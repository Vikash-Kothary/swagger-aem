/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * OpenAPI spec version: 3.2.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface InstallStatus
 */
export interface InstallStatus {
    /**
     * 
     * @type {InstallStatusStatus}
     * @memberof InstallStatus
     */
    status?: InstallStatusStatus;
}

/**
 * 
 * @export
 * @interface InstallStatusStatus
 */
export interface InstallStatusStatus {
    /**
     * 
     * @type {boolean}
     * @memberof InstallStatusStatus
     */
    finished?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InstallStatusStatus
     */
    itemCount?: number;
}

/**
 * 
 * @export
 * @interface KeystoreChainItems
 */
export interface KeystoreChainItems {
    /**
     * e.g. \"CN=localhost\"
     * @type {string}
     * @memberof KeystoreChainItems
     */
    subject?: string;
    /**
     * e.g. \"CN=Admin\"
     * @type {string}
     * @memberof KeystoreChainItems
     */
    issuer?: string;
    /**
     * e.g. \"Sun Jul 01 12:00:00 AEST 2018\"
     * @type {string}
     * @memberof KeystoreChainItems
     */
    notBefore?: string;
    /**
     * e.g. \"Sun Jun 30 23:59:50 AEST 2019\"
     * @type {string}
     * @memberof KeystoreChainItems
     */
    notAfter?: string;
    /**
     * 18165099476682912368
     * @type {number}
     * @memberof KeystoreChainItems
     */
    serialNumber?: number;
}

/**
 * 
 * @export
 * @interface KeystoreInfo
 */
export interface KeystoreInfo {
    /**
     * 
     * @type {Array<KeystoreItems>}
     * @memberof KeystoreInfo
     */
    aliases?: Array<KeystoreItems>;
    /**
     * False if truststore don't exist
     * @type {boolean}
     * @memberof KeystoreInfo
     */
    exists?: boolean;
}

/**
 * 
 * @export
 * @interface KeystoreItems
 */
export interface KeystoreItems {
    /**
     * Keystore alias name
     * @type {string}
     * @memberof KeystoreItems
     */
    alias?: string;
    /**
     * e.g. \"privateKey\"
     * @type {string}
     * @memberof KeystoreItems
     */
    entryType?: string;
    /**
     * e.g. \"RSA\"
     * @type {string}
     * @memberof KeystoreItems
     */
    algorithm?: string;
    /**
     * e.g. \"PKCS#8\"
     * @type {string}
     * @memberof KeystoreItems
     */
    format?: string;
    /**
     * 
     * @type {Array<KeystoreChainItems>}
     * @memberof KeystoreItems
     */
    chain?: Array<KeystoreChainItems>;
}

/**
 * 
 * @export
 * @interface SamlConfigurationInfo
 */
export interface SamlConfigurationInfo {
    /**
     * Persistent Identity (PID)
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    pid?: string;
    /**
     * Title
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    title?: string;
    /**
     * Title
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    description?: string;
    /**
     * needed for configuration binding
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    bundleLocation?: string;
    /**
     * needed for configuraiton binding
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    serviceLocation?: string;
    /**
     * 
     * @type {SamlConfigurationProperties}
     * @memberof SamlConfigurationInfo
     */
    properties?: SamlConfigurationProperties;
}

/**
 * 
 * @export
 * @interface SamlConfigurationProperties
 */
export interface SamlConfigurationProperties {
    /**
     * 
     * @type {SamlConfigurationPropertyItemsArray}
     * @memberof SamlConfigurationProperties
     */
    path?: SamlConfigurationPropertyItemsArray;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsLong}
     * @memberof SamlConfigurationProperties
     */
    serviceRanking?: SamlConfigurationPropertyItemsLong;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    idpUrl?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    idpCertAlias?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    idpHttpRedirect?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    serviceProviderEntityId?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    assertionConsumerServiceURL?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    spPrivateKeyAlias?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    keyStorePassword?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    defaultRedirectUrl?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    userIDAttribute?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    useEncryption?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    createUser?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    addGroupMemberships?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    groupMembershipAttribute?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsArray}
     * @memberof SamlConfigurationProperties
     */
    defaultGroups?: SamlConfigurationPropertyItemsArray;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    nameIdFormat?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsArray}
     * @memberof SamlConfigurationProperties
     */
    synchronizeAttributes?: SamlConfigurationPropertyItemsArray;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    handleLogout?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    logoutUrl?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsLong}
     * @memberof SamlConfigurationProperties
     */
    clockTolerance?: SamlConfigurationPropertyItemsLong;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    digestMethod?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    signatureMethod?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    userIntermediatePath?: SamlConfigurationPropertyItemsString;
}

/**
 * 
 * @export
 * @interface SamlConfigurationPropertyItemsArray
 */
export interface SamlConfigurationPropertyItemsArray {
    /**
     * property name
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    name?: string;
    /**
     * True if optional
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    optional?: boolean;
    /**
     * True if property is set
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    isSet?: boolean;
    /**
     * Property type, 1=String, 3=long, 11=boolean, 12=Password
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    type?: number;
    /**
     * Property value
     * @type {Array<string>}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    values?: Array<string>;
    /**
     * Property description
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface SamlConfigurationPropertyItemsBoolean
 */
export interface SamlConfigurationPropertyItemsBoolean {
    /**
     * property name
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    name?: string;
    /**
     * True if optional
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    optional?: boolean;
    /**
     * True if property is set
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    isSet?: boolean;
    /**
     * Property type, 1=String, 3=long, 11=boolean, 12=Password
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    type?: number;
    /**
     * Property value
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    value?: boolean;
    /**
     * Property description
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface SamlConfigurationPropertyItemsLong
 */
export interface SamlConfigurationPropertyItemsLong {
    /**
     * property name
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    name?: string;
    /**
     * True if optional
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    optional?: boolean;
    /**
     * True if property is set
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    isSet?: boolean;
    /**
     * Property type, 1=String, 3=long, 11=boolean, 12=Password
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    type?: number;
    /**
     * Property value
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    value?: number;
    /**
     * Property description
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface SamlConfigurationPropertyItemsString
 */
export interface SamlConfigurationPropertyItemsString {
    /**
     * property name
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsString
     */
    name?: string;
    /**
     * True if optional
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsString
     */
    optional?: boolean;
    /**
     * True if property is set
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsString
     */
    isSet?: boolean;
    /**
     * Property type, 1=String, 3=long, 11=boolean, 12=Password
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsString
     */
    type?: number;
    /**
     * Property value
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsString
     */
    value?: string;
    /**
     * Property description
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsString
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface TruststoreInfo
 */
export interface TruststoreInfo {
    /**
     * 
     * @type {Array<TruststoreItems>}
     * @memberof TruststoreInfo
     */
    aliases?: Array<TruststoreItems>;
    /**
     * False if truststore don't exist
     * @type {boolean}
     * @memberof TruststoreInfo
     */
    exists?: boolean;
}

/**
 * 
 * @export
 * @interface TruststoreItems
 */
export interface TruststoreItems {
    /**
     * Truststore alias name
     * @type {string}
     * @memberof TruststoreItems
     */
    alias?: string;
    /**
     * 
     * @type {string}
     * @memberof TruststoreItems
     */
    entryType?: string;
    /**
     * e.g. \"CN=localhost\"
     * @type {string}
     * @memberof TruststoreItems
     */
    subject?: string;
    /**
     * e.g. \"CN=Admin\"
     * @type {string}
     * @memberof TruststoreItems
     */
    issuer?: string;
    /**
     * e.g. \"Sun Jul 01 12:00:00 AEST 2018\"
     * @type {string}
     * @memberof TruststoreItems
     */
    notBefore?: string;
    /**
     * e.g. \"Sun Jun 30 23:59:50 AEST 2019\"
     * @type {string}
     * @memberof TruststoreItems
     */
    notAfter?: string;
    /**
     * 18165099476682912368
     * @type {number}
     * @memberof TruststoreItems
     */
    serialNumber?: number;
}


/**
 * ConsoleApi - fetch parameter creator
 * @export
 */
export const ConsoleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAemProductInfo(options: any = {}): FetchArgs {
            const localVarPath = `/system/console/status-productinfo.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigMgr(options: any = {}): FetchArgs {
            const localVarPath = `/system/console/configMgr`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBundle(name: string, action: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postBundle.');
            }
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling postBundle.');
            }
            const localVarPath = `/system/console/bundles/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJmxRepository(action: string, options: any = {}): FetchArgs {
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling postJmxRepository.');
            }
            const localVarPath = `/system/console/jmx/com.adobe.granite:type=Repository/op/{action}`
                .replace(`{${"action"}}`, encodeURIComponent(String(action)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [post] 
         * @param {boolean} [apply] 
         * @param {boolean} [_delete] 
         * @param {string} [action] 
         * @param {string} [$location] 
         * @param {Array<string>} [path] 
         * @param {number} [serviceRanking] 
         * @param {string} [idpUrl] 
         * @param {string} [idpCertAlias] 
         * @param {boolean} [idpHttpRedirect] 
         * @param {string} [serviceProviderEntityId] 
         * @param {string} [assertionConsumerServiceURL] 
         * @param {string} [spPrivateKeyAlias] 
         * @param {string} [keyStorePassword] 
         * @param {string} [defaultRedirectUrl] 
         * @param {string} [userIDAttribute] 
         * @param {boolean} [useEncryption] 
         * @param {boolean} [createUser] 
         * @param {boolean} [addGroupMemberships] 
         * @param {string} [groupMembershipAttribute] 
         * @param {Array<string>} [defaultGroups] 
         * @param {string} [nameIdFormat] 
         * @param {Array<string>} [synchronizeAttributes] 
         * @param {boolean} [handleLogout] 
         * @param {string} [logoutUrl] 
         * @param {number} [clockTolerance] 
         * @param {string} [digestMethod] 
         * @param {string} [signatureMethod] 
         * @param {string} [userIntermediatePath] 
         * @param {Array<string>} [propertylist] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSamlConfiguration(post?: boolean, apply?: boolean, _delete?: boolean, action?: string, $location?: string, path?: Array<string>, serviceRanking?: number, idpUrl?: string, idpCertAlias?: string, idpHttpRedirect?: boolean, serviceProviderEntityId?: string, assertionConsumerServiceURL?: string, spPrivateKeyAlias?: string, keyStorePassword?: string, defaultRedirectUrl?: string, userIDAttribute?: string, useEncryption?: boolean, createUser?: boolean, addGroupMemberships?: boolean, groupMembershipAttribute?: string, defaultGroups?: Array<string>, nameIdFormat?: string, synchronizeAttributes?: Array<string>, handleLogout?: boolean, logoutUrl?: string, clockTolerance?: number, digestMethod?: string, signatureMethod?: string, userIntermediatePath?: string, propertylist?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (post !== undefined) {
                localVarQueryParameter['post'] = post;
            }

            if (apply !== undefined) {
                localVarQueryParameter['apply'] = apply;
            }

            if (_delete !== undefined) {
                localVarQueryParameter['delete'] = _delete;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if ($location !== undefined) {
                localVarQueryParameter['$location'] = $location;
            }

            if (path) {
                localVarQueryParameter['path'] = path;
            }

            if (serviceRanking !== undefined) {
                localVarQueryParameter['service.ranking'] = serviceRanking;
            }

            if (idpUrl !== undefined) {
                localVarQueryParameter['idpUrl'] = idpUrl;
            }

            if (idpCertAlias !== undefined) {
                localVarQueryParameter['idpCertAlias'] = idpCertAlias;
            }

            if (idpHttpRedirect !== undefined) {
                localVarQueryParameter['idpHttpRedirect'] = idpHttpRedirect;
            }

            if (serviceProviderEntityId !== undefined) {
                localVarQueryParameter['serviceProviderEntityId'] = serviceProviderEntityId;
            }

            if (assertionConsumerServiceURL !== undefined) {
                localVarQueryParameter['assertionConsumerServiceURL'] = assertionConsumerServiceURL;
            }

            if (spPrivateKeyAlias !== undefined) {
                localVarQueryParameter['spPrivateKeyAlias'] = spPrivateKeyAlias;
            }

            if (keyStorePassword !== undefined) {
                localVarQueryParameter['keyStorePassword'] = keyStorePassword;
            }

            if (defaultRedirectUrl !== undefined) {
                localVarQueryParameter['defaultRedirectUrl'] = defaultRedirectUrl;
            }

            if (userIDAttribute !== undefined) {
                localVarQueryParameter['userIDAttribute'] = userIDAttribute;
            }

            if (useEncryption !== undefined) {
                localVarQueryParameter['useEncryption'] = useEncryption;
            }

            if (createUser !== undefined) {
                localVarQueryParameter['createUser'] = createUser;
            }

            if (addGroupMemberships !== undefined) {
                localVarQueryParameter['addGroupMemberships'] = addGroupMemberships;
            }

            if (groupMembershipAttribute !== undefined) {
                localVarQueryParameter['groupMembershipAttribute'] = groupMembershipAttribute;
            }

            if (defaultGroups) {
                localVarQueryParameter['defaultGroups'] = defaultGroups;
            }

            if (nameIdFormat !== undefined) {
                localVarQueryParameter['nameIdFormat'] = nameIdFormat;
            }

            if (synchronizeAttributes) {
                localVarQueryParameter['synchronizeAttributes'] = synchronizeAttributes;
            }

            if (handleLogout !== undefined) {
                localVarQueryParameter['handleLogout'] = handleLogout;
            }

            if (logoutUrl !== undefined) {
                localVarQueryParameter['logoutUrl'] = logoutUrl;
            }

            if (clockTolerance !== undefined) {
                localVarQueryParameter['clockTolerance'] = clockTolerance;
            }

            if (digestMethod !== undefined) {
                localVarQueryParameter['digestMethod'] = digestMethod;
            }

            if (signatureMethod !== undefined) {
                localVarQueryParameter['signatureMethod'] = signatureMethod;
            }

            if (userIntermediatePath !== undefined) {
                localVarQueryParameter['userIntermediatePath'] = userIntermediatePath;
            }

            if (propertylist) {
                localVarQueryParameter['propertylist'] = propertylist.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConsoleApi - functional programming interface
 * @export
 */
export const ConsoleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAemProductInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).getAemProductInfo(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigMgr(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).getConfigMgr(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBundle(name: string, action: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).postBundle(name, action, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJmxRepository(action: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).postJmxRepository(action, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {boolean} [post] 
         * @param {boolean} [apply] 
         * @param {boolean} [_delete] 
         * @param {string} [action] 
         * @param {string} [$location] 
         * @param {Array<string>} [path] 
         * @param {number} [serviceRanking] 
         * @param {string} [idpUrl] 
         * @param {string} [idpCertAlias] 
         * @param {boolean} [idpHttpRedirect] 
         * @param {string} [serviceProviderEntityId] 
         * @param {string} [assertionConsumerServiceURL] 
         * @param {string} [spPrivateKeyAlias] 
         * @param {string} [keyStorePassword] 
         * @param {string} [defaultRedirectUrl] 
         * @param {string} [userIDAttribute] 
         * @param {boolean} [useEncryption] 
         * @param {boolean} [createUser] 
         * @param {boolean} [addGroupMemberships] 
         * @param {string} [groupMembershipAttribute] 
         * @param {Array<string>} [defaultGroups] 
         * @param {string} [nameIdFormat] 
         * @param {Array<string>} [synchronizeAttributes] 
         * @param {boolean} [handleLogout] 
         * @param {string} [logoutUrl] 
         * @param {number} [clockTolerance] 
         * @param {string} [digestMethod] 
         * @param {string} [signatureMethod] 
         * @param {string} [userIntermediatePath] 
         * @param {Array<string>} [propertylist] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSamlConfiguration(post?: boolean, apply?: boolean, _delete?: boolean, action?: string, $location?: string, path?: Array<string>, serviceRanking?: number, idpUrl?: string, idpCertAlias?: string, idpHttpRedirect?: boolean, serviceProviderEntityId?: string, assertionConsumerServiceURL?: string, spPrivateKeyAlias?: string, keyStorePassword?: string, defaultRedirectUrl?: string, userIDAttribute?: string, useEncryption?: boolean, createUser?: boolean, addGroupMemberships?: boolean, groupMembershipAttribute?: string, defaultGroups?: Array<string>, nameIdFormat?: string, synchronizeAttributes?: Array<string>, handleLogout?: boolean, logoutUrl?: string, clockTolerance?: number, digestMethod?: string, signatureMethod?: string, userIntermediatePath?: string, propertylist?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SamlConfigurationInfo> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).postSamlConfiguration(post, apply, _delete, action, $location, path, serviceRanking, idpUrl, idpCertAlias, idpHttpRedirect, serviceProviderEntityId, assertionConsumerServiceURL, spPrivateKeyAlias, keyStorePassword, defaultRedirectUrl, userIDAttribute, useEncryption, createUser, addGroupMemberships, groupMembershipAttribute, defaultGroups, nameIdFormat, synchronizeAttributes, handleLogout, logoutUrl, clockTolerance, digestMethod, signatureMethod, userIntermediatePath, propertylist, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConsoleApi - factory interface
 * @export
 */
export const ConsoleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAemProductInfo(options?: any) {
            return ConsoleApiFp(configuration).getAemProductInfo(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigMgr(options?: any) {
            return ConsoleApiFp(configuration).getConfigMgr(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {string} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBundle(name: string, action: string, options?: any) {
            return ConsoleApiFp(configuration).postBundle(name, action, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJmxRepository(action: string, options?: any) {
            return ConsoleApiFp(configuration).postJmxRepository(action, options)(fetch, basePath);
        },
        /**
         * 
         * @param {boolean} [post] 
         * @param {boolean} [apply] 
         * @param {boolean} [_delete] 
         * @param {string} [action] 
         * @param {string} [$location] 
         * @param {Array<string>} [path] 
         * @param {number} [serviceRanking] 
         * @param {string} [idpUrl] 
         * @param {string} [idpCertAlias] 
         * @param {boolean} [idpHttpRedirect] 
         * @param {string} [serviceProviderEntityId] 
         * @param {string} [assertionConsumerServiceURL] 
         * @param {string} [spPrivateKeyAlias] 
         * @param {string} [keyStorePassword] 
         * @param {string} [defaultRedirectUrl] 
         * @param {string} [userIDAttribute] 
         * @param {boolean} [useEncryption] 
         * @param {boolean} [createUser] 
         * @param {boolean} [addGroupMemberships] 
         * @param {string} [groupMembershipAttribute] 
         * @param {Array<string>} [defaultGroups] 
         * @param {string} [nameIdFormat] 
         * @param {Array<string>} [synchronizeAttributes] 
         * @param {boolean} [handleLogout] 
         * @param {string} [logoutUrl] 
         * @param {number} [clockTolerance] 
         * @param {string} [digestMethod] 
         * @param {string} [signatureMethod] 
         * @param {string} [userIntermediatePath] 
         * @param {Array<string>} [propertylist] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSamlConfiguration(post?: boolean, apply?: boolean, _delete?: boolean, action?: string, $location?: string, path?: Array<string>, serviceRanking?: number, idpUrl?: string, idpCertAlias?: string, idpHttpRedirect?: boolean, serviceProviderEntityId?: string, assertionConsumerServiceURL?: string, spPrivateKeyAlias?: string, keyStorePassword?: string, defaultRedirectUrl?: string, userIDAttribute?: string, useEncryption?: boolean, createUser?: boolean, addGroupMemberships?: boolean, groupMembershipAttribute?: string, defaultGroups?: Array<string>, nameIdFormat?: string, synchronizeAttributes?: Array<string>, handleLogout?: boolean, logoutUrl?: string, clockTolerance?: number, digestMethod?: string, signatureMethod?: string, userIntermediatePath?: string, propertylist?: Array<string>, options?: any) {
            return ConsoleApiFp(configuration).postSamlConfiguration(post, apply, _delete, action, $location, path, serviceRanking, idpUrl, idpCertAlias, idpHttpRedirect, serviceProviderEntityId, assertionConsumerServiceURL, spPrivateKeyAlias, keyStorePassword, defaultRedirectUrl, userIDAttribute, useEncryption, createUser, addGroupMemberships, groupMembershipAttribute, defaultGroups, nameIdFormat, synchronizeAttributes, handleLogout, logoutUrl, clockTolerance, digestMethod, signatureMethod, userIntermediatePath, propertylist, options)(fetch, basePath);
        },
    };
};

/**
 * ConsoleApi - object-oriented interface
 * @export
 * @class ConsoleApi
 * @extends {BaseAPI}
 */
export class ConsoleApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsoleApi
     */
    public getAemProductInfo(options?: any) {
        return ConsoleApiFp(this.configuration).getAemProductInfo(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsoleApi
     */
    public getConfigMgr(options?: any) {
        return ConsoleApiFp(this.configuration).getConfigMgr(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {string} action 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsoleApi
     */
    public postBundle(name: string, action: string, options?: any) {
        return ConsoleApiFp(this.configuration).postBundle(name, action, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} action 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsoleApi
     */
    public postJmxRepository(action: string, options?: any) {
        return ConsoleApiFp(this.configuration).postJmxRepository(action, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {boolean} [post] 
     * @param {boolean} [apply] 
     * @param {boolean} [_delete] 
     * @param {string} [action] 
     * @param {string} [$location] 
     * @param {Array<string>} [path] 
     * @param {number} [serviceRanking] 
     * @param {string} [idpUrl] 
     * @param {string} [idpCertAlias] 
     * @param {boolean} [idpHttpRedirect] 
     * @param {string} [serviceProviderEntityId] 
     * @param {string} [assertionConsumerServiceURL] 
     * @param {string} [spPrivateKeyAlias] 
     * @param {string} [keyStorePassword] 
     * @param {string} [defaultRedirectUrl] 
     * @param {string} [userIDAttribute] 
     * @param {boolean} [useEncryption] 
     * @param {boolean} [createUser] 
     * @param {boolean} [addGroupMemberships] 
     * @param {string} [groupMembershipAttribute] 
     * @param {Array<string>} [defaultGroups] 
     * @param {string} [nameIdFormat] 
     * @param {Array<string>} [synchronizeAttributes] 
     * @param {boolean} [handleLogout] 
     * @param {string} [logoutUrl] 
     * @param {number} [clockTolerance] 
     * @param {string} [digestMethod] 
     * @param {string} [signatureMethod] 
     * @param {string} [userIntermediatePath] 
     * @param {Array<string>} [propertylist] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsoleApi
     */
    public postSamlConfiguration(post?: boolean, apply?: boolean, _delete?: boolean, action?: string, $location?: string, path?: Array<string>, serviceRanking?: number, idpUrl?: string, idpCertAlias?: string, idpHttpRedirect?: boolean, serviceProviderEntityId?: string, assertionConsumerServiceURL?: string, spPrivateKeyAlias?: string, keyStorePassword?: string, defaultRedirectUrl?: string, userIDAttribute?: string, useEncryption?: boolean, createUser?: boolean, addGroupMemberships?: boolean, groupMembershipAttribute?: string, defaultGroups?: Array<string>, nameIdFormat?: string, synchronizeAttributes?: Array<string>, handleLogout?: boolean, logoutUrl?: string, clockTolerance?: number, digestMethod?: string, signatureMethod?: string, userIntermediatePath?: string, propertylist?: Array<string>, options?: any) {
        return ConsoleApiFp(this.configuration).postSamlConfiguration(post, apply, _delete, action, $location, path, serviceRanking, idpUrl, idpCertAlias, idpHttpRedirect, serviceProviderEntityId, assertionConsumerServiceURL, spPrivateKeyAlias, keyStorePassword, defaultRedirectUrl, userIDAttribute, useEncryption, createUser, addGroupMemberships, groupMembershipAttribute, defaultGroups, nameIdFormat, synchronizeAttributes, handleLogout, logoutUrl, clockTolerance, digestMethod, signatureMethod, userIntermediatePath, propertylist, options)(this.fetch, this.basePath);
    }

}

/**
 * CqApi - fetch parameter creator
 * @export
 */
export const CqApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginPage(options: any = {}): FetchArgs {
            const localVarPath = `/libs/granite/core/content/login.html`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} authorizableId 
         * @param {string} changelog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCqActions(authorizableId: string, changelog: string, options: any = {}): FetchArgs {
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling postCqActions.');
            }
            // verify required parameter 'changelog' is not null or undefined
            if (changelog === null || changelog === undefined) {
                throw new RequiredError('changelog','Required parameter changelog was null or undefined when calling postCqActions.');
            }
            const localVarPath = `/.cqactions.html`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorizableId !== undefined) {
                localVarQueryParameter['authorizableId'] = authorizableId;
            }

            if (changelog !== undefined) {
                localVarQueryParameter['changelog'] = changelog;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CqApi - functional programming interface
 * @export
 */
export const CqApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginPage(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CqApiFetchParamCreator(configuration).getLoginPage(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} authorizableId 
         * @param {string} changelog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCqActions(authorizableId: string, changelog: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CqApiFetchParamCreator(configuration).postCqActions(authorizableId, changelog, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CqApi - factory interface
 * @export
 */
export const CqApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginPage(options?: any) {
            return CqApiFp(configuration).getLoginPage(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} authorizableId 
         * @param {string} changelog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCqActions(authorizableId: string, changelog: string, options?: any) {
            return CqApiFp(configuration).postCqActions(authorizableId, changelog, options)(fetch, basePath);
        },
    };
};

/**
 * CqApi - object-oriented interface
 * @export
 * @class CqApi
 * @extends {BaseAPI}
 */
export class CqApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CqApi
     */
    public getLoginPage(options?: any) {
        return CqApiFp(this.configuration).getLoginPage(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} authorizableId 
     * @param {string} changelog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CqApi
     */
    public postCqActions(authorizableId: string, changelog: string, options?: any) {
        return CqApiFp(this.configuration).postCqActions(authorizableId, changelog, options)(this.fetch, this.basePath);
    }

}

/**
 * CrxApi - fetch parameter creator
 * @export
 */
export const CrxApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrxdeStatus(options: any = {}): FetchArgs {
            const localVarPath = `/crx/server/crx.default/jcr:root/.1.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstallStatus(options: any = {}): FetchArgs {
            const localVarPath = `/crx/packmgr/installstatus.jsp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageManagerServlet(options: any = {}): FetchArgs {
            const localVarPath = `/crx/packmgr/service/script.html`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} cmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPackageService(cmd: string, options: any = {}): FetchArgs {
            // verify required parameter 'cmd' is not null or undefined
            if (cmd === null || cmd === undefined) {
                throw new RequiredError('cmd','Required parameter cmd was null or undefined when calling postPackageService.');
            }
            const localVarPath = `/crx/packmgr/service.jsp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (cmd !== undefined) {
                localVarQueryParameter['cmd'] = cmd;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {string} cmd 
         * @param {string} [groupName] 
         * @param {string} [packageName] 
         * @param {string} [packageVersion] 
         * @param {string} [charset] 
         * @param {boolean} [force] 
         * @param {boolean} [recursive] 
         * @param {any} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPackageServiceJson(path: string, cmd: string, groupName?: string, packageName?: string, packageVersion?: string, charset?: string, force?: boolean, recursive?: boolean, _package?: any, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postPackageServiceJson.');
            }
            // verify required parameter 'cmd' is not null or undefined
            if (cmd === null || cmd === undefined) {
                throw new RequiredError('cmd','Required parameter cmd was null or undefined when calling postPackageServiceJson.');
            }
            const localVarPath = `/crx/packmgr/service/.json/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (cmd !== undefined) {
                localVarQueryParameter['cmd'] = cmd;
            }

            if (groupName !== undefined) {
                localVarQueryParameter['groupName'] = groupName;
            }

            if (packageName !== undefined) {
                localVarQueryParameter['packageName'] = packageName;
            }

            if (packageVersion !== undefined) {
                localVarQueryParameter['packageVersion'] = packageVersion;
            }

            if (charset !== undefined) {
                localVarQueryParameter['_charset_'] = charset;
            }

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (_package !== undefined) {
                localVarFormParams.set('package', _package as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupName 
         * @param {string} packageName 
         * @param {string} version 
         * @param {string} path 
         * @param {string} [filter] 
         * @param {string} [charset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPackageUpdate(groupName: string, packageName: string, version: string, path: string, filter?: string, charset?: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupName' is not null or undefined
            if (groupName === null || groupName === undefined) {
                throw new RequiredError('groupName','Required parameter groupName was null or undefined when calling postPackageUpdate.');
            }
            // verify required parameter 'packageName' is not null or undefined
            if (packageName === null || packageName === undefined) {
                throw new RequiredError('packageName','Required parameter packageName was null or undefined when calling postPackageUpdate.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling postPackageUpdate.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postPackageUpdate.');
            }
            const localVarPath = `/crx/packmgr/update.jsp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (groupName !== undefined) {
                localVarQueryParameter['groupName'] = groupName;
            }

            if (packageName !== undefined) {
                localVarQueryParameter['packageName'] = packageName;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (charset !== undefined) {
                localVarQueryParameter['_charset_'] = charset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} old 
         * @param {string} plain 
         * @param {string} verify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSetPassword(old: string, plain: string, verify: string, options: any = {}): FetchArgs {
            // verify required parameter 'old' is not null or undefined
            if (old === null || old === undefined) {
                throw new RequiredError('old','Required parameter old was null or undefined when calling postSetPassword.');
            }
            // verify required parameter 'plain' is not null or undefined
            if (plain === null || plain === undefined) {
                throw new RequiredError('plain','Required parameter plain was null or undefined when calling postSetPassword.');
            }
            // verify required parameter 'verify' is not null or undefined
            if (verify === null || verify === undefined) {
                throw new RequiredError('verify','Required parameter verify was null or undefined when calling postSetPassword.');
            }
            const localVarPath = `/crx/explorer/ui/setpassword.jsp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (old !== undefined) {
                localVarQueryParameter['old'] = old;
            }

            if (plain !== undefined) {
                localVarQueryParameter['plain'] = plain;
            }

            if (verify !== undefined) {
                localVarQueryParameter['verify'] = verify;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CrxApi - functional programming interface
 * @export
 */
export const CrxApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrxdeStatus(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).getCrxdeStatus(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstallStatus(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InstallStatus> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).getInstallStatus(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageManagerServlet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).getPackageManagerServlet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} cmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPackageService(cmd: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).postPackageService(cmd, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {string} cmd 
         * @param {string} [groupName] 
         * @param {string} [packageName] 
         * @param {string} [packageVersion] 
         * @param {string} [charset] 
         * @param {boolean} [force] 
         * @param {boolean} [recursive] 
         * @param {any} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPackageServiceJson(path: string, cmd: string, groupName?: string, packageName?: string, packageVersion?: string, charset?: string, force?: boolean, recursive?: boolean, _package?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).postPackageServiceJson(path, cmd, groupName, packageName, packageVersion, charset, force, recursive, _package, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} groupName 
         * @param {string} packageName 
         * @param {string} version 
         * @param {string} path 
         * @param {string} [filter] 
         * @param {string} [charset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPackageUpdate(groupName: string, packageName: string, version: string, path: string, filter?: string, charset?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).postPackageUpdate(groupName, packageName, version, path, filter, charset, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} old 
         * @param {string} plain 
         * @param {string} verify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSetPassword(old: string, plain: string, verify: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).postSetPassword(old, plain, verify, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CrxApi - factory interface
 * @export
 */
export const CrxApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrxdeStatus(options?: any) {
            return CrxApiFp(configuration).getCrxdeStatus(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstallStatus(options?: any) {
            return CrxApiFp(configuration).getInstallStatus(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageManagerServlet(options?: any) {
            return CrxApiFp(configuration).getPackageManagerServlet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} cmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPackageService(cmd: string, options?: any) {
            return CrxApiFp(configuration).postPackageService(cmd, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} path 
         * @param {string} cmd 
         * @param {string} [groupName] 
         * @param {string} [packageName] 
         * @param {string} [packageVersion] 
         * @param {string} [charset] 
         * @param {boolean} [force] 
         * @param {boolean} [recursive] 
         * @param {any} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPackageServiceJson(path: string, cmd: string, groupName?: string, packageName?: string, packageVersion?: string, charset?: string, force?: boolean, recursive?: boolean, _package?: any, options?: any) {
            return CrxApiFp(configuration).postPackageServiceJson(path, cmd, groupName, packageName, packageVersion, charset, force, recursive, _package, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} groupName 
         * @param {string} packageName 
         * @param {string} version 
         * @param {string} path 
         * @param {string} [filter] 
         * @param {string} [charset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPackageUpdate(groupName: string, packageName: string, version: string, path: string, filter?: string, charset?: string, options?: any) {
            return CrxApiFp(configuration).postPackageUpdate(groupName, packageName, version, path, filter, charset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} old 
         * @param {string} plain 
         * @param {string} verify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSetPassword(old: string, plain: string, verify: string, options?: any) {
            return CrxApiFp(configuration).postSetPassword(old, plain, verify, options)(fetch, basePath);
        },
    };
};

/**
 * CrxApi - object-oriented interface
 * @export
 * @class CrxApi
 * @extends {BaseAPI}
 */
export class CrxApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrxApi
     */
    public getCrxdeStatus(options?: any) {
        return CrxApiFp(this.configuration).getCrxdeStatus(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrxApi
     */
    public getInstallStatus(options?: any) {
        return CrxApiFp(this.configuration).getInstallStatus(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrxApi
     */
    public getPackageManagerServlet(options?: any) {
        return CrxApiFp(this.configuration).getPackageManagerServlet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} cmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrxApi
     */
    public postPackageService(cmd: string, options?: any) {
        return CrxApiFp(this.configuration).postPackageService(cmd, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} path 
     * @param {string} cmd 
     * @param {string} [groupName] 
     * @param {string} [packageName] 
     * @param {string} [packageVersion] 
     * @param {string} [charset] 
     * @param {boolean} [force] 
     * @param {boolean} [recursive] 
     * @param {any} [_package] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrxApi
     */
    public postPackageServiceJson(path: string, cmd: string, groupName?: string, packageName?: string, packageVersion?: string, charset?: string, force?: boolean, recursive?: boolean, _package?: any, options?: any) {
        return CrxApiFp(this.configuration).postPackageServiceJson(path, cmd, groupName, packageName, packageVersion, charset, force, recursive, _package, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} groupName 
     * @param {string} packageName 
     * @param {string} version 
     * @param {string} path 
     * @param {string} [filter] 
     * @param {string} [charset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrxApi
     */
    public postPackageUpdate(groupName: string, packageName: string, version: string, path: string, filter?: string, charset?: string, options?: any) {
        return CrxApiFp(this.configuration).postPackageUpdate(groupName, packageName, version, path, filter, charset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} old 
     * @param {string} plain 
     * @param {string} verify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrxApi
     */
    public postSetPassword(old: string, plain: string, verify: string, options?: any) {
        return CrxApiFp(this.configuration).postSetPassword(old, plain, verify, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomApi - fetch parameter creator
 * @export
 */
export const CustomApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [tags] 
         * @param {boolean} [combineTagsOr] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAemHealthCheck(tags?: string, combineTagsOr?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/system/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (combineTagsOr !== undefined) {
                localVarQueryParameter['combineTagsOr'] = combineTagsOr;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [bundlesIgnored] 
         * @param {string} [bundlesIgnored@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigAemHealthCheckServlet(bundlesIgnored?: Array<string>, bundlesIgnored@TypeHint?: string, options: any = {}): FetchArgs {
            const localVarPath = `/apps/system/config/com.shinesolutions.healthcheck.hc.impl.ActiveBundleHealthCheck`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (bundlesIgnored) {
                localVarQueryParameter['bundles.ignored'] = bundlesIgnored;
            }

            if (bundlesIgnored@TypeHint !== undefined) {
                localVarQueryParameter['bundles.ignored@TypeHint'] = bundlesIgnored@TypeHint;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [pwdresetAuthorizables] 
         * @param {string} [pwdresetAuthorizables@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigAemPasswordReset(pwdresetAuthorizables?: Array<string>, pwdresetAuthorizables@TypeHint?: string, options: any = {}): FetchArgs {
            const localVarPath = `/apps/system/config/com.shinesolutions.aem.passwordreset.Activator`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (pwdresetAuthorizables) {
                localVarQueryParameter['pwdreset.authorizables'] = pwdresetAuthorizables;
            }

            if (pwdresetAuthorizables@TypeHint !== undefined) {
                localVarQueryParameter['pwdreset.authorizables@TypeHint'] = pwdresetAuthorizables@TypeHint;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomApi - functional programming interface
 * @export
 */
export const CustomApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [tags] 
         * @param {boolean} [combineTagsOr] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAemHealthCheck(tags?: string, combineTagsOr?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CustomApiFetchParamCreator(configuration).getAemHealthCheck(tags, combineTagsOr, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Array<string>} [bundlesIgnored] 
         * @param {string} [bundlesIgnored@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigAemHealthCheckServlet(bundlesIgnored?: Array<string>, bundlesIgnored@TypeHint?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CustomApiFetchParamCreator(configuration).postConfigAemHealthCheckServlet(bundlesIgnored, bundlesIgnored@TypeHint, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Array<string>} [pwdresetAuthorizables] 
         * @param {string} [pwdresetAuthorizables@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigAemPasswordReset(pwdresetAuthorizables?: Array<string>, pwdresetAuthorizables@TypeHint?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CustomApiFetchParamCreator(configuration).postConfigAemPasswordReset(pwdresetAuthorizables, pwdresetAuthorizables@TypeHint, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomApi - factory interface
 * @export
 */
export const CustomApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [tags] 
         * @param {boolean} [combineTagsOr] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAemHealthCheck(tags?: string, combineTagsOr?: boolean, options?: any) {
            return CustomApiFp(configuration).getAemHealthCheck(tags, combineTagsOr, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Array<string>} [bundlesIgnored] 
         * @param {string} [bundlesIgnored@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigAemHealthCheckServlet(bundlesIgnored?: Array<string>, bundlesIgnored@TypeHint?: string, options?: any) {
            return CustomApiFp(configuration).postConfigAemHealthCheckServlet(bundlesIgnored, bundlesIgnored@TypeHint, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Array<string>} [pwdresetAuthorizables] 
         * @param {string} [pwdresetAuthorizables@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigAemPasswordReset(pwdresetAuthorizables?: Array<string>, pwdresetAuthorizables@TypeHint?: string, options?: any) {
            return CustomApiFp(configuration).postConfigAemPasswordReset(pwdresetAuthorizables, pwdresetAuthorizables@TypeHint, options)(fetch, basePath);
        },
    };
};

/**
 * CustomApi - object-oriented interface
 * @export
 * @class CustomApi
 * @extends {BaseAPI}
 */
export class CustomApi extends BaseAPI {
    /**
     * 
     * @param {string} [tags] 
     * @param {boolean} [combineTagsOr] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomApi
     */
    public getAemHealthCheck(tags?: string, combineTagsOr?: boolean, options?: any) {
        return CustomApiFp(this.configuration).getAemHealthCheck(tags, combineTagsOr, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Array<string>} [bundlesIgnored] 
     * @param {string} [bundlesIgnored@TypeHint] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomApi
     */
    public postConfigAemHealthCheckServlet(bundlesIgnored?: Array<string>, bundlesIgnored@TypeHint?: string, options?: any) {
        return CustomApiFp(this.configuration).postConfigAemHealthCheckServlet(bundlesIgnored, bundlesIgnored@TypeHint, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Array<string>} [pwdresetAuthorizables] 
     * @param {string} [pwdresetAuthorizables@TypeHint] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomApi
     */
    public postConfigAemPasswordReset(pwdresetAuthorizables?: Array<string>, pwdresetAuthorizables@TypeHint?: string, options?: any) {
        return CustomApiFp(this.configuration).postConfigAemPasswordReset(pwdresetAuthorizables, pwdresetAuthorizables@TypeHint, options)(this.fetch, this.basePath);
    }

}

/**
 * SlingApi - fetch parameter creator
 * @export
 */
export const SlingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} runmode 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent(runmode: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'runmode' is not null or undefined
            if (runmode === null || runmode === undefined) {
                throw new RequiredError('runmode','Required parameter runmode was null or undefined when calling deleteAgent.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteAgent.');
            }
            const localVarPath = `/etc/replication/agents.{runmode}/{name}`
                .replace(`{${"runmode"}}`, encodeURIComponent(String(runmode)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNode(path: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling deleteNode.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteNode.');
            }
            const localVarPath = `/{path}/{name}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} runmode 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgent(runmode: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'runmode' is not null or undefined
            if (runmode === null || runmode === undefined) {
                throw new RequiredError('runmode','Required parameter runmode was null or undefined when calling getAgent.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getAgent.');
            }
            const localVarPath = `/etc/replication/agents.{runmode}/{name}`
                .replace(`{${"runmode"}}`, encodeURIComponent(String(runmode)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} runmode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgents(runmode: string, options: any = {}): FetchArgs {
            // verify required parameter 'runmode' is not null or undefined
            if (runmode === null || runmode === undefined) {
                throw new RequiredError('runmode','Required parameter runmode was null or undefined when calling getAgents.');
            }
            const localVarPath = `/etc/replication/agents.{runmode}.-1.json`
                .replace(`{${"runmode"}}`, encodeURIComponent(String(runmode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} intermediatePath 
         * @param {string} authorizableId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizableKeystore(intermediatePath: string, authorizableId: string, options: any = {}): FetchArgs {
            // verify required parameter 'intermediatePath' is not null or undefined
            if (intermediatePath === null || intermediatePath === undefined) {
                throw new RequiredError('intermediatePath','Required parameter intermediatePath was null or undefined when calling getAuthorizableKeystore.');
            }
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling getAuthorizableKeystore.');
            }
            const localVarPath = `/{intermediatePath}/{authorizableId}.ks.json`
                .replace(`{${"intermediatePath"}}`, encodeURIComponent(String(intermediatePath)))
                .replace(`{${"authorizableId"}}`, encodeURIComponent(String(authorizableId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} intermediatePath 
         * @param {string} authorizableId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeystore(intermediatePath: string, authorizableId: string, options: any = {}): FetchArgs {
            // verify required parameter 'intermediatePath' is not null or undefined
            if (intermediatePath === null || intermediatePath === undefined) {
                throw new RequiredError('intermediatePath','Required parameter intermediatePath was null or undefined when calling getKeystore.');
            }
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling getKeystore.');
            }
            const localVarPath = `/{intermediatePath}/{authorizableId}/keystore/store.p12`
                .replace(`{${"intermediatePath"}}`, encodeURIComponent(String(intermediatePath)))
                .replace(`{${"authorizableId"}}`, encodeURIComponent(String(authorizableId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode(path: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getNode.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getNode.');
            }
            const localVarPath = `/{path}/{name}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} group 
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackage(group: string, name: string, version: string, options: any = {}): FetchArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getPackage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPackage.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getPackage.');
            }
            const localVarPath = `/etc/packages/{group}/{name}-{version}.zip`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} group 
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageFilter(group: string, name: string, version: string, options: any = {}): FetchArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getPackageFilter.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPackageFilter.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getPackageFilter.');
            }
            const localVarPath = `/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {number} pLimit 
         * @param {string} _1property 
         * @param {string} _1propertyValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getQuery.');
            }
            // verify required parameter 'pLimit' is not null or undefined
            if (pLimit === null || pLimit === undefined) {
                throw new RequiredError('pLimit','Required parameter pLimit was null or undefined when calling getQuery.');
            }
            // verify required parameter '_1property' is not null or undefined
            if (_1property === null || _1property === undefined) {
                throw new RequiredError('_1property','Required parameter _1property was null or undefined when calling getQuery.');
            }
            // verify required parameter '_1propertyValue' is not null or undefined
            if (_1propertyValue === null || _1propertyValue === undefined) {
                throw new RequiredError('_1propertyValue','Required parameter _1propertyValue was null or undefined when calling getQuery.');
            }
            const localVarPath = `/bin/querybuilder.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (pLimit !== undefined) {
                localVarQueryParameter['p.limit'] = pLimit;
            }

            if (_1property !== undefined) {
                localVarQueryParameter['1_property'] = _1property;
            }

            if (_1propertyValue !== undefined) {
                localVarQueryParameter['1_property.value'] = _1propertyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTruststore(options: any = {}): FetchArgs {
            const localVarPath = `/etc/truststore/truststore.p12`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTruststoreInfo(options: any = {}): FetchArgs {
            const localVarPath = `/libs/granite/security/truststore.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} runmode 
         * @param {string} name 
         * @param {boolean} [jcr:contentCq:distribute] 
         * @param {string} [jcr:contentCq:distribute@TypeHint] 
         * @param {string} [jcr:contentCq:name] 
         * @param {string} [jcr:contentCq:template] 
         * @param {boolean} [jcr:contentEnabled] 
         * @param {string} [jcr:contentJcr:description] 
         * @param {string} [jcr:contentJcr:lastModified] 
         * @param {string} [jcr:contentJcr:lastModifiedBy] 
         * @param {string} [jcr:contentJcr:mixinTypes] 
         * @param {string} [jcr:contentJcr:title] 
         * @param {string} [jcr:contentLogLevel] 
         * @param {boolean} [jcr:contentNoStatusUpdate] 
         * @param {boolean} [jcr:contentNoVersioning] 
         * @param {number} [jcr:contentProtocolConnectTimeout] 
         * @param {boolean} [jcr:contentProtocolHTTPConnectionClosed] 
         * @param {string} [jcr:contentProtocolHTTPExpired] 
         * @param {Array<string>} [jcr:contentProtocolHTTPHeaders] 
         * @param {string} [jcr:contentProtocolHTTPHeaders@TypeHint] 
         * @param {string} [jcr:contentProtocolHTTPMethod] 
         * @param {boolean} [jcr:contentProtocolHTTPSRelaxed] 
         * @param {string} [jcr:contentProtocolInterface] 
         * @param {number} [jcr:contentProtocolSocketTimeout] 
         * @param {string} [jcr:contentProtocolVersion] 
         * @param {string} [jcr:contentProxyNTLMDomain] 
         * @param {string} [jcr:contentProxyNTLMHost] 
         * @param {string} [jcr:contentProxyHost] 
         * @param {string} [jcr:contentProxyPassword] 
         * @param {number} [jcr:contentProxyPort] 
         * @param {string} [jcr:contentProxyUser] 
         * @param {number} [jcr:contentQueueBatchMaxSize] 
         * @param {string} [jcr:contentQueueBatchMode] 
         * @param {number} [jcr:contentQueueBatchWaitTime] 
         * @param {string} [jcr:contentRetryDelay] 
         * @param {boolean} [jcr:contentReverseReplication] 
         * @param {string} [jcr:contentSerializationType] 
         * @param {string} [jcr:contentSling:resourceType] 
         * @param {string} [jcr:contentSsl] 
         * @param {string} [jcr:contentTransportNTLMDomain] 
         * @param {string} [jcr:contentTransportNTLMHost] 
         * @param {string} [jcr:contentTransportPassword] 
         * @param {string} [jcr:contentTransportUri] 
         * @param {string} [jcr:contentTransportUser] 
         * @param {boolean} [jcr:contentTriggerDistribute] 
         * @param {boolean} [jcr:contentTriggerModified] 
         * @param {boolean} [jcr:contentTriggerOnOffTime] 
         * @param {boolean} [jcr:contentTriggerReceive] 
         * @param {boolean} [jcr:contentTriggerSpecific] 
         * @param {string} [jcr:contentUserId] 
         * @param {string} [jcr:primaryType] 
         * @param {string} [:operation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, options: any = {}): FetchArgs {
            // verify required parameter 'runmode' is not null or undefined
            if (runmode === null || runmode === undefined) {
                throw new RequiredError('runmode','Required parameter runmode was null or undefined when calling postAgent.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postAgent.');
            }
            const localVarPath = `/etc/replication/agents.{runmode}/{name}`
                .replace(`{${"runmode"}}`, encodeURIComponent(String(runmode)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jcr:contentCq:distribute !== undefined) {
                localVarQueryParameter['jcr:content/cq:distribute'] = jcr:contentCq:distribute;
            }

            if (jcr:contentCq:distribute@TypeHint !== undefined) {
                localVarQueryParameter['jcr:content/cq:distribute@TypeHint'] = jcr:contentCq:distribute@TypeHint;
            }

            if (jcr:contentCq:name !== undefined) {
                localVarQueryParameter['jcr:content/cq:name'] = jcr:contentCq:name;
            }

            if (jcr:contentCq:template !== undefined) {
                localVarQueryParameter['jcr:content/cq:template'] = jcr:contentCq:template;
            }

            if (jcr:contentEnabled !== undefined) {
                localVarQueryParameter['jcr:content/enabled'] = jcr:contentEnabled;
            }

            if (jcr:contentJcr:description !== undefined) {
                localVarQueryParameter['jcr:content/jcr:description'] = jcr:contentJcr:description;
            }

            if (jcr:contentJcr:lastModified !== undefined) {
                localVarQueryParameter['jcr:content/jcr:lastModified'] = jcr:contentJcr:lastModified;
            }

            if (jcr:contentJcr:lastModifiedBy !== undefined) {
                localVarQueryParameter['jcr:content/jcr:lastModifiedBy'] = jcr:contentJcr:lastModifiedBy;
            }

            if (jcr:contentJcr:mixinTypes !== undefined) {
                localVarQueryParameter['jcr:content/jcr:mixinTypes'] = jcr:contentJcr:mixinTypes;
            }

            if (jcr:contentJcr:title !== undefined) {
                localVarQueryParameter['jcr:content/jcr:title'] = jcr:contentJcr:title;
            }

            if (jcr:contentLogLevel !== undefined) {
                localVarQueryParameter['jcr:content/logLevel'] = jcr:contentLogLevel;
            }

            if (jcr:contentNoStatusUpdate !== undefined) {
                localVarQueryParameter['jcr:content/noStatusUpdate'] = jcr:contentNoStatusUpdate;
            }

            if (jcr:contentNoVersioning !== undefined) {
                localVarQueryParameter['jcr:content/noVersioning'] = jcr:contentNoVersioning;
            }

            if (jcr:contentProtocolConnectTimeout !== undefined) {
                localVarQueryParameter['jcr:content/protocolConnectTimeout'] = jcr:contentProtocolConnectTimeout;
            }

            if (jcr:contentProtocolHTTPConnectionClosed !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPConnectionClosed'] = jcr:contentProtocolHTTPConnectionClosed;
            }

            if (jcr:contentProtocolHTTPExpired !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPExpired'] = jcr:contentProtocolHTTPExpired;
            }

            if (jcr:contentProtocolHTTPHeaders) {
                localVarQueryParameter['jcr:content/protocolHTTPHeaders'] = jcr:contentProtocolHTTPHeaders;
            }

            if (jcr:contentProtocolHTTPHeaders@TypeHint !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPHeaders@TypeHint'] = jcr:contentProtocolHTTPHeaders@TypeHint;
            }

            if (jcr:contentProtocolHTTPMethod !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPMethod'] = jcr:contentProtocolHTTPMethod;
            }

            if (jcr:contentProtocolHTTPSRelaxed !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPSRelaxed'] = jcr:contentProtocolHTTPSRelaxed;
            }

            if (jcr:contentProtocolInterface !== undefined) {
                localVarQueryParameter['jcr:content/protocolInterface'] = jcr:contentProtocolInterface;
            }

            if (jcr:contentProtocolSocketTimeout !== undefined) {
                localVarQueryParameter['jcr:content/protocolSocketTimeout'] = jcr:contentProtocolSocketTimeout;
            }

            if (jcr:contentProtocolVersion !== undefined) {
                localVarQueryParameter['jcr:content/protocolVersion'] = jcr:contentProtocolVersion;
            }

            if (jcr:contentProxyNTLMDomain !== undefined) {
                localVarQueryParameter['jcr:content/proxyNTLMDomain'] = jcr:contentProxyNTLMDomain;
            }

            if (jcr:contentProxyNTLMHost !== undefined) {
                localVarQueryParameter['jcr:content/proxyNTLMHost'] = jcr:contentProxyNTLMHost;
            }

            if (jcr:contentProxyHost !== undefined) {
                localVarQueryParameter['jcr:content/proxyHost'] = jcr:contentProxyHost;
            }

            if (jcr:contentProxyPassword !== undefined) {
                localVarQueryParameter['jcr:content/proxyPassword'] = jcr:contentProxyPassword;
            }

            if (jcr:contentProxyPort !== undefined) {
                localVarQueryParameter['jcr:content/proxyPort'] = jcr:contentProxyPort;
            }

            if (jcr:contentProxyUser !== undefined) {
                localVarQueryParameter['jcr:content/proxyUser'] = jcr:contentProxyUser;
            }

            if (jcr:contentQueueBatchMaxSize !== undefined) {
                localVarQueryParameter['jcr:content/queueBatchMaxSize'] = jcr:contentQueueBatchMaxSize;
            }

            if (jcr:contentQueueBatchMode !== undefined) {
                localVarQueryParameter['jcr:content/queueBatchMode'] = jcr:contentQueueBatchMode;
            }

            if (jcr:contentQueueBatchWaitTime !== undefined) {
                localVarQueryParameter['jcr:content/queueBatchWaitTime'] = jcr:contentQueueBatchWaitTime;
            }

            if (jcr:contentRetryDelay !== undefined) {
                localVarQueryParameter['jcr:content/retryDelay'] = jcr:contentRetryDelay;
            }

            if (jcr:contentReverseReplication !== undefined) {
                localVarQueryParameter['jcr:content/reverseReplication'] = jcr:contentReverseReplication;
            }

            if (jcr:contentSerializationType !== undefined) {
                localVarQueryParameter['jcr:content/serializationType'] = jcr:contentSerializationType;
            }

            if (jcr:contentSling:resourceType !== undefined) {
                localVarQueryParameter['jcr:content/sling:resourceType'] = jcr:contentSling:resourceType;
            }

            if (jcr:contentSsl !== undefined) {
                localVarQueryParameter['jcr:content/ssl'] = jcr:contentSsl;
            }

            if (jcr:contentTransportNTLMDomain !== undefined) {
                localVarQueryParameter['jcr:content/transportNTLMDomain'] = jcr:contentTransportNTLMDomain;
            }

            if (jcr:contentTransportNTLMHost !== undefined) {
                localVarQueryParameter['jcr:content/transportNTLMHost'] = jcr:contentTransportNTLMHost;
            }

            if (jcr:contentTransportPassword !== undefined) {
                localVarQueryParameter['jcr:content/transportPassword'] = jcr:contentTransportPassword;
            }

            if (jcr:contentTransportUri !== undefined) {
                localVarQueryParameter['jcr:content/transportUri'] = jcr:contentTransportUri;
            }

            if (jcr:contentTransportUser !== undefined) {
                localVarQueryParameter['jcr:content/transportUser'] = jcr:contentTransportUser;
            }

            if (jcr:contentTriggerDistribute !== undefined) {
                localVarQueryParameter['jcr:content/triggerDistribute'] = jcr:contentTriggerDistribute;
            }

            if (jcr:contentTriggerModified !== undefined) {
                localVarQueryParameter['jcr:content/triggerModified'] = jcr:contentTriggerModified;
            }

            if (jcr:contentTriggerOnOffTime !== undefined) {
                localVarQueryParameter['jcr:content/triggerOnOffTime'] = jcr:contentTriggerOnOffTime;
            }

            if (jcr:contentTriggerReceive !== undefined) {
                localVarQueryParameter['jcr:content/triggerReceive'] = jcr:contentTriggerReceive;
            }

            if (jcr:contentTriggerSpecific !== undefined) {
                localVarQueryParameter['jcr:content/triggerSpecific'] = jcr:contentTriggerSpecific;
            }

            if (jcr:contentUserId !== undefined) {
                localVarQueryParameter['jcr:content/userId'] = jcr:contentUserId;
            }

            if (jcr:primaryType !== undefined) {
                localVarQueryParameter['jcr:primaryType'] = jcr:primaryType;
            }

            if (:operation !== undefined) {
                localVarQueryParameter[':operation'] = :operation;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} intermediatePath 
         * @param {string} authorizableId 
         * @param {string} [:operation] 
         * @param {string} [currentPassword] 
         * @param {string} [newPassword] 
         * @param {string} [rePassword] 
         * @param {string} [keyPassword] 
         * @param {string} [keyStorePass] 
         * @param {string} [alias] 
         * @param {string} [newAlias] 
         * @param {string} [removeAlias] 
         * @param {any} [certChain] 
         * @param {any} [pk] 
         * @param {any} [keyStore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: any, pk?: any, keyStore?: any, options: any = {}): FetchArgs {
            // verify required parameter 'intermediatePath' is not null or undefined
            if (intermediatePath === null || intermediatePath === undefined) {
                throw new RequiredError('intermediatePath','Required parameter intermediatePath was null or undefined when calling postAuthorizableKeystore.');
            }
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling postAuthorizableKeystore.');
            }
            const localVarPath = `/{intermediatePath}/{authorizableId}.ks.html`
                .replace(`{${"intermediatePath"}}`, encodeURIComponent(String(intermediatePath)))
                .replace(`{${"authorizableId"}}`, encodeURIComponent(String(authorizableId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (:operation !== undefined) {
                localVarQueryParameter[':operation'] = :operation;
            }

            if (currentPassword !== undefined) {
                localVarQueryParameter['currentPassword'] = currentPassword;
            }

            if (newPassword !== undefined) {
                localVarQueryParameter['newPassword'] = newPassword;
            }

            if (rePassword !== undefined) {
                localVarQueryParameter['rePassword'] = rePassword;
            }

            if (keyPassword !== undefined) {
                localVarQueryParameter['keyPassword'] = keyPassword;
            }

            if (keyStorePass !== undefined) {
                localVarQueryParameter['keyStorePass'] = keyStorePass;
            }

            if (alias !== undefined) {
                localVarQueryParameter['alias'] = alias;
            }

            if (newAlias !== undefined) {
                localVarQueryParameter['newAlias'] = newAlias;
            }

            if (removeAlias !== undefined) {
                localVarQueryParameter['removeAlias'] = removeAlias;
            }

            if (certChain !== undefined) {
                localVarFormParams.set('cert-chain', certChain as any);
            }

            if (pk !== undefined) {
                localVarFormParams.set('pk', pk as any);
            }

            if (keyStore !== undefined) {
                localVarFormParams.set('keyStore', keyStore as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} authorizableId 
         * @param {string} intermediatePath 
         * @param {string} [createUser] 
         * @param {string} [createGroup] 
         * @param {string} [rep:password] 
         * @param {string} [profileGivenName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling postAuthorizables.');
            }
            // verify required parameter 'intermediatePath' is not null or undefined
            if (intermediatePath === null || intermediatePath === undefined) {
                throw new RequiredError('intermediatePath','Required parameter intermediatePath was null or undefined when calling postAuthorizables.');
            }
            const localVarPath = `/libs/granite/security/post/authorizables`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorizableId !== undefined) {
                localVarQueryParameter['authorizableId'] = authorizableId;
            }

            if (intermediatePath !== undefined) {
                localVarQueryParameter['intermediatePath'] = intermediatePath;
            }

            if (createUser !== undefined) {
                localVarQueryParameter['createUser'] = createUser;
            }

            if (createGroup !== undefined) {
                localVarQueryParameter['createGroup'] = createGroup;
            }

            if (rep:password !== undefined) {
                localVarQueryParameter['rep:password'] = rep:password;
            }

            if (profileGivenName !== undefined) {
                localVarQueryParameter['profile/givenName'] = profileGivenName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [keyStorePassword] 
         * @param {string} [keyStorePassword@TypeHint] 
         * @param {number} [serviceRanking] 
         * @param {string} [serviceRanking@TypeHint] 
         * @param {boolean} [idpHttpRedirect] 
         * @param {string} [idpHttpRedirect@TypeHint] 
         * @param {boolean} [createUser] 
         * @param {string} [createUser@TypeHint] 
         * @param {string} [defaultRedirectUrl] 
         * @param {string} [defaultRedirectUrl@TypeHint] 
         * @param {string} [userIDAttribute] 
         * @param {string} [userIDAttribute@TypeHint] 
         * @param {Array<string>} [defaultGroups] 
         * @param {string} [defaultGroups@TypeHint] 
         * @param {string} [idpCertAlias] 
         * @param {string} [idpCertAlias@TypeHint] 
         * @param {boolean} [addGroupMemberships] 
         * @param {string} [addGroupMemberships@TypeHint] 
         * @param {Array<string>} [path] 
         * @param {string} [path@TypeHint] 
         * @param {Array<string>} [synchronizeAttributes] 
         * @param {string} [synchronizeAttributes@TypeHint] 
         * @param {number} [clockTolerance] 
         * @param {string} [clockTolerance@TypeHint] 
         * @param {string} [groupMembershipAttribute] 
         * @param {string} [groupMembershipAttribute@TypeHint] 
         * @param {string} [idpUrl] 
         * @param {string} [idpUrl@TypeHint] 
         * @param {string} [logoutUrl] 
         * @param {string} [logoutUrl@TypeHint] 
         * @param {string} [serviceProviderEntityId] 
         * @param {string} [serviceProviderEntityId@TypeHint] 
         * @param {string} [assertionConsumerServiceURL] 
         * @param {string} [assertionConsumerServiceURL@TypeHint] 
         * @param {boolean} [handleLogout] 
         * @param {string} [handleLogout@TypeHint] 
         * @param {string} [spPrivateKeyAlias] 
         * @param {string} [spPrivateKeyAlias@TypeHint] 
         * @param {boolean} [useEncryption] 
         * @param {string} [useEncryption@TypeHint] 
         * @param {string} [nameIdFormat] 
         * @param {string} [nameIdFormat@TypeHint] 
         * @param {string} [digestMethod] 
         * @param {string} [digestMethod@TypeHint] 
         * @param {string} [signatureMethod] 
         * @param {string} [signatureMethod@TypeHint] 
         * @param {string} [userIntermediatePath] 
         * @param {string} [userIntermediatePath@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, options: any = {}): FetchArgs {
            const localVarPath = `/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (keyStorePassword !== undefined) {
                localVarQueryParameter['keyStorePassword'] = keyStorePassword;
            }

            if (keyStorePassword@TypeHint !== undefined) {
                localVarQueryParameter['keyStorePassword@TypeHint'] = keyStorePassword@TypeHint;
            }

            if (serviceRanking !== undefined) {
                localVarQueryParameter['service.ranking'] = serviceRanking;
            }

            if (serviceRanking@TypeHint !== undefined) {
                localVarQueryParameter['service.ranking@TypeHint'] = serviceRanking@TypeHint;
            }

            if (idpHttpRedirect !== undefined) {
                localVarQueryParameter['idpHttpRedirect'] = idpHttpRedirect;
            }

            if (idpHttpRedirect@TypeHint !== undefined) {
                localVarQueryParameter['idpHttpRedirect@TypeHint'] = idpHttpRedirect@TypeHint;
            }

            if (createUser !== undefined) {
                localVarQueryParameter['createUser'] = createUser;
            }

            if (createUser@TypeHint !== undefined) {
                localVarQueryParameter['createUser@TypeHint'] = createUser@TypeHint;
            }

            if (defaultRedirectUrl !== undefined) {
                localVarQueryParameter['defaultRedirectUrl'] = defaultRedirectUrl;
            }

            if (defaultRedirectUrl@TypeHint !== undefined) {
                localVarQueryParameter['defaultRedirectUrl@TypeHint'] = defaultRedirectUrl@TypeHint;
            }

            if (userIDAttribute !== undefined) {
                localVarQueryParameter['userIDAttribute'] = userIDAttribute;
            }

            if (userIDAttribute@TypeHint !== undefined) {
                localVarQueryParameter['userIDAttribute@TypeHint'] = userIDAttribute@TypeHint;
            }

            if (defaultGroups) {
                localVarQueryParameter['defaultGroups'] = defaultGroups;
            }

            if (defaultGroups@TypeHint !== undefined) {
                localVarQueryParameter['defaultGroups@TypeHint'] = defaultGroups@TypeHint;
            }

            if (idpCertAlias !== undefined) {
                localVarQueryParameter['idpCertAlias'] = idpCertAlias;
            }

            if (idpCertAlias@TypeHint !== undefined) {
                localVarQueryParameter['idpCertAlias@TypeHint'] = idpCertAlias@TypeHint;
            }

            if (addGroupMemberships !== undefined) {
                localVarQueryParameter['addGroupMemberships'] = addGroupMemberships;
            }

            if (addGroupMemberships@TypeHint !== undefined) {
                localVarQueryParameter['addGroupMemberships@TypeHint'] = addGroupMemberships@TypeHint;
            }

            if (path) {
                localVarQueryParameter['path'] = path;
            }

            if (path@TypeHint !== undefined) {
                localVarQueryParameter['path@TypeHint'] = path@TypeHint;
            }

            if (synchronizeAttributes) {
                localVarQueryParameter['synchronizeAttributes'] = synchronizeAttributes;
            }

            if (synchronizeAttributes@TypeHint !== undefined) {
                localVarQueryParameter['synchronizeAttributes@TypeHint'] = synchronizeAttributes@TypeHint;
            }

            if (clockTolerance !== undefined) {
                localVarQueryParameter['clockTolerance'] = clockTolerance;
            }

            if (clockTolerance@TypeHint !== undefined) {
                localVarQueryParameter['clockTolerance@TypeHint'] = clockTolerance@TypeHint;
            }

            if (groupMembershipAttribute !== undefined) {
                localVarQueryParameter['groupMembershipAttribute'] = groupMembershipAttribute;
            }

            if (groupMembershipAttribute@TypeHint !== undefined) {
                localVarQueryParameter['groupMembershipAttribute@TypeHint'] = groupMembershipAttribute@TypeHint;
            }

            if (idpUrl !== undefined) {
                localVarQueryParameter['idpUrl'] = idpUrl;
            }

            if (idpUrl@TypeHint !== undefined) {
                localVarQueryParameter['idpUrl@TypeHint'] = idpUrl@TypeHint;
            }

            if (logoutUrl !== undefined) {
                localVarQueryParameter['logoutUrl'] = logoutUrl;
            }

            if (logoutUrl@TypeHint !== undefined) {
                localVarQueryParameter['logoutUrl@TypeHint'] = logoutUrl@TypeHint;
            }

            if (serviceProviderEntityId !== undefined) {
                localVarQueryParameter['serviceProviderEntityId'] = serviceProviderEntityId;
            }

            if (serviceProviderEntityId@TypeHint !== undefined) {
                localVarQueryParameter['serviceProviderEntityId@TypeHint'] = serviceProviderEntityId@TypeHint;
            }

            if (assertionConsumerServiceURL !== undefined) {
                localVarQueryParameter['assertionConsumerServiceURL'] = assertionConsumerServiceURL;
            }

            if (assertionConsumerServiceURL@TypeHint !== undefined) {
                localVarQueryParameter['assertionConsumerServiceURL@TypeHint'] = assertionConsumerServiceURL@TypeHint;
            }

            if (handleLogout !== undefined) {
                localVarQueryParameter['handleLogout'] = handleLogout;
            }

            if (handleLogout@TypeHint !== undefined) {
                localVarQueryParameter['handleLogout@TypeHint'] = handleLogout@TypeHint;
            }

            if (spPrivateKeyAlias !== undefined) {
                localVarQueryParameter['spPrivateKeyAlias'] = spPrivateKeyAlias;
            }

            if (spPrivateKeyAlias@TypeHint !== undefined) {
                localVarQueryParameter['spPrivateKeyAlias@TypeHint'] = spPrivateKeyAlias@TypeHint;
            }

            if (useEncryption !== undefined) {
                localVarQueryParameter['useEncryption'] = useEncryption;
            }

            if (useEncryption@TypeHint !== undefined) {
                localVarQueryParameter['useEncryption@TypeHint'] = useEncryption@TypeHint;
            }

            if (nameIdFormat !== undefined) {
                localVarQueryParameter['nameIdFormat'] = nameIdFormat;
            }

            if (nameIdFormat@TypeHint !== undefined) {
                localVarQueryParameter['nameIdFormat@TypeHint'] = nameIdFormat@TypeHint;
            }

            if (digestMethod !== undefined) {
                localVarQueryParameter['digestMethod'] = digestMethod;
            }

            if (digestMethod@TypeHint !== undefined) {
                localVarQueryParameter['digestMethod@TypeHint'] = digestMethod@TypeHint;
            }

            if (signatureMethod !== undefined) {
                localVarQueryParameter['signatureMethod'] = signatureMethod;
            }

            if (signatureMethod@TypeHint !== undefined) {
                localVarQueryParameter['signatureMethod@TypeHint'] = signatureMethod@TypeHint;
            }

            if (userIntermediatePath !== undefined) {
                localVarQueryParameter['userIntermediatePath'] = userIntermediatePath;
            }

            if (userIntermediatePath@TypeHint !== undefined) {
                localVarQueryParameter['userIntermediatePath@TypeHint'] = userIntermediatePath@TypeHint;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [orgApacheFelixHttpsNio] 
         * @param {string} [orgApacheFelixHttpsNio@TypeHint] 
         * @param {string} [orgApacheFelixHttpsKeystore] 
         * @param {string} [orgApacheFelixHttpsKeystore@TypeHint] 
         * @param {string} [orgApacheFelixHttpsKeystorePassword] 
         * @param {string} [orgApacheFelixHttpsKeystorePassword@TypeHint] 
         * @param {string} [orgApacheFelixHttpsKeystoreKey] 
         * @param {string} [orgApacheFelixHttpsKeystoreKey@TypeHint] 
         * @param {string} [orgApacheFelixHttpsKeystoreKeyPassword] 
         * @param {string} [orgApacheFelixHttpsKeystoreKeyPassword@TypeHint] 
         * @param {string} [orgApacheFelixHttpsTruststore] 
         * @param {string} [orgApacheFelixHttpsTruststore@TypeHint] 
         * @param {string} [orgApacheFelixHttpsTruststorePassword] 
         * @param {string} [orgApacheFelixHttpsTruststorePassword@TypeHint] 
         * @param {string} [orgApacheFelixHttpsClientcertificate] 
         * @param {string} [orgApacheFelixHttpsClientcertificate@TypeHint] 
         * @param {boolean} [orgApacheFelixHttpsEnable] 
         * @param {string} [orgApacheFelixHttpsEnable@TypeHint] 
         * @param {string} [orgOsgiServiceHttpPortSecure] 
         * @param {string} [orgOsgiServiceHttpPortSecure@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, options: any = {}): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.felix.http`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (orgApacheFelixHttpsNio !== undefined) {
                localVarQueryParameter['org.apache.felix.https.nio'] = orgApacheFelixHttpsNio;
            }

            if (orgApacheFelixHttpsNio@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.nio@TypeHint'] = orgApacheFelixHttpsNio@TypeHint;
            }

            if (orgApacheFelixHttpsKeystore !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore'] = orgApacheFelixHttpsKeystore;
            }

            if (orgApacheFelixHttpsKeystore@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore@TypeHint'] = orgApacheFelixHttpsKeystore@TypeHint;
            }

            if (orgApacheFelixHttpsKeystorePassword !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.password'] = orgApacheFelixHttpsKeystorePassword;
            }

            if (orgApacheFelixHttpsKeystorePassword@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.password@TypeHint'] = orgApacheFelixHttpsKeystorePassword@TypeHint;
            }

            if (orgApacheFelixHttpsKeystoreKey !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.key'] = orgApacheFelixHttpsKeystoreKey;
            }

            if (orgApacheFelixHttpsKeystoreKey@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.key@TypeHint'] = orgApacheFelixHttpsKeystoreKey@TypeHint;
            }

            if (orgApacheFelixHttpsKeystoreKeyPassword !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.key.password'] = orgApacheFelixHttpsKeystoreKeyPassword;
            }

            if (orgApacheFelixHttpsKeystoreKeyPassword@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.key.password@TypeHint'] = orgApacheFelixHttpsKeystoreKeyPassword@TypeHint;
            }

            if (orgApacheFelixHttpsTruststore !== undefined) {
                localVarQueryParameter['org.apache.felix.https.truststore'] = orgApacheFelixHttpsTruststore;
            }

            if (orgApacheFelixHttpsTruststore@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.truststore@TypeHint'] = orgApacheFelixHttpsTruststore@TypeHint;
            }

            if (orgApacheFelixHttpsTruststorePassword !== undefined) {
                localVarQueryParameter['org.apache.felix.https.truststore.password'] = orgApacheFelixHttpsTruststorePassword;
            }

            if (orgApacheFelixHttpsTruststorePassword@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.truststore.password@TypeHint'] = orgApacheFelixHttpsTruststorePassword@TypeHint;
            }

            if (orgApacheFelixHttpsClientcertificate !== undefined) {
                localVarQueryParameter['org.apache.felix.https.clientcertificate'] = orgApacheFelixHttpsClientcertificate;
            }

            if (orgApacheFelixHttpsClientcertificate@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.clientcertificate@TypeHint'] = orgApacheFelixHttpsClientcertificate@TypeHint;
            }

            if (orgApacheFelixHttpsEnable !== undefined) {
                localVarQueryParameter['org.apache.felix.https.enable'] = orgApacheFelixHttpsEnable;
            }

            if (orgApacheFelixHttpsEnable@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.enable@TypeHint'] = orgApacheFelixHttpsEnable@TypeHint;
            }

            if (orgOsgiServiceHttpPortSecure !== undefined) {
                localVarQueryParameter['org.osgi.service.http.port.secure'] = orgOsgiServiceHttpPortSecure;
            }

            if (orgOsgiServiceHttpPortSecure@TypeHint !== undefined) {
                localVarQueryParameter['org.osgi.service.http.port.secure@TypeHint'] = orgOsgiServiceHttpPortSecure@TypeHint;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [proxyHost] 
         * @param {string} [proxyHost@TypeHint] 
         * @param {number} [proxyPort] 
         * @param {string} [proxyPort@TypeHint] 
         * @param {Array<string>} [proxyExceptions] 
         * @param {string} [proxyExceptions@TypeHint] 
         * @param {boolean} [proxyEnabled] 
         * @param {string} [proxyEnabled@TypeHint] 
         * @param {string} [proxyUser] 
         * @param {string} [proxyUser@TypeHint] 
         * @param {string} [proxyPassword] 
         * @param {string} [proxyPassword@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, options: any = {}): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.http.proxyconfigurator.config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (proxyHost !== undefined) {
                localVarQueryParameter['proxy.host'] = proxyHost;
            }

            if (proxyHost@TypeHint !== undefined) {
                localVarQueryParameter['proxy.host@TypeHint'] = proxyHost@TypeHint;
            }

            if (proxyPort !== undefined) {
                localVarQueryParameter['proxy.port'] = proxyPort;
            }

            if (proxyPort@TypeHint !== undefined) {
                localVarQueryParameter['proxy.port@TypeHint'] = proxyPort@TypeHint;
            }

            if (proxyExceptions) {
                localVarQueryParameter['proxy.exceptions'] = proxyExceptions;
            }

            if (proxyExceptions@TypeHint !== undefined) {
                localVarQueryParameter['proxy.exceptions@TypeHint'] = proxyExceptions@TypeHint;
            }

            if (proxyEnabled !== undefined) {
                localVarQueryParameter['proxy.enabled'] = proxyEnabled;
            }

            if (proxyEnabled@TypeHint !== undefined) {
                localVarQueryParameter['proxy.enabled@TypeHint'] = proxyEnabled@TypeHint;
            }

            if (proxyUser !== undefined) {
                localVarQueryParameter['proxy.user'] = proxyUser;
            }

            if (proxyUser@TypeHint !== undefined) {
                localVarQueryParameter['proxy.user@TypeHint'] = proxyUser@TypeHint;
            }

            if (proxyPassword !== undefined) {
                localVarQueryParameter['proxy.password'] = proxyPassword;
            }

            if (proxyPassword@TypeHint !== undefined) {
                localVarQueryParameter['proxy.password@TypeHint'] = proxyPassword@TypeHint;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [alias] 
         * @param {string} [alias@TypeHint] 
         * @param {boolean} [davCreateAbsoluteUri] 
         * @param {string} [davCreateAbsoluteUri@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, options: any = {}): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (alias !== undefined) {
                localVarQueryParameter['alias'] = alias;
            }

            if (alias@TypeHint !== undefined) {
                localVarQueryParameter['alias@TypeHint'] = alias@TypeHint;
            }

            if (davCreateAbsoluteUri !== undefined) {
                localVarQueryParameter['dav.create-absolute-uri'] = davCreateAbsoluteUri;
            }

            if (davCreateAbsoluteUri@TypeHint !== undefined) {
                localVarQueryParameter['dav.create-absolute-uri@TypeHint'] = davCreateAbsoluteUri@TypeHint;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [jsonMaximumresults] 
         * @param {string} [jsonMaximumresults@TypeHint] 
         * @param {boolean} [enableHtml] 
         * @param {string} [enableHtml@TypeHint] 
         * @param {boolean} [enableTxt] 
         * @param {string} [enableTxt@TypeHint] 
         * @param {boolean} [enableXml] 
         * @param {string} [enableXml@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, options: any = {}): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jsonMaximumresults !== undefined) {
                localVarQueryParameter['json.maximumresults'] = jsonMaximumresults;
            }

            if (jsonMaximumresults@TypeHint !== undefined) {
                localVarQueryParameter['json.maximumresults@TypeHint'] = jsonMaximumresults@TypeHint;
            }

            if (enableHtml !== undefined) {
                localVarQueryParameter['enable.html'] = enableHtml;
            }

            if (enableHtml@TypeHint !== undefined) {
                localVarQueryParameter['enable.html@TypeHint'] = enableHtml@TypeHint;
            }

            if (enableTxt !== undefined) {
                localVarQueryParameter['enable.txt'] = enableTxt;
            }

            if (enableTxt@TypeHint !== undefined) {
                localVarQueryParameter['enable.txt@TypeHint'] = enableTxt@TypeHint;
            }

            if (enableXml !== undefined) {
                localVarQueryParameter['enable.xml'] = enableXml;
            }

            if (enableXml@TypeHint !== undefined) {
                localVarQueryParameter['enable.xml@TypeHint'] = enableXml@TypeHint;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [allowEmpty] 
         * @param {string} [allowEmpty@TypeHint] 
         * @param {string} [allowHosts] 
         * @param {string} [allowHosts@TypeHint] 
         * @param {string} [allowHostsRegexp] 
         * @param {string} [allowHostsRegexp@TypeHint] 
         * @param {string} [filterMethods] 
         * @param {string} [filterMethods@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, options: any = {}): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.sling.security.impl.ReferrerFilter`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (allowEmpty !== undefined) {
                localVarQueryParameter['allow.empty'] = allowEmpty;
            }

            if (allowEmpty@TypeHint !== undefined) {
                localVarQueryParameter['allow.empty@TypeHint'] = allowEmpty@TypeHint;
            }

            if (allowHosts !== undefined) {
                localVarQueryParameter['allow.hosts'] = allowHosts;
            }

            if (allowHosts@TypeHint !== undefined) {
                localVarQueryParameter['allow.hosts@TypeHint'] = allowHosts@TypeHint;
            }

            if (allowHostsRegexp !== undefined) {
                localVarQueryParameter['allow.hosts.regexp'] = allowHostsRegexp;
            }

            if (allowHostsRegexp@TypeHint !== undefined) {
                localVarQueryParameter['allow.hosts.regexp@TypeHint'] = allowHostsRegexp@TypeHint;
            }

            if (filterMethods !== undefined) {
                localVarQueryParameter['filter.methods'] = filterMethods;
            }

            if (filterMethods@TypeHint !== undefined) {
                localVarQueryParameter['filter.methods@TypeHint'] = filterMethods@TypeHint;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {string} name 
         * @param {string} [:operation] 
         * @param {string} [deleteAuthorizable] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: any, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postNode.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postNode.');
            }
            const localVarPath = `/{path}/{name}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (:operation !== undefined) {
                localVarQueryParameter[':operation'] = :operation;
            }

            if (deleteAuthorizable !== undefined) {
                localVarQueryParameter['deleteAuthorizable'] = deleteAuthorizable;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {string} name 
         * @param {string} [addMembers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNodeRw(path: string, name: string, addMembers?: string, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postNodeRw.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postNodeRw.');
            }
            const localVarPath = `/{path}/{name}.rw.html`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (addMembers !== undefined) {
                localVarQueryParameter['addMembers'] = addMembers;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {string} jcr:primaryType 
         * @param {string} :name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPath(path: string, jcr:primaryType: string, :name: string, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postPath.');
            }
            // verify required parameter 'jcr:primaryType' is not null or undefined
            if (jcr:primaryType === null || jcr:primaryType === undefined) {
                throw new RequiredError('jcr:primaryType','Required parameter jcr:primaryType was null or undefined when calling postPath.');
            }
            // verify required parameter ':name' is not null or undefined
            if (:name === null || :name === undefined) {
                throw new RequiredError(':name','Required parameter :name was null or undefined when calling postPath.');
            }
            const localVarPath = `/{path}/`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jcr:primaryType !== undefined) {
                localVarQueryParameter['jcr:primaryType'] = jcr:primaryType;
            }

            if (:name !== undefined) {
                localVarQueryParameter[':name'] = :name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {number} pLimit 
         * @param {string} _1property 
         * @param {string} _1propertyValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postQuery.');
            }
            // verify required parameter 'pLimit' is not null or undefined
            if (pLimit === null || pLimit === undefined) {
                throw new RequiredError('pLimit','Required parameter pLimit was null or undefined when calling postQuery.');
            }
            // verify required parameter '_1property' is not null or undefined
            if (_1property === null || _1property === undefined) {
                throw new RequiredError('_1property','Required parameter _1property was null or undefined when calling postQuery.');
            }
            // verify required parameter '_1propertyValue' is not null or undefined
            if (_1propertyValue === null || _1propertyValue === undefined) {
                throw new RequiredError('_1propertyValue','Required parameter _1propertyValue was null or undefined when calling postQuery.');
            }
            const localVarPath = `/bin/querybuilder.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (pLimit !== undefined) {
                localVarQueryParameter['p.limit'] = pLimit;
            }

            if (_1property !== undefined) {
                localVarQueryParameter['1_property'] = _1property;
            }

            if (_1propertyValue !== undefined) {
                localVarQueryParameter['1_property.value'] = _1propertyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} ignoredeactivated 
         * @param {boolean} onlymodified 
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, options: any = {}): FetchArgs {
            // verify required parameter 'ignoredeactivated' is not null or undefined
            if (ignoredeactivated === null || ignoredeactivated === undefined) {
                throw new RequiredError('ignoredeactivated','Required parameter ignoredeactivated was null or undefined when calling postTreeActivation.');
            }
            // verify required parameter 'onlymodified' is not null or undefined
            if (onlymodified === null || onlymodified === undefined) {
                throw new RequiredError('onlymodified','Required parameter onlymodified was null or undefined when calling postTreeActivation.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postTreeActivation.');
            }
            const localVarPath = `/etc/replication/treeactivation.html`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (ignoredeactivated !== undefined) {
                localVarQueryParameter['ignoredeactivated'] = ignoredeactivated;
            }

            if (onlymodified !== undefined) {
                localVarQueryParameter['onlymodified'] = onlymodified;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [:operation] 
         * @param {string} [newPassword] 
         * @param {string} [rePassword] 
         * @param {string} [keyStoreType] 
         * @param {string} [removeAlias] 
         * @param {any} [certificate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: any, options: any = {}): FetchArgs {
            const localVarPath = `/libs/granite/security/post/truststore`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (:operation !== undefined) {
                localVarQueryParameter[':operation'] = :operation;
            }

            if (newPassword !== undefined) {
                localVarQueryParameter['newPassword'] = newPassword;
            }

            if (rePassword !== undefined) {
                localVarQueryParameter['rePassword'] = rePassword;
            }

            if (keyStoreType !== undefined) {
                localVarQueryParameter['keyStoreType'] = keyStoreType;
            }

            if (removeAlias !== undefined) {
                localVarQueryParameter['removeAlias'] = removeAlias;
            }

            if (certificate !== undefined) {
                localVarFormParams.set('certificate', certificate as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} [truststoreP12] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTruststorePKCS12(truststoreP12?: any, options: any = {}): FetchArgs {
            const localVarPath = `/etc/truststore`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (truststoreP12 !== undefined) {
                localVarFormParams.set('truststore.p12', truststoreP12 as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SlingApi - functional programming interface
 * @export
 */
export const SlingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} runmode 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent(runmode: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).deleteAgent(runmode, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNode(path: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).deleteNode(path, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} runmode 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgent(runmode: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getAgent(runmode, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} runmode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgents(runmode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getAgents(runmode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} intermediatePath 
         * @param {string} authorizableId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizableKeystore(intermediatePath: string, authorizableId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeystoreInfo> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getAuthorizableKeystore(intermediatePath, authorizableId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} intermediatePath 
         * @param {string} authorizableId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeystore(intermediatePath: string, authorizableId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getKeystore(intermediatePath, authorizableId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode(path: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getNode(path, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} group 
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackage(group: string, name: string, version: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getPackage(group, name, version, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} group 
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageFilter(group: string, name: string, version: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getPackageFilter(group, name, version, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {number} pLimit 
         * @param {string} _1property 
         * @param {string} _1propertyValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getQuery(path, pLimit, _1property, _1propertyValue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTruststore(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getTruststore(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTruststoreInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TruststoreInfo> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getTruststoreInfo(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} runmode 
         * @param {string} name 
         * @param {boolean} [jcr:contentCq:distribute] 
         * @param {string} [jcr:contentCq:distribute@TypeHint] 
         * @param {string} [jcr:contentCq:name] 
         * @param {string} [jcr:contentCq:template] 
         * @param {boolean} [jcr:contentEnabled] 
         * @param {string} [jcr:contentJcr:description] 
         * @param {string} [jcr:contentJcr:lastModified] 
         * @param {string} [jcr:contentJcr:lastModifiedBy] 
         * @param {string} [jcr:contentJcr:mixinTypes] 
         * @param {string} [jcr:contentJcr:title] 
         * @param {string} [jcr:contentLogLevel] 
         * @param {boolean} [jcr:contentNoStatusUpdate] 
         * @param {boolean} [jcr:contentNoVersioning] 
         * @param {number} [jcr:contentProtocolConnectTimeout] 
         * @param {boolean} [jcr:contentProtocolHTTPConnectionClosed] 
         * @param {string} [jcr:contentProtocolHTTPExpired] 
         * @param {Array<string>} [jcr:contentProtocolHTTPHeaders] 
         * @param {string} [jcr:contentProtocolHTTPHeaders@TypeHint] 
         * @param {string} [jcr:contentProtocolHTTPMethod] 
         * @param {boolean} [jcr:contentProtocolHTTPSRelaxed] 
         * @param {string} [jcr:contentProtocolInterface] 
         * @param {number} [jcr:contentProtocolSocketTimeout] 
         * @param {string} [jcr:contentProtocolVersion] 
         * @param {string} [jcr:contentProxyNTLMDomain] 
         * @param {string} [jcr:contentProxyNTLMHost] 
         * @param {string} [jcr:contentProxyHost] 
         * @param {string} [jcr:contentProxyPassword] 
         * @param {number} [jcr:contentProxyPort] 
         * @param {string} [jcr:contentProxyUser] 
         * @param {number} [jcr:contentQueueBatchMaxSize] 
         * @param {string} [jcr:contentQueueBatchMode] 
         * @param {number} [jcr:contentQueueBatchWaitTime] 
         * @param {string} [jcr:contentRetryDelay] 
         * @param {boolean} [jcr:contentReverseReplication] 
         * @param {string} [jcr:contentSerializationType] 
         * @param {string} [jcr:contentSling:resourceType] 
         * @param {string} [jcr:contentSsl] 
         * @param {string} [jcr:contentTransportNTLMDomain] 
         * @param {string} [jcr:contentTransportNTLMHost] 
         * @param {string} [jcr:contentTransportPassword] 
         * @param {string} [jcr:contentTransportUri] 
         * @param {string} [jcr:contentTransportUser] 
         * @param {boolean} [jcr:contentTriggerDistribute] 
         * @param {boolean} [jcr:contentTriggerModified] 
         * @param {boolean} [jcr:contentTriggerOnOffTime] 
         * @param {boolean} [jcr:contentTriggerReceive] 
         * @param {boolean} [jcr:contentTriggerSpecific] 
         * @param {string} [jcr:contentUserId] 
         * @param {string} [jcr:primaryType] 
         * @param {string} [:operation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postAgent(runmode, name, jcr:contentCq:distribute, jcr:contentCq:distribute@TypeHint, jcr:contentCq:name, jcr:contentCq:template, jcr:contentEnabled, jcr:contentJcr:description, jcr:contentJcr:lastModified, jcr:contentJcr:lastModifiedBy, jcr:contentJcr:mixinTypes, jcr:contentJcr:title, jcr:contentLogLevel, jcr:contentNoStatusUpdate, jcr:contentNoVersioning, jcr:contentProtocolConnectTimeout, jcr:contentProtocolHTTPConnectionClosed, jcr:contentProtocolHTTPExpired, jcr:contentProtocolHTTPHeaders, jcr:contentProtocolHTTPHeaders@TypeHint, jcr:contentProtocolHTTPMethod, jcr:contentProtocolHTTPSRelaxed, jcr:contentProtocolInterface, jcr:contentProtocolSocketTimeout, jcr:contentProtocolVersion, jcr:contentProxyNTLMDomain, jcr:contentProxyNTLMHost, jcr:contentProxyHost, jcr:contentProxyPassword, jcr:contentProxyPort, jcr:contentProxyUser, jcr:contentQueueBatchMaxSize, jcr:contentQueueBatchMode, jcr:contentQueueBatchWaitTime, jcr:contentRetryDelay, jcr:contentReverseReplication, jcr:contentSerializationType, jcr:contentSling:resourceType, jcr:contentSsl, jcr:contentTransportNTLMDomain, jcr:contentTransportNTLMHost, jcr:contentTransportPassword, jcr:contentTransportUri, jcr:contentTransportUser, jcr:contentTriggerDistribute, jcr:contentTriggerModified, jcr:contentTriggerOnOffTime, jcr:contentTriggerReceive, jcr:contentTriggerSpecific, jcr:contentUserId, jcr:primaryType, :operation, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} intermediatePath 
         * @param {string} authorizableId 
         * @param {string} [:operation] 
         * @param {string} [currentPassword] 
         * @param {string} [newPassword] 
         * @param {string} [rePassword] 
         * @param {string} [keyPassword] 
         * @param {string} [keyStorePass] 
         * @param {string} [alias] 
         * @param {string} [newAlias] 
         * @param {string} [removeAlias] 
         * @param {any} [certChain] 
         * @param {any} [pk] 
         * @param {any} [keyStore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: any, pk?: any, keyStore?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeystoreInfo> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postAuthorizableKeystore(intermediatePath, authorizableId, :operation, currentPassword, newPassword, rePassword, keyPassword, keyStorePass, alias, newAlias, removeAlias, certChain, pk, keyStore, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} authorizableId 
         * @param {string} intermediatePath 
         * @param {string} [createUser] 
         * @param {string} [createGroup] 
         * @param {string} [rep:password] 
         * @param {string} [profileGivenName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postAuthorizables(authorizableId, intermediatePath, createUser, createGroup, rep:password, profileGivenName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [keyStorePassword] 
         * @param {string} [keyStorePassword@TypeHint] 
         * @param {number} [serviceRanking] 
         * @param {string} [serviceRanking@TypeHint] 
         * @param {boolean} [idpHttpRedirect] 
         * @param {string} [idpHttpRedirect@TypeHint] 
         * @param {boolean} [createUser] 
         * @param {string} [createUser@TypeHint] 
         * @param {string} [defaultRedirectUrl] 
         * @param {string} [defaultRedirectUrl@TypeHint] 
         * @param {string} [userIDAttribute] 
         * @param {string} [userIDAttribute@TypeHint] 
         * @param {Array<string>} [defaultGroups] 
         * @param {string} [defaultGroups@TypeHint] 
         * @param {string} [idpCertAlias] 
         * @param {string} [idpCertAlias@TypeHint] 
         * @param {boolean} [addGroupMemberships] 
         * @param {string} [addGroupMemberships@TypeHint] 
         * @param {Array<string>} [path] 
         * @param {string} [path@TypeHint] 
         * @param {Array<string>} [synchronizeAttributes] 
         * @param {string} [synchronizeAttributes@TypeHint] 
         * @param {number} [clockTolerance] 
         * @param {string} [clockTolerance@TypeHint] 
         * @param {string} [groupMembershipAttribute] 
         * @param {string} [groupMembershipAttribute@TypeHint] 
         * @param {string} [idpUrl] 
         * @param {string} [idpUrl@TypeHint] 
         * @param {string} [logoutUrl] 
         * @param {string} [logoutUrl@TypeHint] 
         * @param {string} [serviceProviderEntityId] 
         * @param {string} [serviceProviderEntityId@TypeHint] 
         * @param {string} [assertionConsumerServiceURL] 
         * @param {string} [assertionConsumerServiceURL@TypeHint] 
         * @param {boolean} [handleLogout] 
         * @param {string} [handleLogout@TypeHint] 
         * @param {string} [spPrivateKeyAlias] 
         * @param {string} [spPrivateKeyAlias@TypeHint] 
         * @param {boolean} [useEncryption] 
         * @param {string} [useEncryption@TypeHint] 
         * @param {string} [nameIdFormat] 
         * @param {string} [nameIdFormat@TypeHint] 
         * @param {string} [digestMethod] 
         * @param {string} [digestMethod@TypeHint] 
         * @param {string} [signatureMethod] 
         * @param {string} [signatureMethod@TypeHint] 
         * @param {string} [userIntermediatePath] 
         * @param {string} [userIntermediatePath@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword, keyStorePassword@TypeHint, serviceRanking, serviceRanking@TypeHint, idpHttpRedirect, idpHttpRedirect@TypeHint, createUser, createUser@TypeHint, defaultRedirectUrl, defaultRedirectUrl@TypeHint, userIDAttribute, userIDAttribute@TypeHint, defaultGroups, defaultGroups@TypeHint, idpCertAlias, idpCertAlias@TypeHint, addGroupMemberships, addGroupMemberships@TypeHint, path, path@TypeHint, synchronizeAttributes, synchronizeAttributes@TypeHint, clockTolerance, clockTolerance@TypeHint, groupMembershipAttribute, groupMembershipAttribute@TypeHint, idpUrl, idpUrl@TypeHint, logoutUrl, logoutUrl@TypeHint, serviceProviderEntityId, serviceProviderEntityId@TypeHint, assertionConsumerServiceURL, assertionConsumerServiceURL@TypeHint, handleLogout, handleLogout@TypeHint, spPrivateKeyAlias, spPrivateKeyAlias@TypeHint, useEncryption, useEncryption@TypeHint, nameIdFormat, nameIdFormat@TypeHint, digestMethod, digestMethod@TypeHint, signatureMethod, signatureMethod@TypeHint, userIntermediatePath, userIntermediatePath@TypeHint, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {boolean} [orgApacheFelixHttpsNio] 
         * @param {string} [orgApacheFelixHttpsNio@TypeHint] 
         * @param {string} [orgApacheFelixHttpsKeystore] 
         * @param {string} [orgApacheFelixHttpsKeystore@TypeHint] 
         * @param {string} [orgApacheFelixHttpsKeystorePassword] 
         * @param {string} [orgApacheFelixHttpsKeystorePassword@TypeHint] 
         * @param {string} [orgApacheFelixHttpsKeystoreKey] 
         * @param {string} [orgApacheFelixHttpsKeystoreKey@TypeHint] 
         * @param {string} [orgApacheFelixHttpsKeystoreKeyPassword] 
         * @param {string} [orgApacheFelixHttpsKeystoreKeyPassword@TypeHint] 
         * @param {string} [orgApacheFelixHttpsTruststore] 
         * @param {string} [orgApacheFelixHttpsTruststore@TypeHint] 
         * @param {string} [orgApacheFelixHttpsTruststorePassword] 
         * @param {string} [orgApacheFelixHttpsTruststorePassword@TypeHint] 
         * @param {string} [orgApacheFelixHttpsClientcertificate] 
         * @param {string} [orgApacheFelixHttpsClientcertificate@TypeHint] 
         * @param {boolean} [orgApacheFelixHttpsEnable] 
         * @param {string} [orgApacheFelixHttpsEnable@TypeHint] 
         * @param {string} [orgOsgiServiceHttpPortSecure] 
         * @param {string} [orgOsgiServiceHttpPortSecure@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio, orgApacheFelixHttpsNio@TypeHint, orgApacheFelixHttpsKeystore, orgApacheFelixHttpsKeystore@TypeHint, orgApacheFelixHttpsKeystorePassword, orgApacheFelixHttpsKeystorePassword@TypeHint, orgApacheFelixHttpsKeystoreKey, orgApacheFelixHttpsKeystoreKey@TypeHint, orgApacheFelixHttpsKeystoreKeyPassword, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint, orgApacheFelixHttpsTruststore, orgApacheFelixHttpsTruststore@TypeHint, orgApacheFelixHttpsTruststorePassword, orgApacheFelixHttpsTruststorePassword@TypeHint, orgApacheFelixHttpsClientcertificate, orgApacheFelixHttpsClientcertificate@TypeHint, orgApacheFelixHttpsEnable, orgApacheFelixHttpsEnable@TypeHint, orgOsgiServiceHttpPortSecure, orgOsgiServiceHttpPortSecure@TypeHint, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [proxyHost] 
         * @param {string} [proxyHost@TypeHint] 
         * @param {number} [proxyPort] 
         * @param {string} [proxyPort@TypeHint] 
         * @param {Array<string>} [proxyExceptions] 
         * @param {string} [proxyExceptions@TypeHint] 
         * @param {boolean} [proxyEnabled] 
         * @param {string} [proxyEnabled@TypeHint] 
         * @param {string} [proxyUser] 
         * @param {string} [proxyUser@TypeHint] 
         * @param {string} [proxyPassword] 
         * @param {string} [proxyPassword@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheHttpComponentsProxyConfiguration(proxyHost, proxyHost@TypeHint, proxyPort, proxyPort@TypeHint, proxyExceptions, proxyExceptions@TypeHint, proxyEnabled, proxyEnabled@TypeHint, proxyUser, proxyUser@TypeHint, proxyPassword, proxyPassword@TypeHint, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [alias] 
         * @param {string} [alias@TypeHint] 
         * @param {boolean} [davCreateAbsoluteUri] 
         * @param {string} [davCreateAbsoluteUri@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheSlingDavExServlet(alias, alias@TypeHint, davCreateAbsoluteUri, davCreateAbsoluteUri@TypeHint, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [jsonMaximumresults] 
         * @param {string} [jsonMaximumresults@TypeHint] 
         * @param {boolean} [enableHtml] 
         * @param {string} [enableHtml@TypeHint] 
         * @param {boolean} [enableTxt] 
         * @param {string} [enableTxt@TypeHint] 
         * @param {boolean} [enableXml] 
         * @param {string} [enableXml@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheSlingGetServlet(jsonMaximumresults, jsonMaximumresults@TypeHint, enableHtml, enableHtml@TypeHint, enableTxt, enableTxt@TypeHint, enableXml, enableXml@TypeHint, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {boolean} [allowEmpty] 
         * @param {string} [allowEmpty@TypeHint] 
         * @param {string} [allowHosts] 
         * @param {string} [allowHosts@TypeHint] 
         * @param {string} [allowHostsRegexp] 
         * @param {string} [allowHostsRegexp@TypeHint] 
         * @param {string} [filterMethods] 
         * @param {string} [filterMethods@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheSlingReferrerFilter(allowEmpty, allowEmpty@TypeHint, allowHosts, allowHosts@TypeHint, allowHostsRegexp, allowHostsRegexp@TypeHint, filterMethods, filterMethods@TypeHint, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {string} name 
         * @param {string} [:operation] 
         * @param {string} [deleteAuthorizable] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postNode(path, name, :operation, deleteAuthorizable, file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {string} name 
         * @param {string} [addMembers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNodeRw(path: string, name: string, addMembers?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postNodeRw(path, name, addMembers, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {string} jcr:primaryType 
         * @param {string} :name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPath(path: string, jcr:primaryType: string, :name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postPath(path, jcr:primaryType, :name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {number} pLimit 
         * @param {string} _1property 
         * @param {string} _1propertyValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postQuery(path, pLimit, _1property, _1propertyValue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {boolean} ignoredeactivated 
         * @param {boolean} onlymodified 
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postTreeActivation(ignoredeactivated, onlymodified, path, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [:operation] 
         * @param {string} [newPassword] 
         * @param {string} [rePassword] 
         * @param {string} [keyStoreType] 
         * @param {string} [removeAlias] 
         * @param {any} [certificate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postTruststore(:operation, newPassword, rePassword, keyStoreType, removeAlias, certificate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {any} [truststoreP12] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTruststorePKCS12(truststoreP12?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postTruststorePKCS12(truststoreP12, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SlingApi - factory interface
 * @export
 */
export const SlingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} runmode 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent(runmode: string, name: string, options?: any) {
            return SlingApiFp(configuration).deleteAgent(runmode, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} path 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNode(path: string, name: string, options?: any) {
            return SlingApiFp(configuration).deleteNode(path, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} runmode 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgent(runmode: string, name: string, options?: any) {
            return SlingApiFp(configuration).getAgent(runmode, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} runmode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgents(runmode: string, options?: any) {
            return SlingApiFp(configuration).getAgents(runmode, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} intermediatePath 
         * @param {string} authorizableId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizableKeystore(intermediatePath: string, authorizableId: string, options?: any) {
            return SlingApiFp(configuration).getAuthorizableKeystore(intermediatePath, authorizableId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} intermediatePath 
         * @param {string} authorizableId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeystore(intermediatePath: string, authorizableId: string, options?: any) {
            return SlingApiFp(configuration).getKeystore(intermediatePath, authorizableId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} path 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode(path: string, name: string, options?: any) {
            return SlingApiFp(configuration).getNode(path, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} group 
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackage(group: string, name: string, version: string, options?: any) {
            return SlingApiFp(configuration).getPackage(group, name, version, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} group 
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageFilter(group: string, name: string, version: string, options?: any) {
            return SlingApiFp(configuration).getPackageFilter(group, name, version, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} path 
         * @param {number} pLimit 
         * @param {string} _1property 
         * @param {string} _1propertyValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options?: any) {
            return SlingApiFp(configuration).getQuery(path, pLimit, _1property, _1propertyValue, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTruststore(options?: any) {
            return SlingApiFp(configuration).getTruststore(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTruststoreInfo(options?: any) {
            return SlingApiFp(configuration).getTruststoreInfo(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} runmode 
         * @param {string} name 
         * @param {boolean} [jcr:contentCq:distribute] 
         * @param {string} [jcr:contentCq:distribute@TypeHint] 
         * @param {string} [jcr:contentCq:name] 
         * @param {string} [jcr:contentCq:template] 
         * @param {boolean} [jcr:contentEnabled] 
         * @param {string} [jcr:contentJcr:description] 
         * @param {string} [jcr:contentJcr:lastModified] 
         * @param {string} [jcr:contentJcr:lastModifiedBy] 
         * @param {string} [jcr:contentJcr:mixinTypes] 
         * @param {string} [jcr:contentJcr:title] 
         * @param {string} [jcr:contentLogLevel] 
         * @param {boolean} [jcr:contentNoStatusUpdate] 
         * @param {boolean} [jcr:contentNoVersioning] 
         * @param {number} [jcr:contentProtocolConnectTimeout] 
         * @param {boolean} [jcr:contentProtocolHTTPConnectionClosed] 
         * @param {string} [jcr:contentProtocolHTTPExpired] 
         * @param {Array<string>} [jcr:contentProtocolHTTPHeaders] 
         * @param {string} [jcr:contentProtocolHTTPHeaders@TypeHint] 
         * @param {string} [jcr:contentProtocolHTTPMethod] 
         * @param {boolean} [jcr:contentProtocolHTTPSRelaxed] 
         * @param {string} [jcr:contentProtocolInterface] 
         * @param {number} [jcr:contentProtocolSocketTimeout] 
         * @param {string} [jcr:contentProtocolVersion] 
         * @param {string} [jcr:contentProxyNTLMDomain] 
         * @param {string} [jcr:contentProxyNTLMHost] 
         * @param {string} [jcr:contentProxyHost] 
         * @param {string} [jcr:contentProxyPassword] 
         * @param {number} [jcr:contentProxyPort] 
         * @param {string} [jcr:contentProxyUser] 
         * @param {number} [jcr:contentQueueBatchMaxSize] 
         * @param {string} [jcr:contentQueueBatchMode] 
         * @param {number} [jcr:contentQueueBatchWaitTime] 
         * @param {string} [jcr:contentRetryDelay] 
         * @param {boolean} [jcr:contentReverseReplication] 
         * @param {string} [jcr:contentSerializationType] 
         * @param {string} [jcr:contentSling:resourceType] 
         * @param {string} [jcr:contentSsl] 
         * @param {string} [jcr:contentTransportNTLMDomain] 
         * @param {string} [jcr:contentTransportNTLMHost] 
         * @param {string} [jcr:contentTransportPassword] 
         * @param {string} [jcr:contentTransportUri] 
         * @param {string} [jcr:contentTransportUser] 
         * @param {boolean} [jcr:contentTriggerDistribute] 
         * @param {boolean} [jcr:contentTriggerModified] 
         * @param {boolean} [jcr:contentTriggerOnOffTime] 
         * @param {boolean} [jcr:contentTriggerReceive] 
         * @param {boolean} [jcr:contentTriggerSpecific] 
         * @param {string} [jcr:contentUserId] 
         * @param {string} [jcr:primaryType] 
         * @param {string} [:operation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, options?: any) {
            return SlingApiFp(configuration).postAgent(runmode, name, jcr:contentCq:distribute, jcr:contentCq:distribute@TypeHint, jcr:contentCq:name, jcr:contentCq:template, jcr:contentEnabled, jcr:contentJcr:description, jcr:contentJcr:lastModified, jcr:contentJcr:lastModifiedBy, jcr:contentJcr:mixinTypes, jcr:contentJcr:title, jcr:contentLogLevel, jcr:contentNoStatusUpdate, jcr:contentNoVersioning, jcr:contentProtocolConnectTimeout, jcr:contentProtocolHTTPConnectionClosed, jcr:contentProtocolHTTPExpired, jcr:contentProtocolHTTPHeaders, jcr:contentProtocolHTTPHeaders@TypeHint, jcr:contentProtocolHTTPMethod, jcr:contentProtocolHTTPSRelaxed, jcr:contentProtocolInterface, jcr:contentProtocolSocketTimeout, jcr:contentProtocolVersion, jcr:contentProxyNTLMDomain, jcr:contentProxyNTLMHost, jcr:contentProxyHost, jcr:contentProxyPassword, jcr:contentProxyPort, jcr:contentProxyUser, jcr:contentQueueBatchMaxSize, jcr:contentQueueBatchMode, jcr:contentQueueBatchWaitTime, jcr:contentRetryDelay, jcr:contentReverseReplication, jcr:contentSerializationType, jcr:contentSling:resourceType, jcr:contentSsl, jcr:contentTransportNTLMDomain, jcr:contentTransportNTLMHost, jcr:contentTransportPassword, jcr:contentTransportUri, jcr:contentTransportUser, jcr:contentTriggerDistribute, jcr:contentTriggerModified, jcr:contentTriggerOnOffTime, jcr:contentTriggerReceive, jcr:contentTriggerSpecific, jcr:contentUserId, jcr:primaryType, :operation, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} intermediatePath 
         * @param {string} authorizableId 
         * @param {string} [:operation] 
         * @param {string} [currentPassword] 
         * @param {string} [newPassword] 
         * @param {string} [rePassword] 
         * @param {string} [keyPassword] 
         * @param {string} [keyStorePass] 
         * @param {string} [alias] 
         * @param {string} [newAlias] 
         * @param {string} [removeAlias] 
         * @param {any} [certChain] 
         * @param {any} [pk] 
         * @param {any} [keyStore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: any, pk?: any, keyStore?: any, options?: any) {
            return SlingApiFp(configuration).postAuthorizableKeystore(intermediatePath, authorizableId, :operation, currentPassword, newPassword, rePassword, keyPassword, keyStorePass, alias, newAlias, removeAlias, certChain, pk, keyStore, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} authorizableId 
         * @param {string} intermediatePath 
         * @param {string} [createUser] 
         * @param {string} [createGroup] 
         * @param {string} [rep:password] 
         * @param {string} [profileGivenName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, options?: any) {
            return SlingApiFp(configuration).postAuthorizables(authorizableId, intermediatePath, createUser, createGroup, rep:password, profileGivenName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [keyStorePassword] 
         * @param {string} [keyStorePassword@TypeHint] 
         * @param {number} [serviceRanking] 
         * @param {string} [serviceRanking@TypeHint] 
         * @param {boolean} [idpHttpRedirect] 
         * @param {string} [idpHttpRedirect@TypeHint] 
         * @param {boolean} [createUser] 
         * @param {string} [createUser@TypeHint] 
         * @param {string} [defaultRedirectUrl] 
         * @param {string} [defaultRedirectUrl@TypeHint] 
         * @param {string} [userIDAttribute] 
         * @param {string} [userIDAttribute@TypeHint] 
         * @param {Array<string>} [defaultGroups] 
         * @param {string} [defaultGroups@TypeHint] 
         * @param {string} [idpCertAlias] 
         * @param {string} [idpCertAlias@TypeHint] 
         * @param {boolean} [addGroupMemberships] 
         * @param {string} [addGroupMemberships@TypeHint] 
         * @param {Array<string>} [path] 
         * @param {string} [path@TypeHint] 
         * @param {Array<string>} [synchronizeAttributes] 
         * @param {string} [synchronizeAttributes@TypeHint] 
         * @param {number} [clockTolerance] 
         * @param {string} [clockTolerance@TypeHint] 
         * @param {string} [groupMembershipAttribute] 
         * @param {string} [groupMembershipAttribute@TypeHint] 
         * @param {string} [idpUrl] 
         * @param {string} [idpUrl@TypeHint] 
         * @param {string} [logoutUrl] 
         * @param {string} [logoutUrl@TypeHint] 
         * @param {string} [serviceProviderEntityId] 
         * @param {string} [serviceProviderEntityId@TypeHint] 
         * @param {string} [assertionConsumerServiceURL] 
         * @param {string} [assertionConsumerServiceURL@TypeHint] 
         * @param {boolean} [handleLogout] 
         * @param {string} [handleLogout@TypeHint] 
         * @param {string} [spPrivateKeyAlias] 
         * @param {string} [spPrivateKeyAlias@TypeHint] 
         * @param {boolean} [useEncryption] 
         * @param {string} [useEncryption@TypeHint] 
         * @param {string} [nameIdFormat] 
         * @param {string} [nameIdFormat@TypeHint] 
         * @param {string} [digestMethod] 
         * @param {string} [digestMethod@TypeHint] 
         * @param {string} [signatureMethod] 
         * @param {string} [signatureMethod@TypeHint] 
         * @param {string} [userIntermediatePath] 
         * @param {string} [userIntermediatePath@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, options?: any) {
            return SlingApiFp(configuration).postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword, keyStorePassword@TypeHint, serviceRanking, serviceRanking@TypeHint, idpHttpRedirect, idpHttpRedirect@TypeHint, createUser, createUser@TypeHint, defaultRedirectUrl, defaultRedirectUrl@TypeHint, userIDAttribute, userIDAttribute@TypeHint, defaultGroups, defaultGroups@TypeHint, idpCertAlias, idpCertAlias@TypeHint, addGroupMemberships, addGroupMemberships@TypeHint, path, path@TypeHint, synchronizeAttributes, synchronizeAttributes@TypeHint, clockTolerance, clockTolerance@TypeHint, groupMembershipAttribute, groupMembershipAttribute@TypeHint, idpUrl, idpUrl@TypeHint, logoutUrl, logoutUrl@TypeHint, serviceProviderEntityId, serviceProviderEntityId@TypeHint, assertionConsumerServiceURL, assertionConsumerServiceURL@TypeHint, handleLogout, handleLogout@TypeHint, spPrivateKeyAlias, spPrivateKeyAlias@TypeHint, useEncryption, useEncryption@TypeHint, nameIdFormat, nameIdFormat@TypeHint, digestMethod, digestMethod@TypeHint, signatureMethod, signatureMethod@TypeHint, userIntermediatePath, userIntermediatePath@TypeHint, options)(fetch, basePath);
        },
        /**
         * 
         * @param {boolean} [orgApacheFelixHttpsNio] 
         * @param {string} [orgApacheFelixHttpsNio@TypeHint] 
         * @param {string} [orgApacheFelixHttpsKeystore] 
         * @param {string} [orgApacheFelixHttpsKeystore@TypeHint] 
         * @param {string} [orgApacheFelixHttpsKeystorePassword] 
         * @param {string} [orgApacheFelixHttpsKeystorePassword@TypeHint] 
         * @param {string} [orgApacheFelixHttpsKeystoreKey] 
         * @param {string} [orgApacheFelixHttpsKeystoreKey@TypeHint] 
         * @param {string} [orgApacheFelixHttpsKeystoreKeyPassword] 
         * @param {string} [orgApacheFelixHttpsKeystoreKeyPassword@TypeHint] 
         * @param {string} [orgApacheFelixHttpsTruststore] 
         * @param {string} [orgApacheFelixHttpsTruststore@TypeHint] 
         * @param {string} [orgApacheFelixHttpsTruststorePassword] 
         * @param {string} [orgApacheFelixHttpsTruststorePassword@TypeHint] 
         * @param {string} [orgApacheFelixHttpsClientcertificate] 
         * @param {string} [orgApacheFelixHttpsClientcertificate@TypeHint] 
         * @param {boolean} [orgApacheFelixHttpsEnable] 
         * @param {string} [orgApacheFelixHttpsEnable@TypeHint] 
         * @param {string} [orgOsgiServiceHttpPortSecure] 
         * @param {string} [orgOsgiServiceHttpPortSecure@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, options?: any) {
            return SlingApiFp(configuration).postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio, orgApacheFelixHttpsNio@TypeHint, orgApacheFelixHttpsKeystore, orgApacheFelixHttpsKeystore@TypeHint, orgApacheFelixHttpsKeystorePassword, orgApacheFelixHttpsKeystorePassword@TypeHint, orgApacheFelixHttpsKeystoreKey, orgApacheFelixHttpsKeystoreKey@TypeHint, orgApacheFelixHttpsKeystoreKeyPassword, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint, orgApacheFelixHttpsTruststore, orgApacheFelixHttpsTruststore@TypeHint, orgApacheFelixHttpsTruststorePassword, orgApacheFelixHttpsTruststorePassword@TypeHint, orgApacheFelixHttpsClientcertificate, orgApacheFelixHttpsClientcertificate@TypeHint, orgApacheFelixHttpsEnable, orgApacheFelixHttpsEnable@TypeHint, orgOsgiServiceHttpPortSecure, orgOsgiServiceHttpPortSecure@TypeHint, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [proxyHost] 
         * @param {string} [proxyHost@TypeHint] 
         * @param {number} [proxyPort] 
         * @param {string} [proxyPort@TypeHint] 
         * @param {Array<string>} [proxyExceptions] 
         * @param {string} [proxyExceptions@TypeHint] 
         * @param {boolean} [proxyEnabled] 
         * @param {string} [proxyEnabled@TypeHint] 
         * @param {string} [proxyUser] 
         * @param {string} [proxyUser@TypeHint] 
         * @param {string} [proxyPassword] 
         * @param {string} [proxyPassword@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, options?: any) {
            return SlingApiFp(configuration).postConfigApacheHttpComponentsProxyConfiguration(proxyHost, proxyHost@TypeHint, proxyPort, proxyPort@TypeHint, proxyExceptions, proxyExceptions@TypeHint, proxyEnabled, proxyEnabled@TypeHint, proxyUser, proxyUser@TypeHint, proxyPassword, proxyPassword@TypeHint, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [alias] 
         * @param {string} [alias@TypeHint] 
         * @param {boolean} [davCreateAbsoluteUri] 
         * @param {string} [davCreateAbsoluteUri@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, options?: any) {
            return SlingApiFp(configuration).postConfigApacheSlingDavExServlet(alias, alias@TypeHint, davCreateAbsoluteUri, davCreateAbsoluteUri@TypeHint, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [jsonMaximumresults] 
         * @param {string} [jsonMaximumresults@TypeHint] 
         * @param {boolean} [enableHtml] 
         * @param {string} [enableHtml@TypeHint] 
         * @param {boolean} [enableTxt] 
         * @param {string} [enableTxt@TypeHint] 
         * @param {boolean} [enableXml] 
         * @param {string} [enableXml@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, options?: any) {
            return SlingApiFp(configuration).postConfigApacheSlingGetServlet(jsonMaximumresults, jsonMaximumresults@TypeHint, enableHtml, enableHtml@TypeHint, enableTxt, enableTxt@TypeHint, enableXml, enableXml@TypeHint, options)(fetch, basePath);
        },
        /**
         * 
         * @param {boolean} [allowEmpty] 
         * @param {string} [allowEmpty@TypeHint] 
         * @param {string} [allowHosts] 
         * @param {string} [allowHosts@TypeHint] 
         * @param {string} [allowHostsRegexp] 
         * @param {string} [allowHostsRegexp@TypeHint] 
         * @param {string} [filterMethods] 
         * @param {string} [filterMethods@TypeHint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, options?: any) {
            return SlingApiFp(configuration).postConfigApacheSlingReferrerFilter(allowEmpty, allowEmpty@TypeHint, allowHosts, allowHosts@TypeHint, allowHostsRegexp, allowHostsRegexp@TypeHint, filterMethods, filterMethods@TypeHint, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} path 
         * @param {string} name 
         * @param {string} [:operation] 
         * @param {string} [deleteAuthorizable] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: any, options?: any) {
            return SlingApiFp(configuration).postNode(path, name, :operation, deleteAuthorizable, file, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} path 
         * @param {string} name 
         * @param {string} [addMembers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNodeRw(path: string, name: string, addMembers?: string, options?: any) {
            return SlingApiFp(configuration).postNodeRw(path, name, addMembers, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} path 
         * @param {string} jcr:primaryType 
         * @param {string} :name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPath(path: string, jcr:primaryType: string, :name: string, options?: any) {
            return SlingApiFp(configuration).postPath(path, jcr:primaryType, :name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} path 
         * @param {number} pLimit 
         * @param {string} _1property 
         * @param {string} _1propertyValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options?: any) {
            return SlingApiFp(configuration).postQuery(path, pLimit, _1property, _1propertyValue, options)(fetch, basePath);
        },
        /**
         * 
         * @param {boolean} ignoredeactivated 
         * @param {boolean} onlymodified 
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, options?: any) {
            return SlingApiFp(configuration).postTreeActivation(ignoredeactivated, onlymodified, path, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [:operation] 
         * @param {string} [newPassword] 
         * @param {string} [rePassword] 
         * @param {string} [keyStoreType] 
         * @param {string} [removeAlias] 
         * @param {any} [certificate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: any, options?: any) {
            return SlingApiFp(configuration).postTruststore(:operation, newPassword, rePassword, keyStoreType, removeAlias, certificate, options)(fetch, basePath);
        },
        /**
         * 
         * @param {any} [truststoreP12] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTruststorePKCS12(truststoreP12?: any, options?: any) {
            return SlingApiFp(configuration).postTruststorePKCS12(truststoreP12, options)(fetch, basePath);
        },
    };
};

/**
 * SlingApi - object-oriented interface
 * @export
 * @class SlingApi
 * @extends {BaseAPI}
 */
export class SlingApi extends BaseAPI {
    /**
     * 
     * @param {string} runmode 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public deleteAgent(runmode: string, name: string, options?: any) {
        return SlingApiFp(this.configuration).deleteAgent(runmode, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} path 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public deleteNode(path: string, name: string, options?: any) {
        return SlingApiFp(this.configuration).deleteNode(path, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} runmode 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public getAgent(runmode: string, name: string, options?: any) {
        return SlingApiFp(this.configuration).getAgent(runmode, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} runmode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public getAgents(runmode: string, options?: any) {
        return SlingApiFp(this.configuration).getAgents(runmode, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} intermediatePath 
     * @param {string} authorizableId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, options?: any) {
        return SlingApiFp(this.configuration).getAuthorizableKeystore(intermediatePath, authorizableId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} intermediatePath 
     * @param {string} authorizableId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public getKeystore(intermediatePath: string, authorizableId: string, options?: any) {
        return SlingApiFp(this.configuration).getKeystore(intermediatePath, authorizableId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} path 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public getNode(path: string, name: string, options?: any) {
        return SlingApiFp(this.configuration).getNode(path, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} group 
     * @param {string} name 
     * @param {string} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public getPackage(group: string, name: string, version: string, options?: any) {
        return SlingApiFp(this.configuration).getPackage(group, name, version, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} group 
     * @param {string} name 
     * @param {string} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public getPackageFilter(group: string, name: string, version: string, options?: any) {
        return SlingApiFp(this.configuration).getPackageFilter(group, name, version, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} path 
     * @param {number} pLimit 
     * @param {string} _1property 
     * @param {string} _1propertyValue 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options?: any) {
        return SlingApiFp(this.configuration).getQuery(path, pLimit, _1property, _1propertyValue, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public getTruststore(options?: any) {
        return SlingApiFp(this.configuration).getTruststore(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public getTruststoreInfo(options?: any) {
        return SlingApiFp(this.configuration).getTruststoreInfo(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} runmode 
     * @param {string} name 
     * @param {boolean} [jcr:contentCq:distribute] 
     * @param {string} [jcr:contentCq:distribute@TypeHint] 
     * @param {string} [jcr:contentCq:name] 
     * @param {string} [jcr:contentCq:template] 
     * @param {boolean} [jcr:contentEnabled] 
     * @param {string} [jcr:contentJcr:description] 
     * @param {string} [jcr:contentJcr:lastModified] 
     * @param {string} [jcr:contentJcr:lastModifiedBy] 
     * @param {string} [jcr:contentJcr:mixinTypes] 
     * @param {string} [jcr:contentJcr:title] 
     * @param {string} [jcr:contentLogLevel] 
     * @param {boolean} [jcr:contentNoStatusUpdate] 
     * @param {boolean} [jcr:contentNoVersioning] 
     * @param {number} [jcr:contentProtocolConnectTimeout] 
     * @param {boolean} [jcr:contentProtocolHTTPConnectionClosed] 
     * @param {string} [jcr:contentProtocolHTTPExpired] 
     * @param {Array<string>} [jcr:contentProtocolHTTPHeaders] 
     * @param {string} [jcr:contentProtocolHTTPHeaders@TypeHint] 
     * @param {string} [jcr:contentProtocolHTTPMethod] 
     * @param {boolean} [jcr:contentProtocolHTTPSRelaxed] 
     * @param {string} [jcr:contentProtocolInterface] 
     * @param {number} [jcr:contentProtocolSocketTimeout] 
     * @param {string} [jcr:contentProtocolVersion] 
     * @param {string} [jcr:contentProxyNTLMDomain] 
     * @param {string} [jcr:contentProxyNTLMHost] 
     * @param {string} [jcr:contentProxyHost] 
     * @param {string} [jcr:contentProxyPassword] 
     * @param {number} [jcr:contentProxyPort] 
     * @param {string} [jcr:contentProxyUser] 
     * @param {number} [jcr:contentQueueBatchMaxSize] 
     * @param {string} [jcr:contentQueueBatchMode] 
     * @param {number} [jcr:contentQueueBatchWaitTime] 
     * @param {string} [jcr:contentRetryDelay] 
     * @param {boolean} [jcr:contentReverseReplication] 
     * @param {string} [jcr:contentSerializationType] 
     * @param {string} [jcr:contentSling:resourceType] 
     * @param {string} [jcr:contentSsl] 
     * @param {string} [jcr:contentTransportNTLMDomain] 
     * @param {string} [jcr:contentTransportNTLMHost] 
     * @param {string} [jcr:contentTransportPassword] 
     * @param {string} [jcr:contentTransportUri] 
     * @param {string} [jcr:contentTransportUser] 
     * @param {boolean} [jcr:contentTriggerDistribute] 
     * @param {boolean} [jcr:contentTriggerModified] 
     * @param {boolean} [jcr:contentTriggerOnOffTime] 
     * @param {boolean} [jcr:contentTriggerReceive] 
     * @param {boolean} [jcr:contentTriggerSpecific] 
     * @param {string} [jcr:contentUserId] 
     * @param {string} [jcr:primaryType] 
     * @param {string} [:operation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, options?: any) {
        return SlingApiFp(this.configuration).postAgent(runmode, name, jcr:contentCq:distribute, jcr:contentCq:distribute@TypeHint, jcr:contentCq:name, jcr:contentCq:template, jcr:contentEnabled, jcr:contentJcr:description, jcr:contentJcr:lastModified, jcr:contentJcr:lastModifiedBy, jcr:contentJcr:mixinTypes, jcr:contentJcr:title, jcr:contentLogLevel, jcr:contentNoStatusUpdate, jcr:contentNoVersioning, jcr:contentProtocolConnectTimeout, jcr:contentProtocolHTTPConnectionClosed, jcr:contentProtocolHTTPExpired, jcr:contentProtocolHTTPHeaders, jcr:contentProtocolHTTPHeaders@TypeHint, jcr:contentProtocolHTTPMethod, jcr:contentProtocolHTTPSRelaxed, jcr:contentProtocolInterface, jcr:contentProtocolSocketTimeout, jcr:contentProtocolVersion, jcr:contentProxyNTLMDomain, jcr:contentProxyNTLMHost, jcr:contentProxyHost, jcr:contentProxyPassword, jcr:contentProxyPort, jcr:contentProxyUser, jcr:contentQueueBatchMaxSize, jcr:contentQueueBatchMode, jcr:contentQueueBatchWaitTime, jcr:contentRetryDelay, jcr:contentReverseReplication, jcr:contentSerializationType, jcr:contentSling:resourceType, jcr:contentSsl, jcr:contentTransportNTLMDomain, jcr:contentTransportNTLMHost, jcr:contentTransportPassword, jcr:contentTransportUri, jcr:contentTransportUser, jcr:contentTriggerDistribute, jcr:contentTriggerModified, jcr:contentTriggerOnOffTime, jcr:contentTriggerReceive, jcr:contentTriggerSpecific, jcr:contentUserId, jcr:primaryType, :operation, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} intermediatePath 
     * @param {string} authorizableId 
     * @param {string} [:operation] 
     * @param {string} [currentPassword] 
     * @param {string} [newPassword] 
     * @param {string} [rePassword] 
     * @param {string} [keyPassword] 
     * @param {string} [keyStorePass] 
     * @param {string} [alias] 
     * @param {string} [newAlias] 
     * @param {string} [removeAlias] 
     * @param {any} [certChain] 
     * @param {any} [pk] 
     * @param {any} [keyStore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: any, pk?: any, keyStore?: any, options?: any) {
        return SlingApiFp(this.configuration).postAuthorizableKeystore(intermediatePath, authorizableId, :operation, currentPassword, newPassword, rePassword, keyPassword, keyStorePass, alias, newAlias, removeAlias, certChain, pk, keyStore, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} authorizableId 
     * @param {string} intermediatePath 
     * @param {string} [createUser] 
     * @param {string} [createGroup] 
     * @param {string} [rep:password] 
     * @param {string} [profileGivenName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, options?: any) {
        return SlingApiFp(this.configuration).postAuthorizables(authorizableId, intermediatePath, createUser, createGroup, rep:password, profileGivenName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [keyStorePassword] 
     * @param {string} [keyStorePassword@TypeHint] 
     * @param {number} [serviceRanking] 
     * @param {string} [serviceRanking@TypeHint] 
     * @param {boolean} [idpHttpRedirect] 
     * @param {string} [idpHttpRedirect@TypeHint] 
     * @param {boolean} [createUser] 
     * @param {string} [createUser@TypeHint] 
     * @param {string} [defaultRedirectUrl] 
     * @param {string} [defaultRedirectUrl@TypeHint] 
     * @param {string} [userIDAttribute] 
     * @param {string} [userIDAttribute@TypeHint] 
     * @param {Array<string>} [defaultGroups] 
     * @param {string} [defaultGroups@TypeHint] 
     * @param {string} [idpCertAlias] 
     * @param {string} [idpCertAlias@TypeHint] 
     * @param {boolean} [addGroupMemberships] 
     * @param {string} [addGroupMemberships@TypeHint] 
     * @param {Array<string>} [path] 
     * @param {string} [path@TypeHint] 
     * @param {Array<string>} [synchronizeAttributes] 
     * @param {string} [synchronizeAttributes@TypeHint] 
     * @param {number} [clockTolerance] 
     * @param {string} [clockTolerance@TypeHint] 
     * @param {string} [groupMembershipAttribute] 
     * @param {string} [groupMembershipAttribute@TypeHint] 
     * @param {string} [idpUrl] 
     * @param {string} [idpUrl@TypeHint] 
     * @param {string} [logoutUrl] 
     * @param {string} [logoutUrl@TypeHint] 
     * @param {string} [serviceProviderEntityId] 
     * @param {string} [serviceProviderEntityId@TypeHint] 
     * @param {string} [assertionConsumerServiceURL] 
     * @param {string} [assertionConsumerServiceURL@TypeHint] 
     * @param {boolean} [handleLogout] 
     * @param {string} [handleLogout@TypeHint] 
     * @param {string} [spPrivateKeyAlias] 
     * @param {string} [spPrivateKeyAlias@TypeHint] 
     * @param {boolean} [useEncryption] 
     * @param {string} [useEncryption@TypeHint] 
     * @param {string} [nameIdFormat] 
     * @param {string} [nameIdFormat@TypeHint] 
     * @param {string} [digestMethod] 
     * @param {string} [digestMethod@TypeHint] 
     * @param {string} [signatureMethod] 
     * @param {string} [signatureMethod@TypeHint] 
     * @param {string} [userIntermediatePath] 
     * @param {string} [userIntermediatePath@TypeHint] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, options?: any) {
        return SlingApiFp(this.configuration).postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword, keyStorePassword@TypeHint, serviceRanking, serviceRanking@TypeHint, idpHttpRedirect, idpHttpRedirect@TypeHint, createUser, createUser@TypeHint, defaultRedirectUrl, defaultRedirectUrl@TypeHint, userIDAttribute, userIDAttribute@TypeHint, defaultGroups, defaultGroups@TypeHint, idpCertAlias, idpCertAlias@TypeHint, addGroupMemberships, addGroupMemberships@TypeHint, path, path@TypeHint, synchronizeAttributes, synchronizeAttributes@TypeHint, clockTolerance, clockTolerance@TypeHint, groupMembershipAttribute, groupMembershipAttribute@TypeHint, idpUrl, idpUrl@TypeHint, logoutUrl, logoutUrl@TypeHint, serviceProviderEntityId, serviceProviderEntityId@TypeHint, assertionConsumerServiceURL, assertionConsumerServiceURL@TypeHint, handleLogout, handleLogout@TypeHint, spPrivateKeyAlias, spPrivateKeyAlias@TypeHint, useEncryption, useEncryption@TypeHint, nameIdFormat, nameIdFormat@TypeHint, digestMethod, digestMethod@TypeHint, signatureMethod, signatureMethod@TypeHint, userIntermediatePath, userIntermediatePath@TypeHint, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {boolean} [orgApacheFelixHttpsNio] 
     * @param {string} [orgApacheFelixHttpsNio@TypeHint] 
     * @param {string} [orgApacheFelixHttpsKeystore] 
     * @param {string} [orgApacheFelixHttpsKeystore@TypeHint] 
     * @param {string} [orgApacheFelixHttpsKeystorePassword] 
     * @param {string} [orgApacheFelixHttpsKeystorePassword@TypeHint] 
     * @param {string} [orgApacheFelixHttpsKeystoreKey] 
     * @param {string} [orgApacheFelixHttpsKeystoreKey@TypeHint] 
     * @param {string} [orgApacheFelixHttpsKeystoreKeyPassword] 
     * @param {string} [orgApacheFelixHttpsKeystoreKeyPassword@TypeHint] 
     * @param {string} [orgApacheFelixHttpsTruststore] 
     * @param {string} [orgApacheFelixHttpsTruststore@TypeHint] 
     * @param {string} [orgApacheFelixHttpsTruststorePassword] 
     * @param {string} [orgApacheFelixHttpsTruststorePassword@TypeHint] 
     * @param {string} [orgApacheFelixHttpsClientcertificate] 
     * @param {string} [orgApacheFelixHttpsClientcertificate@TypeHint] 
     * @param {boolean} [orgApacheFelixHttpsEnable] 
     * @param {string} [orgApacheFelixHttpsEnable@TypeHint] 
     * @param {string} [orgOsgiServiceHttpPortSecure] 
     * @param {string} [orgOsgiServiceHttpPortSecure@TypeHint] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, options?: any) {
        return SlingApiFp(this.configuration).postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio, orgApacheFelixHttpsNio@TypeHint, orgApacheFelixHttpsKeystore, orgApacheFelixHttpsKeystore@TypeHint, orgApacheFelixHttpsKeystorePassword, orgApacheFelixHttpsKeystorePassword@TypeHint, orgApacheFelixHttpsKeystoreKey, orgApacheFelixHttpsKeystoreKey@TypeHint, orgApacheFelixHttpsKeystoreKeyPassword, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint, orgApacheFelixHttpsTruststore, orgApacheFelixHttpsTruststore@TypeHint, orgApacheFelixHttpsTruststorePassword, orgApacheFelixHttpsTruststorePassword@TypeHint, orgApacheFelixHttpsClientcertificate, orgApacheFelixHttpsClientcertificate@TypeHint, orgApacheFelixHttpsEnable, orgApacheFelixHttpsEnable@TypeHint, orgOsgiServiceHttpPortSecure, orgOsgiServiceHttpPortSecure@TypeHint, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [proxyHost] 
     * @param {string} [proxyHost@TypeHint] 
     * @param {number} [proxyPort] 
     * @param {string} [proxyPort@TypeHint] 
     * @param {Array<string>} [proxyExceptions] 
     * @param {string} [proxyExceptions@TypeHint] 
     * @param {boolean} [proxyEnabled] 
     * @param {string} [proxyEnabled@TypeHint] 
     * @param {string} [proxyUser] 
     * @param {string} [proxyUser@TypeHint] 
     * @param {string} [proxyPassword] 
     * @param {string} [proxyPassword@TypeHint] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, options?: any) {
        return SlingApiFp(this.configuration).postConfigApacheHttpComponentsProxyConfiguration(proxyHost, proxyHost@TypeHint, proxyPort, proxyPort@TypeHint, proxyExceptions, proxyExceptions@TypeHint, proxyEnabled, proxyEnabled@TypeHint, proxyUser, proxyUser@TypeHint, proxyPassword, proxyPassword@TypeHint, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [alias] 
     * @param {string} [alias@TypeHint] 
     * @param {boolean} [davCreateAbsoluteUri] 
     * @param {string} [davCreateAbsoluteUri@TypeHint] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, options?: any) {
        return SlingApiFp(this.configuration).postConfigApacheSlingDavExServlet(alias, alias@TypeHint, davCreateAbsoluteUri, davCreateAbsoluteUri@TypeHint, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [jsonMaximumresults] 
     * @param {string} [jsonMaximumresults@TypeHint] 
     * @param {boolean} [enableHtml] 
     * @param {string} [enableHtml@TypeHint] 
     * @param {boolean} [enableTxt] 
     * @param {string} [enableTxt@TypeHint] 
     * @param {boolean} [enableXml] 
     * @param {string} [enableXml@TypeHint] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, options?: any) {
        return SlingApiFp(this.configuration).postConfigApacheSlingGetServlet(jsonMaximumresults, jsonMaximumresults@TypeHint, enableHtml, enableHtml@TypeHint, enableTxt, enableTxt@TypeHint, enableXml, enableXml@TypeHint, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {boolean} [allowEmpty] 
     * @param {string} [allowEmpty@TypeHint] 
     * @param {string} [allowHosts] 
     * @param {string} [allowHosts@TypeHint] 
     * @param {string} [allowHostsRegexp] 
     * @param {string} [allowHostsRegexp@TypeHint] 
     * @param {string} [filterMethods] 
     * @param {string} [filterMethods@TypeHint] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, options?: any) {
        return SlingApiFp(this.configuration).postConfigApacheSlingReferrerFilter(allowEmpty, allowEmpty@TypeHint, allowHosts, allowHosts@TypeHint, allowHostsRegexp, allowHostsRegexp@TypeHint, filterMethods, filterMethods@TypeHint, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} path 
     * @param {string} name 
     * @param {string} [:operation] 
     * @param {string} [deleteAuthorizable] 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: any, options?: any) {
        return SlingApiFp(this.configuration).postNode(path, name, :operation, deleteAuthorizable, file, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} path 
     * @param {string} name 
     * @param {string} [addMembers] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postNodeRw(path: string, name: string, addMembers?: string, options?: any) {
        return SlingApiFp(this.configuration).postNodeRw(path, name, addMembers, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} path 
     * @param {string} jcr:primaryType 
     * @param {string} :name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postPath(path: string, jcr:primaryType: string, :name: string, options?: any) {
        return SlingApiFp(this.configuration).postPath(path, jcr:primaryType, :name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} path 
     * @param {number} pLimit 
     * @param {string} _1property 
     * @param {string} _1propertyValue 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options?: any) {
        return SlingApiFp(this.configuration).postQuery(path, pLimit, _1property, _1propertyValue, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {boolean} ignoredeactivated 
     * @param {boolean} onlymodified 
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, options?: any) {
        return SlingApiFp(this.configuration).postTreeActivation(ignoredeactivated, onlymodified, path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [:operation] 
     * @param {string} [newPassword] 
     * @param {string} [rePassword] 
     * @param {string} [keyStoreType] 
     * @param {string} [removeAlias] 
     * @param {any} [certificate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: any, options?: any) {
        return SlingApiFp(this.configuration).postTruststore(:operation, newPassword, rePassword, keyStoreType, removeAlias, certificate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {any} [truststoreP12] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlingApi
     */
    public postTruststorePKCS12(truststoreP12?: any, options?: any) {
        return SlingApiFp(this.configuration).postTruststorePKCS12(truststoreP12, options)(this.fetch, this.basePath);
    }

}

