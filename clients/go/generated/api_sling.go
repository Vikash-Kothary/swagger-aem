/*
 * Adobe Experience Manager (AEM) API
 *
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * API version: 3.2.0-pre.0
 * Contact: opensource@shinesolutions.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
	"os"
)

// Linger please
var (
	_ context.Context
)

type SlingApiService service

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param runmode
 * @param name
*/
func (a *SlingApiService) DeleteAgent(ctx context.Context, runmode string, name string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/etc/replication/agents.{runmode}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"runmode"+"}", fmt.Sprintf("%v", runmode), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param path
 * @param name
*/
func (a *SlingApiService) DeleteNode(ctx context.Context, path string, name string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/{path}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", fmt.Sprintf("%v", path), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param runmode
 * @param name
*/
func (a *SlingApiService) GetAgent(ctx context.Context, runmode string, name string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/etc/replication/agents.{runmode}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"runmode"+"}", fmt.Sprintf("%v", runmode), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param runmode
@return string
*/
func (a *SlingApiService) GetAgents(ctx context.Context, runmode string) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/etc/replication/agents.{runmode}.-1.json"
	localVarPath = strings.Replace(localVarPath, "{"+"runmode"+"}", fmt.Sprintf("%v", runmode), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param intermediatePath
 * @param authorizableId
@return KeystoreInfo
*/
func (a *SlingApiService) GetAuthorizableKeystore(ctx context.Context, intermediatePath string, authorizableId string) (KeystoreInfo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue KeystoreInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/{intermediatePath}/{authorizableId}.ks.json"
	localVarPath = strings.Replace(localVarPath, "{"+"intermediatePath"+"}", fmt.Sprintf("%v", intermediatePath), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorizableId"+"}", fmt.Sprintf("%v", authorizableId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v KeystoreInfo
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param intermediatePath
 * @param authorizableId
@return *os.File
*/
func (a *SlingApiService) GetKeystore(ctx context.Context, intermediatePath string, authorizableId string) (*os.File, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/{intermediatePath}/{authorizableId}/keystore/store.p12"
	localVarPath = strings.Replace(localVarPath, "{"+"intermediatePath"+"}", fmt.Sprintf("%v", intermediatePath), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorizableId"+"}", fmt.Sprintf("%v", authorizableId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v *os.File
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param path
 * @param name
*/
func (a *SlingApiService) GetNode(ctx context.Context, path string, name string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/{path}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", fmt.Sprintf("%v", path), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param group
 * @param name
 * @param version
@return *os.File
*/
func (a *SlingApiService) GetPackage(ctx context.Context, group string, name string, version string) (*os.File, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/etc/packages/{group}/{name}-{version}.zip"
	localVarPath = strings.Replace(localVarPath, "{"+"group"+"}", fmt.Sprintf("%v", group), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", fmt.Sprintf("%v", version), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v *os.File
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param group
 * @param name
 * @param version
@return string
*/
func (a *SlingApiService) GetPackageFilter(ctx context.Context, group string, name string, version string) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json"
	localVarPath = strings.Replace(localVarPath, "{"+"group"+"}", fmt.Sprintf("%v", group), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", fmt.Sprintf("%v", version), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param path
 * @param pLimit
 * @param var1Property
 * @param var1PropertyValue
@return string
*/
func (a *SlingApiService) GetQuery(ctx context.Context, path string, pLimit float32, var1Property string, var1PropertyValue string) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/bin/querybuilder.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("path", parameterToString(path, ""))
	localVarQueryParams.Add("p.limit", parameterToString(pLimit, ""))
	localVarQueryParams.Add("1_property", parameterToString(var1Property, ""))
	localVarQueryParams.Add("1_property.value", parameterToString(var1PropertyValue, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return *os.File
*/
func (a *SlingApiService) GetTruststore(ctx context.Context) (*os.File, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/etc/truststore/truststore.p12"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v *os.File
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return TruststoreInfo
*/
func (a *SlingApiService) GetTruststoreInfo(ctx context.Context) (TruststoreInfo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue TruststoreInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/libs/granite/security/truststore.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v TruststoreInfo
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param runmode
 * @param name
 * @param optional nil or *PostAgentOpts - Optional Parameters:
 * @param "Jcrcontentcqdistribute" (optional.Bool) - 
 * @param "JcrcontentcqdistributeTypeHint" (optional.String) - 
 * @param "Jcrcontentcqname" (optional.String) - 
 * @param "Jcrcontentcqtemplate" (optional.String) - 
 * @param "Jcrcontentenabled" (optional.Bool) - 
 * @param "Jcrcontentjcrdescription" (optional.String) - 
 * @param "JcrcontentjcrlastModified" (optional.String) - 
 * @param "JcrcontentjcrlastModifiedBy" (optional.String) - 
 * @param "JcrcontentjcrmixinTypes" (optional.String) - 
 * @param "Jcrcontentjcrtitle" (optional.String) - 
 * @param "JcrcontentlogLevel" (optional.String) - 
 * @param "JcrcontentnoStatusUpdate" (optional.Bool) - 
 * @param "JcrcontentnoVersioning" (optional.Bool) - 
 * @param "JcrcontentprotocolConnectTimeout" (optional.Float32) - 
 * @param "JcrcontentprotocolHTTPConnectionClosed" (optional.Bool) - 
 * @param "JcrcontentprotocolHTTPExpired" (optional.String) - 
 * @param "JcrcontentprotocolHTTPHeaders" (optional.Interface of []string) - 
 * @param "JcrcontentprotocolHTTPHeadersTypeHint" (optional.String) - 
 * @param "JcrcontentprotocolHTTPMethod" (optional.String) - 
 * @param "JcrcontentprotocolHTTPSRelaxed" (optional.Bool) - 
 * @param "JcrcontentprotocolInterface" (optional.String) - 
 * @param "JcrcontentprotocolSocketTimeout" (optional.Float32) - 
 * @param "JcrcontentprotocolVersion" (optional.String) - 
 * @param "JcrcontentproxyNTLMDomain" (optional.String) - 
 * @param "JcrcontentproxyNTLMHost" (optional.String) - 
 * @param "JcrcontentproxyHost" (optional.String) - 
 * @param "JcrcontentproxyPassword" (optional.String) - 
 * @param "JcrcontentproxyPort" (optional.Float32) - 
 * @param "JcrcontentproxyUser" (optional.String) - 
 * @param "JcrcontentqueueBatchMaxSize" (optional.Float32) - 
 * @param "JcrcontentqueueBatchMode" (optional.String) - 
 * @param "JcrcontentqueueBatchWaitTime" (optional.Float32) - 
 * @param "JcrcontentretryDelay" (optional.String) - 
 * @param "JcrcontentreverseReplication" (optional.Bool) - 
 * @param "JcrcontentserializationType" (optional.String) - 
 * @param "JcrcontentslingresourceType" (optional.String) - 
 * @param "Jcrcontentssl" (optional.String) - 
 * @param "JcrcontenttransportNTLMDomain" (optional.String) - 
 * @param "JcrcontenttransportNTLMHost" (optional.String) - 
 * @param "JcrcontenttransportPassword" (optional.String) - 
 * @param "JcrcontenttransportUri" (optional.String) - 
 * @param "JcrcontenttransportUser" (optional.String) - 
 * @param "JcrcontenttriggerDistribute" (optional.Bool) - 
 * @param "JcrcontenttriggerModified" (optional.Bool) - 
 * @param "JcrcontenttriggerOnOffTime" (optional.Bool) - 
 * @param "JcrcontenttriggerReceive" (optional.Bool) - 
 * @param "JcrcontenttriggerSpecific" (optional.Bool) - 
 * @param "JcrcontentuserId" (optional.String) - 
 * @param "JcrprimaryType" (optional.String) - 
 * @param "Operation" (optional.String) - 
*/

type PostAgentOpts struct {
    Jcrcontentcqdistribute optional.Bool
    JcrcontentcqdistributeTypeHint optional.String
    Jcrcontentcqname optional.String
    Jcrcontentcqtemplate optional.String
    Jcrcontentenabled optional.Bool
    Jcrcontentjcrdescription optional.String
    JcrcontentjcrlastModified optional.String
    JcrcontentjcrlastModifiedBy optional.String
    JcrcontentjcrmixinTypes optional.String
    Jcrcontentjcrtitle optional.String
    JcrcontentlogLevel optional.String
    JcrcontentnoStatusUpdate optional.Bool
    JcrcontentnoVersioning optional.Bool
    JcrcontentprotocolConnectTimeout optional.Float32
    JcrcontentprotocolHTTPConnectionClosed optional.Bool
    JcrcontentprotocolHTTPExpired optional.String
    JcrcontentprotocolHTTPHeaders optional.Interface
    JcrcontentprotocolHTTPHeadersTypeHint optional.String
    JcrcontentprotocolHTTPMethod optional.String
    JcrcontentprotocolHTTPSRelaxed optional.Bool
    JcrcontentprotocolInterface optional.String
    JcrcontentprotocolSocketTimeout optional.Float32
    JcrcontentprotocolVersion optional.String
    JcrcontentproxyNTLMDomain optional.String
    JcrcontentproxyNTLMHost optional.String
    JcrcontentproxyHost optional.String
    JcrcontentproxyPassword optional.String
    JcrcontentproxyPort optional.Float32
    JcrcontentproxyUser optional.String
    JcrcontentqueueBatchMaxSize optional.Float32
    JcrcontentqueueBatchMode optional.String
    JcrcontentqueueBatchWaitTime optional.Float32
    JcrcontentretryDelay optional.String
    JcrcontentreverseReplication optional.Bool
    JcrcontentserializationType optional.String
    JcrcontentslingresourceType optional.String
    Jcrcontentssl optional.String
    JcrcontenttransportNTLMDomain optional.String
    JcrcontenttransportNTLMHost optional.String
    JcrcontenttransportPassword optional.String
    JcrcontenttransportUri optional.String
    JcrcontenttransportUser optional.String
    JcrcontenttriggerDistribute optional.Bool
    JcrcontenttriggerModified optional.Bool
    JcrcontenttriggerOnOffTime optional.Bool
    JcrcontenttriggerReceive optional.Bool
    JcrcontenttriggerSpecific optional.Bool
    JcrcontentuserId optional.String
    JcrprimaryType optional.String
    Operation optional.String
}

func (a *SlingApiService) PostAgent(ctx context.Context, runmode string, name string, localVarOptionals *PostAgentOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/etc/replication/agents.{runmode}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"runmode"+"}", fmt.Sprintf("%v", runmode), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Jcrcontentcqdistribute.IsSet() {
		localVarQueryParams.Add("jcr:content/cq:distribute", parameterToString(localVarOptionals.Jcrcontentcqdistribute.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentcqdistributeTypeHint.IsSet() {
		localVarQueryParams.Add("jcr:content/cq:distribute@TypeHint", parameterToString(localVarOptionals.JcrcontentcqdistributeTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Jcrcontentcqname.IsSet() {
		localVarQueryParams.Add("jcr:content/cq:name", parameterToString(localVarOptionals.Jcrcontentcqname.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Jcrcontentcqtemplate.IsSet() {
		localVarQueryParams.Add("jcr:content/cq:template", parameterToString(localVarOptionals.Jcrcontentcqtemplate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Jcrcontentenabled.IsSet() {
		localVarQueryParams.Add("jcr:content/enabled", parameterToString(localVarOptionals.Jcrcontentenabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Jcrcontentjcrdescription.IsSet() {
		localVarQueryParams.Add("jcr:content/jcr:description", parameterToString(localVarOptionals.Jcrcontentjcrdescription.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentjcrlastModified.IsSet() {
		localVarQueryParams.Add("jcr:content/jcr:lastModified", parameterToString(localVarOptionals.JcrcontentjcrlastModified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentjcrlastModifiedBy.IsSet() {
		localVarQueryParams.Add("jcr:content/jcr:lastModifiedBy", parameterToString(localVarOptionals.JcrcontentjcrlastModifiedBy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentjcrmixinTypes.IsSet() {
		localVarQueryParams.Add("jcr:content/jcr:mixinTypes", parameterToString(localVarOptionals.JcrcontentjcrmixinTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Jcrcontentjcrtitle.IsSet() {
		localVarQueryParams.Add("jcr:content/jcr:title", parameterToString(localVarOptionals.Jcrcontentjcrtitle.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentlogLevel.IsSet() {
		localVarQueryParams.Add("jcr:content/logLevel", parameterToString(localVarOptionals.JcrcontentlogLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentnoStatusUpdate.IsSet() {
		localVarQueryParams.Add("jcr:content/noStatusUpdate", parameterToString(localVarOptionals.JcrcontentnoStatusUpdate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentnoVersioning.IsSet() {
		localVarQueryParams.Add("jcr:content/noVersioning", parameterToString(localVarOptionals.JcrcontentnoVersioning.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentprotocolConnectTimeout.IsSet() {
		localVarQueryParams.Add("jcr:content/protocolConnectTimeout", parameterToString(localVarOptionals.JcrcontentprotocolConnectTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentprotocolHTTPConnectionClosed.IsSet() {
		localVarQueryParams.Add("jcr:content/protocolHTTPConnectionClosed", parameterToString(localVarOptionals.JcrcontentprotocolHTTPConnectionClosed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentprotocolHTTPExpired.IsSet() {
		localVarQueryParams.Add("jcr:content/protocolHTTPExpired", parameterToString(localVarOptionals.JcrcontentprotocolHTTPExpired.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentprotocolHTTPHeaders.IsSet() {
		localVarQueryParams.Add("jcr:content/protocolHTTPHeaders", parameterToString(localVarOptionals.JcrcontentprotocolHTTPHeaders.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentprotocolHTTPHeadersTypeHint.IsSet() {
		localVarQueryParams.Add("jcr:content/protocolHTTPHeaders@TypeHint", parameterToString(localVarOptionals.JcrcontentprotocolHTTPHeadersTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentprotocolHTTPMethod.IsSet() {
		localVarQueryParams.Add("jcr:content/protocolHTTPMethod", parameterToString(localVarOptionals.JcrcontentprotocolHTTPMethod.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentprotocolHTTPSRelaxed.IsSet() {
		localVarQueryParams.Add("jcr:content/protocolHTTPSRelaxed", parameterToString(localVarOptionals.JcrcontentprotocolHTTPSRelaxed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentprotocolInterface.IsSet() {
		localVarQueryParams.Add("jcr:content/protocolInterface", parameterToString(localVarOptionals.JcrcontentprotocolInterface.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentprotocolSocketTimeout.IsSet() {
		localVarQueryParams.Add("jcr:content/protocolSocketTimeout", parameterToString(localVarOptionals.JcrcontentprotocolSocketTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentprotocolVersion.IsSet() {
		localVarQueryParams.Add("jcr:content/protocolVersion", parameterToString(localVarOptionals.JcrcontentprotocolVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentproxyNTLMDomain.IsSet() {
		localVarQueryParams.Add("jcr:content/proxyNTLMDomain", parameterToString(localVarOptionals.JcrcontentproxyNTLMDomain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentproxyNTLMHost.IsSet() {
		localVarQueryParams.Add("jcr:content/proxyNTLMHost", parameterToString(localVarOptionals.JcrcontentproxyNTLMHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentproxyHost.IsSet() {
		localVarQueryParams.Add("jcr:content/proxyHost", parameterToString(localVarOptionals.JcrcontentproxyHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentproxyPassword.IsSet() {
		localVarQueryParams.Add("jcr:content/proxyPassword", parameterToString(localVarOptionals.JcrcontentproxyPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentproxyPort.IsSet() {
		localVarQueryParams.Add("jcr:content/proxyPort", parameterToString(localVarOptionals.JcrcontentproxyPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentproxyUser.IsSet() {
		localVarQueryParams.Add("jcr:content/proxyUser", parameterToString(localVarOptionals.JcrcontentproxyUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentqueueBatchMaxSize.IsSet() {
		localVarQueryParams.Add("jcr:content/queueBatchMaxSize", parameterToString(localVarOptionals.JcrcontentqueueBatchMaxSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentqueueBatchMode.IsSet() {
		localVarQueryParams.Add("jcr:content/queueBatchMode", parameterToString(localVarOptionals.JcrcontentqueueBatchMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentqueueBatchWaitTime.IsSet() {
		localVarQueryParams.Add("jcr:content/queueBatchWaitTime", parameterToString(localVarOptionals.JcrcontentqueueBatchWaitTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentretryDelay.IsSet() {
		localVarQueryParams.Add("jcr:content/retryDelay", parameterToString(localVarOptionals.JcrcontentretryDelay.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentreverseReplication.IsSet() {
		localVarQueryParams.Add("jcr:content/reverseReplication", parameterToString(localVarOptionals.JcrcontentreverseReplication.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentserializationType.IsSet() {
		localVarQueryParams.Add("jcr:content/serializationType", parameterToString(localVarOptionals.JcrcontentserializationType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentslingresourceType.IsSet() {
		localVarQueryParams.Add("jcr:content/sling:resourceType", parameterToString(localVarOptionals.JcrcontentslingresourceType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Jcrcontentssl.IsSet() {
		localVarQueryParams.Add("jcr:content/ssl", parameterToString(localVarOptionals.Jcrcontentssl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontenttransportNTLMDomain.IsSet() {
		localVarQueryParams.Add("jcr:content/transportNTLMDomain", parameterToString(localVarOptionals.JcrcontenttransportNTLMDomain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontenttransportNTLMHost.IsSet() {
		localVarQueryParams.Add("jcr:content/transportNTLMHost", parameterToString(localVarOptionals.JcrcontenttransportNTLMHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontenttransportPassword.IsSet() {
		localVarQueryParams.Add("jcr:content/transportPassword", parameterToString(localVarOptionals.JcrcontenttransportPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontenttransportUri.IsSet() {
		localVarQueryParams.Add("jcr:content/transportUri", parameterToString(localVarOptionals.JcrcontenttransportUri.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontenttransportUser.IsSet() {
		localVarQueryParams.Add("jcr:content/transportUser", parameterToString(localVarOptionals.JcrcontenttransportUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontenttriggerDistribute.IsSet() {
		localVarQueryParams.Add("jcr:content/triggerDistribute", parameterToString(localVarOptionals.JcrcontenttriggerDistribute.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontenttriggerModified.IsSet() {
		localVarQueryParams.Add("jcr:content/triggerModified", parameterToString(localVarOptionals.JcrcontenttriggerModified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontenttriggerOnOffTime.IsSet() {
		localVarQueryParams.Add("jcr:content/triggerOnOffTime", parameterToString(localVarOptionals.JcrcontenttriggerOnOffTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontenttriggerReceive.IsSet() {
		localVarQueryParams.Add("jcr:content/triggerReceive", parameterToString(localVarOptionals.JcrcontenttriggerReceive.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontenttriggerSpecific.IsSet() {
		localVarQueryParams.Add("jcr:content/triggerSpecific", parameterToString(localVarOptionals.JcrcontenttriggerSpecific.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrcontentuserId.IsSet() {
		localVarQueryParams.Add("jcr:content/userId", parameterToString(localVarOptionals.JcrcontentuserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JcrprimaryType.IsSet() {
		localVarQueryParams.Add("jcr:primaryType", parameterToString(localVarOptionals.JcrprimaryType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Operation.IsSet() {
		localVarQueryParams.Add(":operation", parameterToString(localVarOptionals.Operation.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param intermediatePath
 * @param authorizableId
 * @param optional nil or *PostAuthorizableKeystoreOpts - Optional Parameters:
 * @param "Operation" (optional.String) - 
 * @param "CurrentPassword" (optional.String) - 
 * @param "NewPassword" (optional.String) - 
 * @param "RePassword" (optional.String) - 
 * @param "KeyPassword" (optional.String) - 
 * @param "KeyStorePass" (optional.String) - 
 * @param "Alias" (optional.String) - 
 * @param "NewAlias" (optional.String) - 
 * @param "RemoveAlias" (optional.String) - 
 * @param "CertChain" (optional.Interface of *os.File) - 
 * @param "Pk" (optional.Interface of *os.File) - 
 * @param "KeyStore" (optional.Interface of *os.File) - 
@return KeystoreInfo
*/

type PostAuthorizableKeystoreOpts struct {
    Operation optional.String
    CurrentPassword optional.String
    NewPassword optional.String
    RePassword optional.String
    KeyPassword optional.String
    KeyStorePass optional.String
    Alias optional.String
    NewAlias optional.String
    RemoveAlias optional.String
    CertChain optional.Interface
    Pk optional.Interface
    KeyStore optional.Interface
}

func (a *SlingApiService) PostAuthorizableKeystore(ctx context.Context, intermediatePath string, authorizableId string, localVarOptionals *PostAuthorizableKeystoreOpts) (KeystoreInfo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue KeystoreInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/{intermediatePath}/{authorizableId}.ks.html"
	localVarPath = strings.Replace(localVarPath, "{"+"intermediatePath"+"}", fmt.Sprintf("%v", intermediatePath), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorizableId"+"}", fmt.Sprintf("%v", authorizableId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Operation.IsSet() {
		localVarQueryParams.Add(":operation", parameterToString(localVarOptionals.Operation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CurrentPassword.IsSet() {
		localVarQueryParams.Add("currentPassword", parameterToString(localVarOptionals.CurrentPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewPassword.IsSet() {
		localVarQueryParams.Add("newPassword", parameterToString(localVarOptionals.NewPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RePassword.IsSet() {
		localVarQueryParams.Add("rePassword", parameterToString(localVarOptionals.RePassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.KeyPassword.IsSet() {
		localVarQueryParams.Add("keyPassword", parameterToString(localVarOptionals.KeyPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.KeyStorePass.IsSet() {
		localVarQueryParams.Add("keyStorePass", parameterToString(localVarOptionals.KeyStorePass.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Alias.IsSet() {
		localVarQueryParams.Add("alias", parameterToString(localVarOptionals.Alias.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewAlias.IsSet() {
		localVarQueryParams.Add("newAlias", parameterToString(localVarOptionals.NewAlias.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoveAlias.IsSet() {
		localVarQueryParams.Add("removeAlias", parameterToString(localVarOptionals.RemoveAlias.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormFileName = "cert-chain"
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.CertChain.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.CertChain.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("certChain should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	localVarFormFileName = "pk"
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.Pk.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.Pk.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("pk should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	localVarFormFileName = "keyStore"
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.KeyStore.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.KeyStore.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("keyStore should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v KeystoreInfo
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param authorizableId
 * @param intermediatePath
 * @param optional nil or *PostAuthorizablesOpts - Optional Parameters:
 * @param "CreateUser" (optional.String) - 
 * @param "CreateGroup" (optional.String) - 
 * @param "Reppassword" (optional.String) - 
 * @param "ProfilegivenName" (optional.String) - 
@return string
*/

type PostAuthorizablesOpts struct {
    CreateUser optional.String
    CreateGroup optional.String
    Reppassword optional.String
    ProfilegivenName optional.String
}

func (a *SlingApiService) PostAuthorizables(ctx context.Context, authorizableId string, intermediatePath string, localVarOptionals *PostAuthorizablesOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/libs/granite/security/post/authorizables"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("authorizableId", parameterToString(authorizableId, ""))
	localVarQueryParams.Add("intermediatePath", parameterToString(intermediatePath, ""))
	if localVarOptionals != nil && localVarOptionals.CreateUser.IsSet() {
		localVarQueryParams.Add("createUser", parameterToString(localVarOptionals.CreateUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreateGroup.IsSet() {
		localVarQueryParams.Add("createGroup", parameterToString(localVarOptionals.CreateGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Reppassword.IsSet() {
		localVarQueryParams.Add("rep:password", parameterToString(localVarOptionals.Reppassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProfilegivenName.IsSet() {
		localVarQueryParams.Add("profile/givenName", parameterToString(localVarOptionals.ProfilegivenName.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PostConfigAdobeGraniteSamlAuthenticationHandlerOpts - Optional Parameters:
 * @param "KeyStorePassword" (optional.String) - 
 * @param "KeyStorePasswordTypeHint" (optional.String) - 
 * @param "ServiceRanking" (optional.Int32) - 
 * @param "ServiceRankingTypeHint" (optional.String) - 
 * @param "IdpHttpRedirect" (optional.Bool) - 
 * @param "IdpHttpRedirectTypeHint" (optional.String) - 
 * @param "CreateUser" (optional.Bool) - 
 * @param "CreateUserTypeHint" (optional.String) - 
 * @param "DefaultRedirectUrl" (optional.String) - 
 * @param "DefaultRedirectUrlTypeHint" (optional.String) - 
 * @param "UserIDAttribute" (optional.String) - 
 * @param "UserIDAttributeTypeHint" (optional.String) - 
 * @param "DefaultGroups" (optional.Interface of []string) - 
 * @param "DefaultGroupsTypeHint" (optional.String) - 
 * @param "IdpCertAlias" (optional.String) - 
 * @param "IdpCertAliasTypeHint" (optional.String) - 
 * @param "AddGroupMemberships" (optional.Bool) - 
 * @param "AddGroupMembershipsTypeHint" (optional.String) - 
 * @param "Path" (optional.Interface of []string) - 
 * @param "PathTypeHint" (optional.String) - 
 * @param "SynchronizeAttributes" (optional.Interface of []string) - 
 * @param "SynchronizeAttributesTypeHint" (optional.String) - 
 * @param "ClockTolerance" (optional.Int32) - 
 * @param "ClockToleranceTypeHint" (optional.String) - 
 * @param "GroupMembershipAttribute" (optional.String) - 
 * @param "GroupMembershipAttributeTypeHint" (optional.String) - 
 * @param "IdpUrl" (optional.String) - 
 * @param "IdpUrlTypeHint" (optional.String) - 
 * @param "LogoutUrl" (optional.String) - 
 * @param "LogoutUrlTypeHint" (optional.String) - 
 * @param "ServiceProviderEntityId" (optional.String) - 
 * @param "ServiceProviderEntityIdTypeHint" (optional.String) - 
 * @param "AssertionConsumerServiceURL" (optional.String) - 
 * @param "AssertionConsumerServiceURLTypeHint" (optional.String) - 
 * @param "HandleLogout" (optional.Bool) - 
 * @param "HandleLogoutTypeHint" (optional.String) - 
 * @param "SpPrivateKeyAlias" (optional.String) - 
 * @param "SpPrivateKeyAliasTypeHint" (optional.String) - 
 * @param "UseEncryption" (optional.Bool) - 
 * @param "UseEncryptionTypeHint" (optional.String) - 
 * @param "NameIdFormat" (optional.String) - 
 * @param "NameIdFormatTypeHint" (optional.String) - 
 * @param "DigestMethod" (optional.String) - 
 * @param "DigestMethodTypeHint" (optional.String) - 
 * @param "SignatureMethod" (optional.String) - 
 * @param "SignatureMethodTypeHint" (optional.String) - 
 * @param "UserIntermediatePath" (optional.String) - 
 * @param "UserIntermediatePathTypeHint" (optional.String) - 
*/

type PostConfigAdobeGraniteSamlAuthenticationHandlerOpts struct {
    KeyStorePassword optional.String
    KeyStorePasswordTypeHint optional.String
    ServiceRanking optional.Int32
    ServiceRankingTypeHint optional.String
    IdpHttpRedirect optional.Bool
    IdpHttpRedirectTypeHint optional.String
    CreateUser optional.Bool
    CreateUserTypeHint optional.String
    DefaultRedirectUrl optional.String
    DefaultRedirectUrlTypeHint optional.String
    UserIDAttribute optional.String
    UserIDAttributeTypeHint optional.String
    DefaultGroups optional.Interface
    DefaultGroupsTypeHint optional.String
    IdpCertAlias optional.String
    IdpCertAliasTypeHint optional.String
    AddGroupMemberships optional.Bool
    AddGroupMembershipsTypeHint optional.String
    Path optional.Interface
    PathTypeHint optional.String
    SynchronizeAttributes optional.Interface
    SynchronizeAttributesTypeHint optional.String
    ClockTolerance optional.Int32
    ClockToleranceTypeHint optional.String
    GroupMembershipAttribute optional.String
    GroupMembershipAttributeTypeHint optional.String
    IdpUrl optional.String
    IdpUrlTypeHint optional.String
    LogoutUrl optional.String
    LogoutUrlTypeHint optional.String
    ServiceProviderEntityId optional.String
    ServiceProviderEntityIdTypeHint optional.String
    AssertionConsumerServiceURL optional.String
    AssertionConsumerServiceURLTypeHint optional.String
    HandleLogout optional.Bool
    HandleLogoutTypeHint optional.String
    SpPrivateKeyAlias optional.String
    SpPrivateKeyAliasTypeHint optional.String
    UseEncryption optional.Bool
    UseEncryptionTypeHint optional.String
    NameIdFormat optional.String
    NameIdFormatTypeHint optional.String
    DigestMethod optional.String
    DigestMethodTypeHint optional.String
    SignatureMethod optional.String
    SignatureMethodTypeHint optional.String
    UserIntermediatePath optional.String
    UserIntermediatePathTypeHint optional.String
}

func (a *SlingApiService) PostConfigAdobeGraniteSamlAuthenticationHandler(ctx context.Context, localVarOptionals *PostConfigAdobeGraniteSamlAuthenticationHandlerOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.KeyStorePassword.IsSet() {
		localVarQueryParams.Add("keyStorePassword", parameterToString(localVarOptionals.KeyStorePassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.KeyStorePasswordTypeHint.IsSet() {
		localVarQueryParams.Add("keyStorePassword@TypeHint", parameterToString(localVarOptionals.KeyStorePasswordTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceRanking.IsSet() {
		localVarQueryParams.Add("service.ranking", parameterToString(localVarOptionals.ServiceRanking.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceRankingTypeHint.IsSet() {
		localVarQueryParams.Add("service.ranking@TypeHint", parameterToString(localVarOptionals.ServiceRankingTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdpHttpRedirect.IsSet() {
		localVarQueryParams.Add("idpHttpRedirect", parameterToString(localVarOptionals.IdpHttpRedirect.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdpHttpRedirectTypeHint.IsSet() {
		localVarQueryParams.Add("idpHttpRedirect@TypeHint", parameterToString(localVarOptionals.IdpHttpRedirectTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreateUser.IsSet() {
		localVarQueryParams.Add("createUser", parameterToString(localVarOptionals.CreateUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreateUserTypeHint.IsSet() {
		localVarQueryParams.Add("createUser@TypeHint", parameterToString(localVarOptionals.CreateUserTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DefaultRedirectUrl.IsSet() {
		localVarQueryParams.Add("defaultRedirectUrl", parameterToString(localVarOptionals.DefaultRedirectUrl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DefaultRedirectUrlTypeHint.IsSet() {
		localVarQueryParams.Add("defaultRedirectUrl@TypeHint", parameterToString(localVarOptionals.DefaultRedirectUrlTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserIDAttribute.IsSet() {
		localVarQueryParams.Add("userIDAttribute", parameterToString(localVarOptionals.UserIDAttribute.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserIDAttributeTypeHint.IsSet() {
		localVarQueryParams.Add("userIDAttribute@TypeHint", parameterToString(localVarOptionals.UserIDAttributeTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DefaultGroups.IsSet() {
		localVarQueryParams.Add("defaultGroups", parameterToString(localVarOptionals.DefaultGroups.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DefaultGroupsTypeHint.IsSet() {
		localVarQueryParams.Add("defaultGroups@TypeHint", parameterToString(localVarOptionals.DefaultGroupsTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdpCertAlias.IsSet() {
		localVarQueryParams.Add("idpCertAlias", parameterToString(localVarOptionals.IdpCertAlias.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdpCertAliasTypeHint.IsSet() {
		localVarQueryParams.Add("idpCertAlias@TypeHint", parameterToString(localVarOptionals.IdpCertAliasTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddGroupMemberships.IsSet() {
		localVarQueryParams.Add("addGroupMemberships", parameterToString(localVarOptionals.AddGroupMemberships.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddGroupMembershipsTypeHint.IsSet() {
		localVarQueryParams.Add("addGroupMemberships@TypeHint", parameterToString(localVarOptionals.AddGroupMembershipsTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Path.IsSet() {
		localVarQueryParams.Add("path", parameterToString(localVarOptionals.Path.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PathTypeHint.IsSet() {
		localVarQueryParams.Add("path@TypeHint", parameterToString(localVarOptionals.PathTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SynchronizeAttributes.IsSet() {
		localVarQueryParams.Add("synchronizeAttributes", parameterToString(localVarOptionals.SynchronizeAttributes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SynchronizeAttributesTypeHint.IsSet() {
		localVarQueryParams.Add("synchronizeAttributes@TypeHint", parameterToString(localVarOptionals.SynchronizeAttributesTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClockTolerance.IsSet() {
		localVarQueryParams.Add("clockTolerance", parameterToString(localVarOptionals.ClockTolerance.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClockToleranceTypeHint.IsSet() {
		localVarQueryParams.Add("clockTolerance@TypeHint", parameterToString(localVarOptionals.ClockToleranceTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GroupMembershipAttribute.IsSet() {
		localVarQueryParams.Add("groupMembershipAttribute", parameterToString(localVarOptionals.GroupMembershipAttribute.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GroupMembershipAttributeTypeHint.IsSet() {
		localVarQueryParams.Add("groupMembershipAttribute@TypeHint", parameterToString(localVarOptionals.GroupMembershipAttributeTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdpUrl.IsSet() {
		localVarQueryParams.Add("idpUrl", parameterToString(localVarOptionals.IdpUrl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdpUrlTypeHint.IsSet() {
		localVarQueryParams.Add("idpUrl@TypeHint", parameterToString(localVarOptionals.IdpUrlTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogoutUrl.IsSet() {
		localVarQueryParams.Add("logoutUrl", parameterToString(localVarOptionals.LogoutUrl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogoutUrlTypeHint.IsSet() {
		localVarQueryParams.Add("logoutUrl@TypeHint", parameterToString(localVarOptionals.LogoutUrlTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceProviderEntityId.IsSet() {
		localVarQueryParams.Add("serviceProviderEntityId", parameterToString(localVarOptionals.ServiceProviderEntityId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceProviderEntityIdTypeHint.IsSet() {
		localVarQueryParams.Add("serviceProviderEntityId@TypeHint", parameterToString(localVarOptionals.ServiceProviderEntityIdTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssertionConsumerServiceURL.IsSet() {
		localVarQueryParams.Add("assertionConsumerServiceURL", parameterToString(localVarOptionals.AssertionConsumerServiceURL.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssertionConsumerServiceURLTypeHint.IsSet() {
		localVarQueryParams.Add("assertionConsumerServiceURL@TypeHint", parameterToString(localVarOptionals.AssertionConsumerServiceURLTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HandleLogout.IsSet() {
		localVarQueryParams.Add("handleLogout", parameterToString(localVarOptionals.HandleLogout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HandleLogoutTypeHint.IsSet() {
		localVarQueryParams.Add("handleLogout@TypeHint", parameterToString(localVarOptionals.HandleLogoutTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpPrivateKeyAlias.IsSet() {
		localVarQueryParams.Add("spPrivateKeyAlias", parameterToString(localVarOptionals.SpPrivateKeyAlias.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpPrivateKeyAliasTypeHint.IsSet() {
		localVarQueryParams.Add("spPrivateKeyAlias@TypeHint", parameterToString(localVarOptionals.SpPrivateKeyAliasTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UseEncryption.IsSet() {
		localVarQueryParams.Add("useEncryption", parameterToString(localVarOptionals.UseEncryption.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UseEncryptionTypeHint.IsSet() {
		localVarQueryParams.Add("useEncryption@TypeHint", parameterToString(localVarOptionals.UseEncryptionTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIdFormat.IsSet() {
		localVarQueryParams.Add("nameIdFormat", parameterToString(localVarOptionals.NameIdFormat.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIdFormatTypeHint.IsSet() {
		localVarQueryParams.Add("nameIdFormat@TypeHint", parameterToString(localVarOptionals.NameIdFormatTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DigestMethod.IsSet() {
		localVarQueryParams.Add("digestMethod", parameterToString(localVarOptionals.DigestMethod.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DigestMethodTypeHint.IsSet() {
		localVarQueryParams.Add("digestMethod@TypeHint", parameterToString(localVarOptionals.DigestMethodTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SignatureMethod.IsSet() {
		localVarQueryParams.Add("signatureMethod", parameterToString(localVarOptionals.SignatureMethod.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SignatureMethodTypeHint.IsSet() {
		localVarQueryParams.Add("signatureMethod@TypeHint", parameterToString(localVarOptionals.SignatureMethodTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserIntermediatePath.IsSet() {
		localVarQueryParams.Add("userIntermediatePath", parameterToString(localVarOptionals.UserIntermediatePath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserIntermediatePathTypeHint.IsSet() {
		localVarQueryParams.Add("userIntermediatePath@TypeHint", parameterToString(localVarOptionals.UserIntermediatePathTypeHint.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PostConfigApacheFelixJettyBasedHttpServiceOpts - Optional Parameters:
 * @param "OrgApacheFelixHttpsNio" (optional.Bool) - 
 * @param "OrgApacheFelixHttpsNioTypeHint" (optional.String) - 
 * @param "OrgApacheFelixHttpsKeystore" (optional.String) - 
 * @param "OrgApacheFelixHttpsKeystoreTypeHint" (optional.String) - 
 * @param "OrgApacheFelixHttpsKeystorePassword" (optional.String) - 
 * @param "OrgApacheFelixHttpsKeystorePasswordTypeHint" (optional.String) - 
 * @param "OrgApacheFelixHttpsKeystoreKey" (optional.String) - 
 * @param "OrgApacheFelixHttpsKeystoreKeyTypeHint" (optional.String) - 
 * @param "OrgApacheFelixHttpsKeystoreKeyPassword" (optional.String) - 
 * @param "OrgApacheFelixHttpsKeystoreKeyPasswordTypeHint" (optional.String) - 
 * @param "OrgApacheFelixHttpsTruststore" (optional.String) - 
 * @param "OrgApacheFelixHttpsTruststoreTypeHint" (optional.String) - 
 * @param "OrgApacheFelixHttpsTruststorePassword" (optional.String) - 
 * @param "OrgApacheFelixHttpsTruststorePasswordTypeHint" (optional.String) - 
 * @param "OrgApacheFelixHttpsClientcertificate" (optional.String) - 
 * @param "OrgApacheFelixHttpsClientcertificateTypeHint" (optional.String) - 
 * @param "OrgApacheFelixHttpsEnable" (optional.Bool) - 
 * @param "OrgApacheFelixHttpsEnableTypeHint" (optional.String) - 
 * @param "OrgOsgiServiceHttpPortSecure" (optional.String) - 
 * @param "OrgOsgiServiceHttpPortSecureTypeHint" (optional.String) - 
*/

type PostConfigApacheFelixJettyBasedHttpServiceOpts struct {
    OrgApacheFelixHttpsNio optional.Bool
    OrgApacheFelixHttpsNioTypeHint optional.String
    OrgApacheFelixHttpsKeystore optional.String
    OrgApacheFelixHttpsKeystoreTypeHint optional.String
    OrgApacheFelixHttpsKeystorePassword optional.String
    OrgApacheFelixHttpsKeystorePasswordTypeHint optional.String
    OrgApacheFelixHttpsKeystoreKey optional.String
    OrgApacheFelixHttpsKeystoreKeyTypeHint optional.String
    OrgApacheFelixHttpsKeystoreKeyPassword optional.String
    OrgApacheFelixHttpsKeystoreKeyPasswordTypeHint optional.String
    OrgApacheFelixHttpsTruststore optional.String
    OrgApacheFelixHttpsTruststoreTypeHint optional.String
    OrgApacheFelixHttpsTruststorePassword optional.String
    OrgApacheFelixHttpsTruststorePasswordTypeHint optional.String
    OrgApacheFelixHttpsClientcertificate optional.String
    OrgApacheFelixHttpsClientcertificateTypeHint optional.String
    OrgApacheFelixHttpsEnable optional.Bool
    OrgApacheFelixHttpsEnableTypeHint optional.String
    OrgOsgiServiceHttpPortSecure optional.String
    OrgOsgiServiceHttpPortSecureTypeHint optional.String
}

func (a *SlingApiService) PostConfigApacheFelixJettyBasedHttpService(ctx context.Context, localVarOptionals *PostConfigApacheFelixJettyBasedHttpServiceOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/apps/system/config/org.apache.felix.http"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsNio.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.nio", parameterToString(localVarOptionals.OrgApacheFelixHttpsNio.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsNioTypeHint.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.nio@TypeHint", parameterToString(localVarOptionals.OrgApacheFelixHttpsNioTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsKeystore.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.keystore", parameterToString(localVarOptionals.OrgApacheFelixHttpsKeystore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsKeystoreTypeHint.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.keystore@TypeHint", parameterToString(localVarOptionals.OrgApacheFelixHttpsKeystoreTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsKeystorePassword.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.keystore.password", parameterToString(localVarOptionals.OrgApacheFelixHttpsKeystorePassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsKeystorePasswordTypeHint.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.keystore.password@TypeHint", parameterToString(localVarOptionals.OrgApacheFelixHttpsKeystorePasswordTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsKeystoreKey.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.keystore.key", parameterToString(localVarOptionals.OrgApacheFelixHttpsKeystoreKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsKeystoreKeyTypeHint.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.keystore.key@TypeHint", parameterToString(localVarOptionals.OrgApacheFelixHttpsKeystoreKeyTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsKeystoreKeyPassword.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.keystore.key.password", parameterToString(localVarOptionals.OrgApacheFelixHttpsKeystoreKeyPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsKeystoreKeyPasswordTypeHint.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.keystore.key.password@TypeHint", parameterToString(localVarOptionals.OrgApacheFelixHttpsKeystoreKeyPasswordTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsTruststore.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.truststore", parameterToString(localVarOptionals.OrgApacheFelixHttpsTruststore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsTruststoreTypeHint.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.truststore@TypeHint", parameterToString(localVarOptionals.OrgApacheFelixHttpsTruststoreTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsTruststorePassword.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.truststore.password", parameterToString(localVarOptionals.OrgApacheFelixHttpsTruststorePassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsTruststorePasswordTypeHint.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.truststore.password@TypeHint", parameterToString(localVarOptionals.OrgApacheFelixHttpsTruststorePasswordTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsClientcertificate.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.clientcertificate", parameterToString(localVarOptionals.OrgApacheFelixHttpsClientcertificate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsClientcertificateTypeHint.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.clientcertificate@TypeHint", parameterToString(localVarOptionals.OrgApacheFelixHttpsClientcertificateTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsEnable.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.enable", parameterToString(localVarOptionals.OrgApacheFelixHttpsEnable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgApacheFelixHttpsEnableTypeHint.IsSet() {
		localVarQueryParams.Add("org.apache.felix.https.enable@TypeHint", parameterToString(localVarOptionals.OrgApacheFelixHttpsEnableTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgOsgiServiceHttpPortSecure.IsSet() {
		localVarQueryParams.Add("org.osgi.service.http.port.secure", parameterToString(localVarOptionals.OrgOsgiServiceHttpPortSecure.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgOsgiServiceHttpPortSecureTypeHint.IsSet() {
		localVarQueryParams.Add("org.osgi.service.http.port.secure@TypeHint", parameterToString(localVarOptionals.OrgOsgiServiceHttpPortSecureTypeHint.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PostConfigApacheHttpComponentsProxyConfigurationOpts - Optional Parameters:
 * @param "ProxyHost" (optional.String) - 
 * @param "ProxyHostTypeHint" (optional.String) - 
 * @param "ProxyPort" (optional.Int32) - 
 * @param "ProxyPortTypeHint" (optional.String) - 
 * @param "ProxyExceptions" (optional.Interface of []string) - 
 * @param "ProxyExceptionsTypeHint" (optional.String) - 
 * @param "ProxyEnabled" (optional.Bool) - 
 * @param "ProxyEnabledTypeHint" (optional.String) - 
 * @param "ProxyUser" (optional.String) - 
 * @param "ProxyUserTypeHint" (optional.String) - 
 * @param "ProxyPassword" (optional.String) - 
 * @param "ProxyPasswordTypeHint" (optional.String) - 
*/

type PostConfigApacheHttpComponentsProxyConfigurationOpts struct {
    ProxyHost optional.String
    ProxyHostTypeHint optional.String
    ProxyPort optional.Int32
    ProxyPortTypeHint optional.String
    ProxyExceptions optional.Interface
    ProxyExceptionsTypeHint optional.String
    ProxyEnabled optional.Bool
    ProxyEnabledTypeHint optional.String
    ProxyUser optional.String
    ProxyUserTypeHint optional.String
    ProxyPassword optional.String
    ProxyPasswordTypeHint optional.String
}

func (a *SlingApiService) PostConfigApacheHttpComponentsProxyConfiguration(ctx context.Context, localVarOptionals *PostConfigApacheHttpComponentsProxyConfigurationOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/apps/system/config/org.apache.http.proxyconfigurator.config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ProxyHost.IsSet() {
		localVarQueryParams.Add("proxy.host", parameterToString(localVarOptionals.ProxyHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProxyHostTypeHint.IsSet() {
		localVarQueryParams.Add("proxy.host@TypeHint", parameterToString(localVarOptionals.ProxyHostTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProxyPort.IsSet() {
		localVarQueryParams.Add("proxy.port", parameterToString(localVarOptionals.ProxyPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProxyPortTypeHint.IsSet() {
		localVarQueryParams.Add("proxy.port@TypeHint", parameterToString(localVarOptionals.ProxyPortTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProxyExceptions.IsSet() {
		localVarQueryParams.Add("proxy.exceptions", parameterToString(localVarOptionals.ProxyExceptions.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProxyExceptionsTypeHint.IsSet() {
		localVarQueryParams.Add("proxy.exceptions@TypeHint", parameterToString(localVarOptionals.ProxyExceptionsTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProxyEnabled.IsSet() {
		localVarQueryParams.Add("proxy.enabled", parameterToString(localVarOptionals.ProxyEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProxyEnabledTypeHint.IsSet() {
		localVarQueryParams.Add("proxy.enabled@TypeHint", parameterToString(localVarOptionals.ProxyEnabledTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProxyUser.IsSet() {
		localVarQueryParams.Add("proxy.user", parameterToString(localVarOptionals.ProxyUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProxyUserTypeHint.IsSet() {
		localVarQueryParams.Add("proxy.user@TypeHint", parameterToString(localVarOptionals.ProxyUserTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProxyPassword.IsSet() {
		localVarQueryParams.Add("proxy.password", parameterToString(localVarOptionals.ProxyPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProxyPasswordTypeHint.IsSet() {
		localVarQueryParams.Add("proxy.password@TypeHint", parameterToString(localVarOptionals.ProxyPasswordTypeHint.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PostConfigApacheSlingDavExServletOpts - Optional Parameters:
 * @param "Alias" (optional.String) - 
 * @param "AliasTypeHint" (optional.String) - 
 * @param "DavCreateAbsoluteUri" (optional.Bool) - 
 * @param "DavCreateAbsoluteUriTypeHint" (optional.String) - 
*/

type PostConfigApacheSlingDavExServletOpts struct {
    Alias optional.String
    AliasTypeHint optional.String
    DavCreateAbsoluteUri optional.Bool
    DavCreateAbsoluteUriTypeHint optional.String
}

func (a *SlingApiService) PostConfigApacheSlingDavExServlet(ctx context.Context, localVarOptionals *PostConfigApacheSlingDavExServletOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Alias.IsSet() {
		localVarQueryParams.Add("alias", parameterToString(localVarOptionals.Alias.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AliasTypeHint.IsSet() {
		localVarQueryParams.Add("alias@TypeHint", parameterToString(localVarOptionals.AliasTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DavCreateAbsoluteUri.IsSet() {
		localVarQueryParams.Add("dav.create-absolute-uri", parameterToString(localVarOptionals.DavCreateAbsoluteUri.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DavCreateAbsoluteUriTypeHint.IsSet() {
		localVarQueryParams.Add("dav.create-absolute-uri@TypeHint", parameterToString(localVarOptionals.DavCreateAbsoluteUriTypeHint.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PostConfigApacheSlingGetServletOpts - Optional Parameters:
 * @param "JsonMaximumresults" (optional.String) - 
 * @param "JsonMaximumresultsTypeHint" (optional.String) - 
 * @param "EnableHtml" (optional.Bool) - 
 * @param "EnableHtmlTypeHint" (optional.String) - 
 * @param "EnableTxt" (optional.Bool) - 
 * @param "EnableTxtTypeHint" (optional.String) - 
 * @param "EnableXml" (optional.Bool) - 
 * @param "EnableXmlTypeHint" (optional.String) - 
*/

type PostConfigApacheSlingGetServletOpts struct {
    JsonMaximumresults optional.String
    JsonMaximumresultsTypeHint optional.String
    EnableHtml optional.Bool
    EnableHtmlTypeHint optional.String
    EnableTxt optional.Bool
    EnableTxtTypeHint optional.String
    EnableXml optional.Bool
    EnableXmlTypeHint optional.String
}

func (a *SlingApiService) PostConfigApacheSlingGetServlet(ctx context.Context, localVarOptionals *PostConfigApacheSlingGetServletOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.JsonMaximumresults.IsSet() {
		localVarQueryParams.Add("json.maximumresults", parameterToString(localVarOptionals.JsonMaximumresults.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JsonMaximumresultsTypeHint.IsSet() {
		localVarQueryParams.Add("json.maximumresults@TypeHint", parameterToString(localVarOptionals.JsonMaximumresultsTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableHtml.IsSet() {
		localVarQueryParams.Add("enable.html", parameterToString(localVarOptionals.EnableHtml.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableHtmlTypeHint.IsSet() {
		localVarQueryParams.Add("enable.html@TypeHint", parameterToString(localVarOptionals.EnableHtmlTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableTxt.IsSet() {
		localVarQueryParams.Add("enable.txt", parameterToString(localVarOptionals.EnableTxt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableTxtTypeHint.IsSet() {
		localVarQueryParams.Add("enable.txt@TypeHint", parameterToString(localVarOptionals.EnableTxtTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableXml.IsSet() {
		localVarQueryParams.Add("enable.xml", parameterToString(localVarOptionals.EnableXml.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableXmlTypeHint.IsSet() {
		localVarQueryParams.Add("enable.xml@TypeHint", parameterToString(localVarOptionals.EnableXmlTypeHint.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PostConfigApacheSlingReferrerFilterOpts - Optional Parameters:
 * @param "AllowEmpty" (optional.Bool) - 
 * @param "AllowEmptyTypeHint" (optional.String) - 
 * @param "AllowHosts" (optional.String) - 
 * @param "AllowHostsTypeHint" (optional.String) - 
 * @param "AllowHostsRegexp" (optional.String) - 
 * @param "AllowHostsRegexpTypeHint" (optional.String) - 
 * @param "FilterMethods" (optional.String) - 
 * @param "FilterMethodsTypeHint" (optional.String) - 
*/

type PostConfigApacheSlingReferrerFilterOpts struct {
    AllowEmpty optional.Bool
    AllowEmptyTypeHint optional.String
    AllowHosts optional.String
    AllowHostsTypeHint optional.String
    AllowHostsRegexp optional.String
    AllowHostsRegexpTypeHint optional.String
    FilterMethods optional.String
    FilterMethodsTypeHint optional.String
}

func (a *SlingApiService) PostConfigApacheSlingReferrerFilter(ctx context.Context, localVarOptionals *PostConfigApacheSlingReferrerFilterOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/apps/system/config/org.apache.sling.security.impl.ReferrerFilter"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AllowEmpty.IsSet() {
		localVarQueryParams.Add("allow.empty", parameterToString(localVarOptionals.AllowEmpty.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AllowEmptyTypeHint.IsSet() {
		localVarQueryParams.Add("allow.empty@TypeHint", parameterToString(localVarOptionals.AllowEmptyTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AllowHosts.IsSet() {
		localVarQueryParams.Add("allow.hosts", parameterToString(localVarOptionals.AllowHosts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AllowHostsTypeHint.IsSet() {
		localVarQueryParams.Add("allow.hosts@TypeHint", parameterToString(localVarOptionals.AllowHostsTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AllowHostsRegexp.IsSet() {
		localVarQueryParams.Add("allow.hosts.regexp", parameterToString(localVarOptionals.AllowHostsRegexp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AllowHostsRegexpTypeHint.IsSet() {
		localVarQueryParams.Add("allow.hosts.regexp@TypeHint", parameterToString(localVarOptionals.AllowHostsRegexpTypeHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilterMethods.IsSet() {
		localVarQueryParams.Add("filter.methods", parameterToString(localVarOptionals.FilterMethods.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilterMethodsTypeHint.IsSet() {
		localVarQueryParams.Add("filter.methods@TypeHint", parameterToString(localVarOptionals.FilterMethodsTypeHint.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param path
 * @param name
 * @param optional nil or *PostNodeOpts - Optional Parameters:
 * @param "Operation" (optional.String) - 
 * @param "DeleteAuthorizable" (optional.String) - 
 * @param "File" (optional.Interface of *os.File) - 
*/

type PostNodeOpts struct {
    Operation optional.String
    DeleteAuthorizable optional.String
    File optional.Interface
}

func (a *SlingApiService) PostNode(ctx context.Context, path string, name string, localVarOptionals *PostNodeOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/{path}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", fmt.Sprintf("%v", path), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Operation.IsSet() {
		localVarQueryParams.Add(":operation", parameterToString(localVarOptionals.Operation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeleteAuthorizable.IsSet() {
		localVarQueryParams.Add("deleteAuthorizable", parameterToString(localVarOptionals.DeleteAuthorizable.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormFileName = "file"
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.File.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.File.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("file should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param path
 * @param name
 * @param optional nil or *PostNodeRwOpts - Optional Parameters:
 * @param "AddMembers" (optional.String) - 
*/

type PostNodeRwOpts struct {
    AddMembers optional.String
}

func (a *SlingApiService) PostNodeRw(ctx context.Context, path string, name string, localVarOptionals *PostNodeRwOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/{path}/{name}.rw.html"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", fmt.Sprintf("%v", path), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AddMembers.IsSet() {
		localVarQueryParams.Add("addMembers", parameterToString(localVarOptionals.AddMembers.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param path
 * @param jcrprimaryType
 * @param name
*/
func (a *SlingApiService) PostPath(ctx context.Context, path string, jcrprimaryType string, name string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/{path}/"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", fmt.Sprintf("%v", path), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("jcr:primaryType", parameterToString(jcrprimaryType, ""))
	localVarQueryParams.Add(":name", parameterToString(name, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param path
 * @param pLimit
 * @param var1Property
 * @param var1PropertyValue
@return string
*/
func (a *SlingApiService) PostQuery(ctx context.Context, path string, pLimit float32, var1Property string, var1PropertyValue string) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/bin/querybuilder.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("path", parameterToString(path, ""))
	localVarQueryParams.Add("p.limit", parameterToString(pLimit, ""))
	localVarQueryParams.Add("1_property", parameterToString(var1Property, ""))
	localVarQueryParams.Add("1_property.value", parameterToString(var1PropertyValue, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param ignoredeactivated
 * @param onlymodified
 * @param path
*/
func (a *SlingApiService) PostTreeActivation(ctx context.Context, ignoredeactivated bool, onlymodified bool, path string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/etc/replication/treeactivation.html"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("ignoredeactivated", parameterToString(ignoredeactivated, ""))
	localVarQueryParams.Add("onlymodified", parameterToString(onlymodified, ""))
	localVarQueryParams.Add("path", parameterToString(path, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PostTruststoreOpts - Optional Parameters:
 * @param "Operation" (optional.String) - 
 * @param "NewPassword" (optional.String) - 
 * @param "RePassword" (optional.String) - 
 * @param "KeyStoreType" (optional.String) - 
 * @param "RemoveAlias" (optional.String) - 
 * @param "Certificate" (optional.Interface of *os.File) - 
@return string
*/

type PostTruststoreOpts struct {
    Operation optional.String
    NewPassword optional.String
    RePassword optional.String
    KeyStoreType optional.String
    RemoveAlias optional.String
    Certificate optional.Interface
}

func (a *SlingApiService) PostTruststore(ctx context.Context, localVarOptionals *PostTruststoreOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/libs/granite/security/post/truststore"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Operation.IsSet() {
		localVarQueryParams.Add(":operation", parameterToString(localVarOptionals.Operation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewPassword.IsSet() {
		localVarQueryParams.Add("newPassword", parameterToString(localVarOptionals.NewPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RePassword.IsSet() {
		localVarQueryParams.Add("rePassword", parameterToString(localVarOptionals.RePassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.KeyStoreType.IsSet() {
		localVarQueryParams.Add("keyStoreType", parameterToString(localVarOptionals.KeyStoreType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoveAlias.IsSet() {
		localVarQueryParams.Add("removeAlias", parameterToString(localVarOptionals.RemoveAlias.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormFileName = "certificate"
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.Certificate.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.Certificate.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("certificate should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SlingApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PostTruststorePKCS12Opts - Optional Parameters:
 * @param "TruststoreP12" (optional.Interface of *os.File) - 
@return string
*/

type PostTruststorePKCS12Opts struct {
    TruststoreP12 optional.Interface
}

func (a *SlingApiService) PostTruststorePKCS12(ctx context.Context, localVarOptionals *PostTruststorePKCS12Opts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/etc/truststore"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormFileName = "truststore.p12"
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.TruststoreP12.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.TruststoreP12.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("truststoreP12 should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
