# coding: utf-8

"""
    Adobe Experience Manager (AEM) API

    Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API  # noqa: E501

    OpenAPI spec version: 3.2.0-pre.0
    Contact: opensource@shinesolutions.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swaggeraem.api_client import ApiClient


class SlingApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_agent(self, runmode, name, **kwargs):  # noqa: E501
        """delete_agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_agent(runmode, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runmode: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_agent_with_http_info(runmode, name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_agent_with_http_info(runmode, name, **kwargs)  # noqa: E501
            return data

    def delete_agent_with_http_info(self, runmode, name, **kwargs):  # noqa: E501
        """delete_agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_agent_with_http_info(runmode, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runmode: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['runmode', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_agent" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in local_var_params or
                local_var_params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `delete_agent`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in local_var_params or
                local_var_params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runmode' in local_var_params:
            path_params['runmode'] = local_var_params['runmode']  # noqa: E501
        if 'name' in local_var_params:
            path_params['name'] = local_var_params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/replication/agents.{runmode}/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_node(self, path, name, **kwargs):  # noqa: E501
        """delete_node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_node(path, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_node_with_http_info(path, name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_node_with_http_info(path, name, **kwargs)  # noqa: E501
            return data

    def delete_node_with_http_info(self, path, name, **kwargs):  # noqa: E501
        """delete_node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_node_with_http_info(path, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['path', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_node" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in local_var_params or
                local_var_params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `delete_node`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in local_var_params or
                local_var_params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501
        if 'name' in local_var_params:
            path_params['name'] = local_var_params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/{path}/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_agent(self, runmode, name, **kwargs):  # noqa: E501
        """get_agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_agent(runmode, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runmode: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_agent_with_http_info(runmode, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_agent_with_http_info(runmode, name, **kwargs)  # noqa: E501
            return data

    def get_agent_with_http_info(self, runmode, name, **kwargs):  # noqa: E501
        """get_agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_agent_with_http_info(runmode, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runmode: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['runmode', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agent" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in local_var_params or
                local_var_params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `get_agent`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in local_var_params or
                local_var_params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runmode' in local_var_params:
            path_params['runmode'] = local_var_params['runmode']  # noqa: E501
        if 'name' in local_var_params:
            path_params['name'] = local_var_params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/replication/agents.{runmode}/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_agents(self, runmode, **kwargs):  # noqa: E501
        """get_agents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_agents(runmode, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runmode: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_agents_with_http_info(runmode, **kwargs)  # noqa: E501
        else:
            (data) = self.get_agents_with_http_info(runmode, **kwargs)  # noqa: E501
            return data

    def get_agents_with_http_info(self, runmode, **kwargs):  # noqa: E501
        """get_agents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_agents_with_http_info(runmode, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runmode: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['runmode']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agents" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in local_var_params or
                local_var_params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `get_agents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runmode' in local_var_params:
            path_params['runmode'] = local_var_params['runmode']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/replication/agents.{runmode}.-1.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_authorizable_keystore(self, intermediate_path, authorizable_id, **kwargs):  # noqa: E501
        """get_authorizable_keystore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_authorizable_keystore(intermediate_path, authorizable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str intermediate_path: (required)
        :param str authorizable_id: (required)
        :return: KeystoreInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_authorizable_keystore_with_http_info(intermediate_path, authorizable_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_authorizable_keystore_with_http_info(intermediate_path, authorizable_id, **kwargs)  # noqa: E501
            return data

    def get_authorizable_keystore_with_http_info(self, intermediate_path, authorizable_id, **kwargs):  # noqa: E501
        """get_authorizable_keystore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_authorizable_keystore_with_http_info(intermediate_path, authorizable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str intermediate_path: (required)
        :param str authorizable_id: (required)
        :return: KeystoreInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['intermediate_path', 'authorizable_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_authorizable_keystore" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'intermediate_path' is set
        if ('intermediate_path' not in local_var_params or
                local_var_params['intermediate_path'] is None):
            raise ValueError("Missing the required parameter `intermediate_path` when calling `get_authorizable_keystore`")  # noqa: E501
        # verify the required parameter 'authorizable_id' is set
        if ('authorizable_id' not in local_var_params or
                local_var_params['authorizable_id'] is None):
            raise ValueError("Missing the required parameter `authorizable_id` when calling `get_authorizable_keystore`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'intermediate_path' in local_var_params:
            path_params['intermediatePath'] = local_var_params['intermediate_path']  # noqa: E501
        if 'authorizable_id' in local_var_params:
            path_params['authorizableId'] = local_var_params['authorizable_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/{intermediatePath}/{authorizableId}.ks.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='KeystoreInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_keystore(self, intermediate_path, authorizable_id, **kwargs):  # noqa: E501
        """get_keystore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_keystore(intermediate_path, authorizable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str intermediate_path: (required)
        :param str authorizable_id: (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_keystore_with_http_info(intermediate_path, authorizable_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_keystore_with_http_info(intermediate_path, authorizable_id, **kwargs)  # noqa: E501
            return data

    def get_keystore_with_http_info(self, intermediate_path, authorizable_id, **kwargs):  # noqa: E501
        """get_keystore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_keystore_with_http_info(intermediate_path, authorizable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str intermediate_path: (required)
        :param str authorizable_id: (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['intermediate_path', 'authorizable_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_keystore" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'intermediate_path' is set
        if ('intermediate_path' not in local_var_params or
                local_var_params['intermediate_path'] is None):
            raise ValueError("Missing the required parameter `intermediate_path` when calling `get_keystore`")  # noqa: E501
        # verify the required parameter 'authorizable_id' is set
        if ('authorizable_id' not in local_var_params or
                local_var_params['authorizable_id'] is None):
            raise ValueError("Missing the required parameter `authorizable_id` when calling `get_keystore`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'intermediate_path' in local_var_params:
            path_params['intermediatePath'] = local_var_params['intermediate_path']  # noqa: E501
        if 'authorizable_id' in local_var_params:
            path_params['authorizableId'] = local_var_params['authorizable_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/{intermediatePath}/{authorizableId}/keystore/store.p12', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_node(self, path, name, **kwargs):  # noqa: E501
        """get_node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node(path, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_node_with_http_info(path, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_node_with_http_info(path, name, **kwargs)  # noqa: E501
            return data

    def get_node_with_http_info(self, path, name, **kwargs):  # noqa: E501
        """get_node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_with_http_info(path, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['path', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in local_var_params or
                local_var_params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_node`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in local_var_params or
                local_var_params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501
        if 'name' in local_var_params:
            path_params['name'] = local_var_params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/{path}/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_package(self, group, name, version, **kwargs):  # noqa: E501
        """get_package  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_package(group, name, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group: (required)
        :param str name: (required)
        :param str version: (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_package_with_http_info(group, name, version, **kwargs)  # noqa: E501
        else:
            (data) = self.get_package_with_http_info(group, name, version, **kwargs)  # noqa: E501
            return data

    def get_package_with_http_info(self, group, name, version, **kwargs):  # noqa: E501
        """get_package  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_package_with_http_info(group, name, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group: (required)
        :param str name: (required)
        :param str version: (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['group', 'name', 'version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_package" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'group' is set
        if ('group' not in local_var_params or
                local_var_params['group'] is None):
            raise ValueError("Missing the required parameter `group` when calling `get_package`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in local_var_params or
                local_var_params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_package`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in local_var_params or
                local_var_params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get_package`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group' in local_var_params:
            path_params['group'] = local_var_params['group']  # noqa: E501
        if 'name' in local_var_params:
            path_params['name'] = local_var_params['name']  # noqa: E501
        if 'version' in local_var_params:
            path_params['version'] = local_var_params['version']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/packages/{group}/{name}-{version}.zip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_package_filter(self, group, name, version, **kwargs):  # noqa: E501
        """get_package_filter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_package_filter(group, name, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group: (required)
        :param str name: (required)
        :param str version: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_package_filter_with_http_info(group, name, version, **kwargs)  # noqa: E501
        else:
            (data) = self.get_package_filter_with_http_info(group, name, version, **kwargs)  # noqa: E501
            return data

    def get_package_filter_with_http_info(self, group, name, version, **kwargs):  # noqa: E501
        """get_package_filter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_package_filter_with_http_info(group, name, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group: (required)
        :param str name: (required)
        :param str version: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['group', 'name', 'version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_package_filter" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'group' is set
        if ('group' not in local_var_params or
                local_var_params['group'] is None):
            raise ValueError("Missing the required parameter `group` when calling `get_package_filter`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in local_var_params or
                local_var_params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_package_filter`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in local_var_params or
                local_var_params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get_package_filter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group' in local_var_params:
            path_params['group'] = local_var_params['group']  # noqa: E501
        if 'name' in local_var_params:
            path_params['name'] = local_var_params['name']  # noqa: E501
        if 'version' in local_var_params:
            path_params['version'] = local_var_params['version']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_query(self, path, p_limit, _1_property, _1_property_value, **kwargs):  # noqa: E501
        """get_query  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_query(path, p_limit, _1_property, _1_property_value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param float p_limit: (required)
        :param str _1_property: (required)
        :param str _1_property_value: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_query_with_http_info(path, p_limit, _1_property, _1_property_value, **kwargs)  # noqa: E501
        else:
            (data) = self.get_query_with_http_info(path, p_limit, _1_property, _1_property_value, **kwargs)  # noqa: E501
            return data

    def get_query_with_http_info(self, path, p_limit, _1_property, _1_property_value, **kwargs):  # noqa: E501
        """get_query  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_query_with_http_info(path, p_limit, _1_property, _1_property_value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param float p_limit: (required)
        :param str _1_property: (required)
        :param str _1_property_value: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['path', 'p_limit', '_1_property', '_1_property_value']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_query" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in local_var_params or
                local_var_params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_query`")  # noqa: E501
        # verify the required parameter 'p_limit' is set
        if ('p_limit' not in local_var_params or
                local_var_params['p_limit'] is None):
            raise ValueError("Missing the required parameter `p_limit` when calling `get_query`")  # noqa: E501
        # verify the required parameter '_1_property' is set
        if ('_1_property' not in local_var_params or
                local_var_params['_1_property'] is None):
            raise ValueError("Missing the required parameter `_1_property` when calling `get_query`")  # noqa: E501
        # verify the required parameter '_1_property_value' is set
        if ('_1_property_value' not in local_var_params or
                local_var_params['_1_property_value'] is None):
            raise ValueError("Missing the required parameter `_1_property_value` when calling `get_query`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in local_var_params:
            query_params.append(('path', local_var_params['path']))  # noqa: E501
        if 'p_limit' in local_var_params:
            query_params.append(('p.limit', local_var_params['p_limit']))  # noqa: E501
        if '_1_property' in local_var_params:
            query_params.append(('1_property', local_var_params['_1_property']))  # noqa: E501
        if '_1_property_value' in local_var_params:
            query_params.append(('1_property.value', local_var_params['_1_property_value']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bin/querybuilder.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_truststore(self, **kwargs):  # noqa: E501
        """get_truststore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_truststore(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_truststore_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_truststore_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_truststore_with_http_info(self, **kwargs):  # noqa: E501
        """get_truststore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_truststore_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_truststore" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/truststore/truststore.p12', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_truststore_info(self, **kwargs):  # noqa: E501
        """get_truststore_info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_truststore_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TruststoreInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_truststore_info_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_truststore_info_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_truststore_info_with_http_info(self, **kwargs):  # noqa: E501
        """get_truststore_info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_truststore_info_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TruststoreInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_truststore_info" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/libs/granite/security/truststore.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TruststoreInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_agent(self, runmode, name, **kwargs):  # noqa: E501
        """post_agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_agent(runmode, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runmode: (required)
        :param str name: (required)
        :param bool jcrcontentcqdistribute:
        :param str jcrcontentcqdistribute_type_hint:
        :param str jcrcontentcqname:
        :param str jcrcontentcqtemplate:
        :param bool jcrcontentenabled:
        :param str jcrcontentjcrdescription:
        :param str jcrcontentjcrlast_modified:
        :param str jcrcontentjcrlast_modified_by:
        :param str jcrcontentjcrmixin_types:
        :param str jcrcontentjcrtitle:
        :param str jcrcontentlog_level:
        :param bool jcrcontentno_status_update:
        :param bool jcrcontentno_versioning:
        :param float jcrcontentprotocol_connect_timeout:
        :param bool jcrcontentprotocol_http_connection_closed:
        :param str jcrcontentprotocol_http_expired:
        :param list[str] jcrcontentprotocol_http_headers:
        :param str jcrcontentprotocol_http_headers_type_hint:
        :param str jcrcontentprotocol_http_method:
        :param bool jcrcontentprotocol_https_relaxed:
        :param str jcrcontentprotocol_interface:
        :param float jcrcontentprotocol_socket_timeout:
        :param str jcrcontentprotocol_version:
        :param str jcrcontentproxy_ntlm_domain:
        :param str jcrcontentproxy_ntlm_host:
        :param str jcrcontentproxy_host:
        :param str jcrcontentproxy_password:
        :param float jcrcontentproxy_port:
        :param str jcrcontentproxy_user:
        :param float jcrcontentqueue_batch_max_size:
        :param str jcrcontentqueue_batch_mode:
        :param float jcrcontentqueue_batch_wait_time:
        :param str jcrcontentretry_delay:
        :param bool jcrcontentreverse_replication:
        :param str jcrcontentserialization_type:
        :param str jcrcontentslingresource_type:
        :param str jcrcontentssl:
        :param str jcrcontenttransport_ntlm_domain:
        :param str jcrcontenttransport_ntlm_host:
        :param str jcrcontenttransport_password:
        :param str jcrcontenttransport_uri:
        :param str jcrcontenttransport_user:
        :param bool jcrcontenttrigger_distribute:
        :param bool jcrcontenttrigger_modified:
        :param bool jcrcontenttrigger_on_off_time:
        :param bool jcrcontenttrigger_receive:
        :param bool jcrcontenttrigger_specific:
        :param str jcrcontentuser_id:
        :param str jcrprimary_type:
        :param str operation:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_agent_with_http_info(runmode, name, **kwargs)  # noqa: E501
        else:
            (data) = self.post_agent_with_http_info(runmode, name, **kwargs)  # noqa: E501
            return data

    def post_agent_with_http_info(self, runmode, name, **kwargs):  # noqa: E501
        """post_agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_agent_with_http_info(runmode, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runmode: (required)
        :param str name: (required)
        :param bool jcrcontentcqdistribute:
        :param str jcrcontentcqdistribute_type_hint:
        :param str jcrcontentcqname:
        :param str jcrcontentcqtemplate:
        :param bool jcrcontentenabled:
        :param str jcrcontentjcrdescription:
        :param str jcrcontentjcrlast_modified:
        :param str jcrcontentjcrlast_modified_by:
        :param str jcrcontentjcrmixin_types:
        :param str jcrcontentjcrtitle:
        :param str jcrcontentlog_level:
        :param bool jcrcontentno_status_update:
        :param bool jcrcontentno_versioning:
        :param float jcrcontentprotocol_connect_timeout:
        :param bool jcrcontentprotocol_http_connection_closed:
        :param str jcrcontentprotocol_http_expired:
        :param list[str] jcrcontentprotocol_http_headers:
        :param str jcrcontentprotocol_http_headers_type_hint:
        :param str jcrcontentprotocol_http_method:
        :param bool jcrcontentprotocol_https_relaxed:
        :param str jcrcontentprotocol_interface:
        :param float jcrcontentprotocol_socket_timeout:
        :param str jcrcontentprotocol_version:
        :param str jcrcontentproxy_ntlm_domain:
        :param str jcrcontentproxy_ntlm_host:
        :param str jcrcontentproxy_host:
        :param str jcrcontentproxy_password:
        :param float jcrcontentproxy_port:
        :param str jcrcontentproxy_user:
        :param float jcrcontentqueue_batch_max_size:
        :param str jcrcontentqueue_batch_mode:
        :param float jcrcontentqueue_batch_wait_time:
        :param str jcrcontentretry_delay:
        :param bool jcrcontentreverse_replication:
        :param str jcrcontentserialization_type:
        :param str jcrcontentslingresource_type:
        :param str jcrcontentssl:
        :param str jcrcontenttransport_ntlm_domain:
        :param str jcrcontenttransport_ntlm_host:
        :param str jcrcontenttransport_password:
        :param str jcrcontenttransport_uri:
        :param str jcrcontenttransport_user:
        :param bool jcrcontenttrigger_distribute:
        :param bool jcrcontenttrigger_modified:
        :param bool jcrcontenttrigger_on_off_time:
        :param bool jcrcontenttrigger_receive:
        :param bool jcrcontenttrigger_specific:
        :param str jcrcontentuser_id:
        :param str jcrprimary_type:
        :param str operation:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['runmode', 'name', 'jcrcontentcqdistribute', 'jcrcontentcqdistribute_type_hint', 'jcrcontentcqname', 'jcrcontentcqtemplate', 'jcrcontentenabled', 'jcrcontentjcrdescription', 'jcrcontentjcrlast_modified', 'jcrcontentjcrlast_modified_by', 'jcrcontentjcrmixin_types', 'jcrcontentjcrtitle', 'jcrcontentlog_level', 'jcrcontentno_status_update', 'jcrcontentno_versioning', 'jcrcontentprotocol_connect_timeout', 'jcrcontentprotocol_http_connection_closed', 'jcrcontentprotocol_http_expired', 'jcrcontentprotocol_http_headers', 'jcrcontentprotocol_http_headers_type_hint', 'jcrcontentprotocol_http_method', 'jcrcontentprotocol_https_relaxed', 'jcrcontentprotocol_interface', 'jcrcontentprotocol_socket_timeout', 'jcrcontentprotocol_version', 'jcrcontentproxy_ntlm_domain', 'jcrcontentproxy_ntlm_host', 'jcrcontentproxy_host', 'jcrcontentproxy_password', 'jcrcontentproxy_port', 'jcrcontentproxy_user', 'jcrcontentqueue_batch_max_size', 'jcrcontentqueue_batch_mode', 'jcrcontentqueue_batch_wait_time', 'jcrcontentretry_delay', 'jcrcontentreverse_replication', 'jcrcontentserialization_type', 'jcrcontentslingresource_type', 'jcrcontentssl', 'jcrcontenttransport_ntlm_domain', 'jcrcontenttransport_ntlm_host', 'jcrcontenttransport_password', 'jcrcontenttransport_uri', 'jcrcontenttransport_user', 'jcrcontenttrigger_distribute', 'jcrcontenttrigger_modified', 'jcrcontenttrigger_on_off_time', 'jcrcontenttrigger_receive', 'jcrcontenttrigger_specific', 'jcrcontentuser_id', 'jcrprimary_type', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_agent" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in local_var_params or
                local_var_params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `post_agent`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in local_var_params or
                local_var_params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runmode' in local_var_params:
            path_params['runmode'] = local_var_params['runmode']  # noqa: E501
        if 'name' in local_var_params:
            path_params['name'] = local_var_params['name']  # noqa: E501

        query_params = []
        if 'jcrcontentcqdistribute' in local_var_params:
            query_params.append(('jcr:content/cq:distribute', local_var_params['jcrcontentcqdistribute']))  # noqa: E501
        if 'jcrcontentcqdistribute_type_hint' in local_var_params:
            query_params.append(('jcr:content/cq:distribute@TypeHint', local_var_params['jcrcontentcqdistribute_type_hint']))  # noqa: E501
        if 'jcrcontentcqname' in local_var_params:
            query_params.append(('jcr:content/cq:name', local_var_params['jcrcontentcqname']))  # noqa: E501
        if 'jcrcontentcqtemplate' in local_var_params:
            query_params.append(('jcr:content/cq:template', local_var_params['jcrcontentcqtemplate']))  # noqa: E501
        if 'jcrcontentenabled' in local_var_params:
            query_params.append(('jcr:content/enabled', local_var_params['jcrcontentenabled']))  # noqa: E501
        if 'jcrcontentjcrdescription' in local_var_params:
            query_params.append(('jcr:content/jcr:description', local_var_params['jcrcontentjcrdescription']))  # noqa: E501
        if 'jcrcontentjcrlast_modified' in local_var_params:
            query_params.append(('jcr:content/jcr:lastModified', local_var_params['jcrcontentjcrlast_modified']))  # noqa: E501
        if 'jcrcontentjcrlast_modified_by' in local_var_params:
            query_params.append(('jcr:content/jcr:lastModifiedBy', local_var_params['jcrcontentjcrlast_modified_by']))  # noqa: E501
        if 'jcrcontentjcrmixin_types' in local_var_params:
            query_params.append(('jcr:content/jcr:mixinTypes', local_var_params['jcrcontentjcrmixin_types']))  # noqa: E501
        if 'jcrcontentjcrtitle' in local_var_params:
            query_params.append(('jcr:content/jcr:title', local_var_params['jcrcontentjcrtitle']))  # noqa: E501
        if 'jcrcontentlog_level' in local_var_params:
            query_params.append(('jcr:content/logLevel', local_var_params['jcrcontentlog_level']))  # noqa: E501
        if 'jcrcontentno_status_update' in local_var_params:
            query_params.append(('jcr:content/noStatusUpdate', local_var_params['jcrcontentno_status_update']))  # noqa: E501
        if 'jcrcontentno_versioning' in local_var_params:
            query_params.append(('jcr:content/noVersioning', local_var_params['jcrcontentno_versioning']))  # noqa: E501
        if 'jcrcontentprotocol_connect_timeout' in local_var_params:
            query_params.append(('jcr:content/protocolConnectTimeout', local_var_params['jcrcontentprotocol_connect_timeout']))  # noqa: E501
        if 'jcrcontentprotocol_http_connection_closed' in local_var_params:
            query_params.append(('jcr:content/protocolHTTPConnectionClosed', local_var_params['jcrcontentprotocol_http_connection_closed']))  # noqa: E501
        if 'jcrcontentprotocol_http_expired' in local_var_params:
            query_params.append(('jcr:content/protocolHTTPExpired', local_var_params['jcrcontentprotocol_http_expired']))  # noqa: E501
        if 'jcrcontentprotocol_http_headers' in local_var_params:
            query_params.append(('jcr:content/protocolHTTPHeaders', local_var_params['jcrcontentprotocol_http_headers']))  # noqa: E501
            collection_formats['jcr:content/protocolHTTPHeaders'] = 'multi'  # noqa: E501
        if 'jcrcontentprotocol_http_headers_type_hint' in local_var_params:
            query_params.append(('jcr:content/protocolHTTPHeaders@TypeHint', local_var_params['jcrcontentprotocol_http_headers_type_hint']))  # noqa: E501
        if 'jcrcontentprotocol_http_method' in local_var_params:
            query_params.append(('jcr:content/protocolHTTPMethod', local_var_params['jcrcontentprotocol_http_method']))  # noqa: E501
        if 'jcrcontentprotocol_https_relaxed' in local_var_params:
            query_params.append(('jcr:content/protocolHTTPSRelaxed', local_var_params['jcrcontentprotocol_https_relaxed']))  # noqa: E501
        if 'jcrcontentprotocol_interface' in local_var_params:
            query_params.append(('jcr:content/protocolInterface', local_var_params['jcrcontentprotocol_interface']))  # noqa: E501
        if 'jcrcontentprotocol_socket_timeout' in local_var_params:
            query_params.append(('jcr:content/protocolSocketTimeout', local_var_params['jcrcontentprotocol_socket_timeout']))  # noqa: E501
        if 'jcrcontentprotocol_version' in local_var_params:
            query_params.append(('jcr:content/protocolVersion', local_var_params['jcrcontentprotocol_version']))  # noqa: E501
        if 'jcrcontentproxy_ntlm_domain' in local_var_params:
            query_params.append(('jcr:content/proxyNTLMDomain', local_var_params['jcrcontentproxy_ntlm_domain']))  # noqa: E501
        if 'jcrcontentproxy_ntlm_host' in local_var_params:
            query_params.append(('jcr:content/proxyNTLMHost', local_var_params['jcrcontentproxy_ntlm_host']))  # noqa: E501
        if 'jcrcontentproxy_host' in local_var_params:
            query_params.append(('jcr:content/proxyHost', local_var_params['jcrcontentproxy_host']))  # noqa: E501
        if 'jcrcontentproxy_password' in local_var_params:
            query_params.append(('jcr:content/proxyPassword', local_var_params['jcrcontentproxy_password']))  # noqa: E501
        if 'jcrcontentproxy_port' in local_var_params:
            query_params.append(('jcr:content/proxyPort', local_var_params['jcrcontentproxy_port']))  # noqa: E501
        if 'jcrcontentproxy_user' in local_var_params:
            query_params.append(('jcr:content/proxyUser', local_var_params['jcrcontentproxy_user']))  # noqa: E501
        if 'jcrcontentqueue_batch_max_size' in local_var_params:
            query_params.append(('jcr:content/queueBatchMaxSize', local_var_params['jcrcontentqueue_batch_max_size']))  # noqa: E501
        if 'jcrcontentqueue_batch_mode' in local_var_params:
            query_params.append(('jcr:content/queueBatchMode', local_var_params['jcrcontentqueue_batch_mode']))  # noqa: E501
        if 'jcrcontentqueue_batch_wait_time' in local_var_params:
            query_params.append(('jcr:content/queueBatchWaitTime', local_var_params['jcrcontentqueue_batch_wait_time']))  # noqa: E501
        if 'jcrcontentretry_delay' in local_var_params:
            query_params.append(('jcr:content/retryDelay', local_var_params['jcrcontentretry_delay']))  # noqa: E501
        if 'jcrcontentreverse_replication' in local_var_params:
            query_params.append(('jcr:content/reverseReplication', local_var_params['jcrcontentreverse_replication']))  # noqa: E501
        if 'jcrcontentserialization_type' in local_var_params:
            query_params.append(('jcr:content/serializationType', local_var_params['jcrcontentserialization_type']))  # noqa: E501
        if 'jcrcontentslingresource_type' in local_var_params:
            query_params.append(('jcr:content/sling:resourceType', local_var_params['jcrcontentslingresource_type']))  # noqa: E501
        if 'jcrcontentssl' in local_var_params:
            query_params.append(('jcr:content/ssl', local_var_params['jcrcontentssl']))  # noqa: E501
        if 'jcrcontenttransport_ntlm_domain' in local_var_params:
            query_params.append(('jcr:content/transportNTLMDomain', local_var_params['jcrcontenttransport_ntlm_domain']))  # noqa: E501
        if 'jcrcontenttransport_ntlm_host' in local_var_params:
            query_params.append(('jcr:content/transportNTLMHost', local_var_params['jcrcontenttransport_ntlm_host']))  # noqa: E501
        if 'jcrcontenttransport_password' in local_var_params:
            query_params.append(('jcr:content/transportPassword', local_var_params['jcrcontenttransport_password']))  # noqa: E501
        if 'jcrcontenttransport_uri' in local_var_params:
            query_params.append(('jcr:content/transportUri', local_var_params['jcrcontenttransport_uri']))  # noqa: E501
        if 'jcrcontenttransport_user' in local_var_params:
            query_params.append(('jcr:content/transportUser', local_var_params['jcrcontenttransport_user']))  # noqa: E501
        if 'jcrcontenttrigger_distribute' in local_var_params:
            query_params.append(('jcr:content/triggerDistribute', local_var_params['jcrcontenttrigger_distribute']))  # noqa: E501
        if 'jcrcontenttrigger_modified' in local_var_params:
            query_params.append(('jcr:content/triggerModified', local_var_params['jcrcontenttrigger_modified']))  # noqa: E501
        if 'jcrcontenttrigger_on_off_time' in local_var_params:
            query_params.append(('jcr:content/triggerOnOffTime', local_var_params['jcrcontenttrigger_on_off_time']))  # noqa: E501
        if 'jcrcontenttrigger_receive' in local_var_params:
            query_params.append(('jcr:content/triggerReceive', local_var_params['jcrcontenttrigger_receive']))  # noqa: E501
        if 'jcrcontenttrigger_specific' in local_var_params:
            query_params.append(('jcr:content/triggerSpecific', local_var_params['jcrcontenttrigger_specific']))  # noqa: E501
        if 'jcrcontentuser_id' in local_var_params:
            query_params.append(('jcr:content/userId', local_var_params['jcrcontentuser_id']))  # noqa: E501
        if 'jcrprimary_type' in local_var_params:
            query_params.append(('jcr:primaryType', local_var_params['jcrprimary_type']))  # noqa: E501
        if 'operation' in local_var_params:
            query_params.append((':operation', local_var_params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/replication/agents.{runmode}/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_authorizable_keystore(self, intermediate_path, authorizable_id, **kwargs):  # noqa: E501
        """post_authorizable_keystore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_authorizable_keystore(intermediate_path, authorizable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str intermediate_path: (required)
        :param str authorizable_id: (required)
        :param str operation:
        :param str current_password:
        :param str new_password:
        :param str re_password:
        :param str key_password:
        :param str key_store_pass:
        :param str alias:
        :param str new_alias:
        :param str remove_alias:
        :param file cert_chain:
        :param file pk:
        :param file key_store:
        :return: KeystoreInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_authorizable_keystore_with_http_info(intermediate_path, authorizable_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_authorizable_keystore_with_http_info(intermediate_path, authorizable_id, **kwargs)  # noqa: E501
            return data

    def post_authorizable_keystore_with_http_info(self, intermediate_path, authorizable_id, **kwargs):  # noqa: E501
        """post_authorizable_keystore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_authorizable_keystore_with_http_info(intermediate_path, authorizable_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str intermediate_path: (required)
        :param str authorizable_id: (required)
        :param str operation:
        :param str current_password:
        :param str new_password:
        :param str re_password:
        :param str key_password:
        :param str key_store_pass:
        :param str alias:
        :param str new_alias:
        :param str remove_alias:
        :param file cert_chain:
        :param file pk:
        :param file key_store:
        :return: KeystoreInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['intermediate_path', 'authorizable_id', 'operation', 'current_password', 'new_password', 're_password', 'key_password', 'key_store_pass', 'alias', 'new_alias', 'remove_alias', 'cert_chain', 'pk', 'key_store']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_authorizable_keystore" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'intermediate_path' is set
        if ('intermediate_path' not in local_var_params or
                local_var_params['intermediate_path'] is None):
            raise ValueError("Missing the required parameter `intermediate_path` when calling `post_authorizable_keystore`")  # noqa: E501
        # verify the required parameter 'authorizable_id' is set
        if ('authorizable_id' not in local_var_params or
                local_var_params['authorizable_id'] is None):
            raise ValueError("Missing the required parameter `authorizable_id` when calling `post_authorizable_keystore`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'intermediate_path' in local_var_params:
            path_params['intermediatePath'] = local_var_params['intermediate_path']  # noqa: E501
        if 'authorizable_id' in local_var_params:
            path_params['authorizableId'] = local_var_params['authorizable_id']  # noqa: E501

        query_params = []
        if 'operation' in local_var_params:
            query_params.append((':operation', local_var_params['operation']))  # noqa: E501
        if 'current_password' in local_var_params:
            query_params.append(('currentPassword', local_var_params['current_password']))  # noqa: E501
        if 'new_password' in local_var_params:
            query_params.append(('newPassword', local_var_params['new_password']))  # noqa: E501
        if 're_password' in local_var_params:
            query_params.append(('rePassword', local_var_params['re_password']))  # noqa: E501
        if 'key_password' in local_var_params:
            query_params.append(('keyPassword', local_var_params['key_password']))  # noqa: E501
        if 'key_store_pass' in local_var_params:
            query_params.append(('keyStorePass', local_var_params['key_store_pass']))  # noqa: E501
        if 'alias' in local_var_params:
            query_params.append(('alias', local_var_params['alias']))  # noqa: E501
        if 'new_alias' in local_var_params:
            query_params.append(('newAlias', local_var_params['new_alias']))  # noqa: E501
        if 'remove_alias' in local_var_params:
            query_params.append(('removeAlias', local_var_params['remove_alias']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'cert_chain' in local_var_params:
            local_var_files['cert-chain'] = local_var_params['cert_chain']  # noqa: E501
        if 'pk' in local_var_params:
            local_var_files['pk'] = local_var_params['pk']  # noqa: E501
        if 'key_store' in local_var_params:
            local_var_files['keyStore'] = local_var_params['key_store']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/{intermediatePath}/{authorizableId}.ks.html', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='KeystoreInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_authorizables(self, authorizable_id, intermediate_path, **kwargs):  # noqa: E501
        """post_authorizables  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_authorizables(authorizable_id, intermediate_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorizable_id: (required)
        :param str intermediate_path: (required)
        :param str create_user:
        :param str create_group:
        :param str reppassword:
        :param str profilegiven_name:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_authorizables_with_http_info(authorizable_id, intermediate_path, **kwargs)  # noqa: E501
        else:
            (data) = self.post_authorizables_with_http_info(authorizable_id, intermediate_path, **kwargs)  # noqa: E501
            return data

    def post_authorizables_with_http_info(self, authorizable_id, intermediate_path, **kwargs):  # noqa: E501
        """post_authorizables  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_authorizables_with_http_info(authorizable_id, intermediate_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorizable_id: (required)
        :param str intermediate_path: (required)
        :param str create_user:
        :param str create_group:
        :param str reppassword:
        :param str profilegiven_name:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorizable_id', 'intermediate_path', 'create_user', 'create_group', 'reppassword', 'profilegiven_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_authorizables" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorizable_id' is set
        if ('authorizable_id' not in local_var_params or
                local_var_params['authorizable_id'] is None):
            raise ValueError("Missing the required parameter `authorizable_id` when calling `post_authorizables`")  # noqa: E501
        # verify the required parameter 'intermediate_path' is set
        if ('intermediate_path' not in local_var_params or
                local_var_params['intermediate_path'] is None):
            raise ValueError("Missing the required parameter `intermediate_path` when calling `post_authorizables`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'authorizable_id' in local_var_params:
            query_params.append(('authorizableId', local_var_params['authorizable_id']))  # noqa: E501
        if 'intermediate_path' in local_var_params:
            query_params.append(('intermediatePath', local_var_params['intermediate_path']))  # noqa: E501
        if 'create_user' in local_var_params:
            query_params.append(('createUser', local_var_params['create_user']))  # noqa: E501
        if 'create_group' in local_var_params:
            query_params.append(('createGroup', local_var_params['create_group']))  # noqa: E501
        if 'reppassword' in local_var_params:
            query_params.append(('rep:password', local_var_params['reppassword']))  # noqa: E501
        if 'profilegiven_name' in local_var_params:
            query_params.append(('profile/givenName', local_var_params['profilegiven_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/libs/granite/security/post/authorizables', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_adobe_granite_saml_authentication_handler(self, **kwargs):  # noqa: E501
        """post_config_adobe_granite_saml_authentication_handler  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_adobe_granite_saml_authentication_handler(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str key_store_password:
        :param str key_store_password_type_hint:
        :param int service_ranking:
        :param str service_ranking_type_hint:
        :param bool idp_http_redirect:
        :param str idp_http_redirect_type_hint:
        :param bool create_user:
        :param str create_user_type_hint:
        :param str default_redirect_url:
        :param str default_redirect_url_type_hint:
        :param str user_id_attribute:
        :param str user_id_attribute_type_hint:
        :param list[str] default_groups:
        :param str default_groups_type_hint:
        :param str idp_cert_alias:
        :param str idp_cert_alias_type_hint:
        :param bool add_group_memberships:
        :param str add_group_memberships_type_hint:
        :param list[str] path:
        :param str path_type_hint:
        :param list[str] synchronize_attributes:
        :param str synchronize_attributes_type_hint:
        :param int clock_tolerance:
        :param str clock_tolerance_type_hint:
        :param str group_membership_attribute:
        :param str group_membership_attribute_type_hint:
        :param str idp_url:
        :param str idp_url_type_hint:
        :param str logout_url:
        :param str logout_url_type_hint:
        :param str service_provider_entity_id:
        :param str service_provider_entity_id_type_hint:
        :param str assertion_consumer_service_url:
        :param str assertion_consumer_service_url_type_hint:
        :param bool handle_logout:
        :param str handle_logout_type_hint:
        :param str sp_private_key_alias:
        :param str sp_private_key_alias_type_hint:
        :param bool use_encryption:
        :param str use_encryption_type_hint:
        :param str name_id_format:
        :param str name_id_format_type_hint:
        :param str digest_method:
        :param str digest_method_type_hint:
        :param str signature_method:
        :param str signature_method_type_hint:
        :param str user_intermediate_path:
        :param str user_intermediate_path_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_adobe_granite_saml_authentication_handler_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_config_adobe_granite_saml_authentication_handler_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_config_adobe_granite_saml_authentication_handler_with_http_info(self, **kwargs):  # noqa: E501
        """post_config_adobe_granite_saml_authentication_handler  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_adobe_granite_saml_authentication_handler_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str key_store_password:
        :param str key_store_password_type_hint:
        :param int service_ranking:
        :param str service_ranking_type_hint:
        :param bool idp_http_redirect:
        :param str idp_http_redirect_type_hint:
        :param bool create_user:
        :param str create_user_type_hint:
        :param str default_redirect_url:
        :param str default_redirect_url_type_hint:
        :param str user_id_attribute:
        :param str user_id_attribute_type_hint:
        :param list[str] default_groups:
        :param str default_groups_type_hint:
        :param str idp_cert_alias:
        :param str idp_cert_alias_type_hint:
        :param bool add_group_memberships:
        :param str add_group_memberships_type_hint:
        :param list[str] path:
        :param str path_type_hint:
        :param list[str] synchronize_attributes:
        :param str synchronize_attributes_type_hint:
        :param int clock_tolerance:
        :param str clock_tolerance_type_hint:
        :param str group_membership_attribute:
        :param str group_membership_attribute_type_hint:
        :param str idp_url:
        :param str idp_url_type_hint:
        :param str logout_url:
        :param str logout_url_type_hint:
        :param str service_provider_entity_id:
        :param str service_provider_entity_id_type_hint:
        :param str assertion_consumer_service_url:
        :param str assertion_consumer_service_url_type_hint:
        :param bool handle_logout:
        :param str handle_logout_type_hint:
        :param str sp_private_key_alias:
        :param str sp_private_key_alias_type_hint:
        :param bool use_encryption:
        :param str use_encryption_type_hint:
        :param str name_id_format:
        :param str name_id_format_type_hint:
        :param str digest_method:
        :param str digest_method_type_hint:
        :param str signature_method:
        :param str signature_method_type_hint:
        :param str user_intermediate_path:
        :param str user_intermediate_path_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['key_store_password', 'key_store_password_type_hint', 'service_ranking', 'service_ranking_type_hint', 'idp_http_redirect', 'idp_http_redirect_type_hint', 'create_user', 'create_user_type_hint', 'default_redirect_url', 'default_redirect_url_type_hint', 'user_id_attribute', 'user_id_attribute_type_hint', 'default_groups', 'default_groups_type_hint', 'idp_cert_alias', 'idp_cert_alias_type_hint', 'add_group_memberships', 'add_group_memberships_type_hint', 'path', 'path_type_hint', 'synchronize_attributes', 'synchronize_attributes_type_hint', 'clock_tolerance', 'clock_tolerance_type_hint', 'group_membership_attribute', 'group_membership_attribute_type_hint', 'idp_url', 'idp_url_type_hint', 'logout_url', 'logout_url_type_hint', 'service_provider_entity_id', 'service_provider_entity_id_type_hint', 'assertion_consumer_service_url', 'assertion_consumer_service_url_type_hint', 'handle_logout', 'handle_logout_type_hint', 'sp_private_key_alias', 'sp_private_key_alias_type_hint', 'use_encryption', 'use_encryption_type_hint', 'name_id_format', 'name_id_format_type_hint', 'digest_method', 'digest_method_type_hint', 'signature_method', 'signature_method_type_hint', 'user_intermediate_path', 'user_intermediate_path_type_hint']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_adobe_granite_saml_authentication_handler" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'key_store_password' in local_var_params:
            query_params.append(('keyStorePassword', local_var_params['key_store_password']))  # noqa: E501
        if 'key_store_password_type_hint' in local_var_params:
            query_params.append(('keyStorePassword@TypeHint', local_var_params['key_store_password_type_hint']))  # noqa: E501
        if 'service_ranking' in local_var_params:
            query_params.append(('service.ranking', local_var_params['service_ranking']))  # noqa: E501
        if 'service_ranking_type_hint' in local_var_params:
            query_params.append(('service.ranking@TypeHint', local_var_params['service_ranking_type_hint']))  # noqa: E501
        if 'idp_http_redirect' in local_var_params:
            query_params.append(('idpHttpRedirect', local_var_params['idp_http_redirect']))  # noqa: E501
        if 'idp_http_redirect_type_hint' in local_var_params:
            query_params.append(('idpHttpRedirect@TypeHint', local_var_params['idp_http_redirect_type_hint']))  # noqa: E501
        if 'create_user' in local_var_params:
            query_params.append(('createUser', local_var_params['create_user']))  # noqa: E501
        if 'create_user_type_hint' in local_var_params:
            query_params.append(('createUser@TypeHint', local_var_params['create_user_type_hint']))  # noqa: E501
        if 'default_redirect_url' in local_var_params:
            query_params.append(('defaultRedirectUrl', local_var_params['default_redirect_url']))  # noqa: E501
        if 'default_redirect_url_type_hint' in local_var_params:
            query_params.append(('defaultRedirectUrl@TypeHint', local_var_params['default_redirect_url_type_hint']))  # noqa: E501
        if 'user_id_attribute' in local_var_params:
            query_params.append(('userIDAttribute', local_var_params['user_id_attribute']))  # noqa: E501
        if 'user_id_attribute_type_hint' in local_var_params:
            query_params.append(('userIDAttribute@TypeHint', local_var_params['user_id_attribute_type_hint']))  # noqa: E501
        if 'default_groups' in local_var_params:
            query_params.append(('defaultGroups', local_var_params['default_groups']))  # noqa: E501
            collection_formats['defaultGroups'] = 'multi'  # noqa: E501
        if 'default_groups_type_hint' in local_var_params:
            query_params.append(('defaultGroups@TypeHint', local_var_params['default_groups_type_hint']))  # noqa: E501
        if 'idp_cert_alias' in local_var_params:
            query_params.append(('idpCertAlias', local_var_params['idp_cert_alias']))  # noqa: E501
        if 'idp_cert_alias_type_hint' in local_var_params:
            query_params.append(('idpCertAlias@TypeHint', local_var_params['idp_cert_alias_type_hint']))  # noqa: E501
        if 'add_group_memberships' in local_var_params:
            query_params.append(('addGroupMemberships', local_var_params['add_group_memberships']))  # noqa: E501
        if 'add_group_memberships_type_hint' in local_var_params:
            query_params.append(('addGroupMemberships@TypeHint', local_var_params['add_group_memberships_type_hint']))  # noqa: E501
        if 'path' in local_var_params:
            query_params.append(('path', local_var_params['path']))  # noqa: E501
            collection_formats['path'] = 'multi'  # noqa: E501
        if 'path_type_hint' in local_var_params:
            query_params.append(('path@TypeHint', local_var_params['path_type_hint']))  # noqa: E501
        if 'synchronize_attributes' in local_var_params:
            query_params.append(('synchronizeAttributes', local_var_params['synchronize_attributes']))  # noqa: E501
            collection_formats['synchronizeAttributes'] = 'multi'  # noqa: E501
        if 'synchronize_attributes_type_hint' in local_var_params:
            query_params.append(('synchronizeAttributes@TypeHint', local_var_params['synchronize_attributes_type_hint']))  # noqa: E501
        if 'clock_tolerance' in local_var_params:
            query_params.append(('clockTolerance', local_var_params['clock_tolerance']))  # noqa: E501
        if 'clock_tolerance_type_hint' in local_var_params:
            query_params.append(('clockTolerance@TypeHint', local_var_params['clock_tolerance_type_hint']))  # noqa: E501
        if 'group_membership_attribute' in local_var_params:
            query_params.append(('groupMembershipAttribute', local_var_params['group_membership_attribute']))  # noqa: E501
        if 'group_membership_attribute_type_hint' in local_var_params:
            query_params.append(('groupMembershipAttribute@TypeHint', local_var_params['group_membership_attribute_type_hint']))  # noqa: E501
        if 'idp_url' in local_var_params:
            query_params.append(('idpUrl', local_var_params['idp_url']))  # noqa: E501
        if 'idp_url_type_hint' in local_var_params:
            query_params.append(('idpUrl@TypeHint', local_var_params['idp_url_type_hint']))  # noqa: E501
        if 'logout_url' in local_var_params:
            query_params.append(('logoutUrl', local_var_params['logout_url']))  # noqa: E501
        if 'logout_url_type_hint' in local_var_params:
            query_params.append(('logoutUrl@TypeHint', local_var_params['logout_url_type_hint']))  # noqa: E501
        if 'service_provider_entity_id' in local_var_params:
            query_params.append(('serviceProviderEntityId', local_var_params['service_provider_entity_id']))  # noqa: E501
        if 'service_provider_entity_id_type_hint' in local_var_params:
            query_params.append(('serviceProviderEntityId@TypeHint', local_var_params['service_provider_entity_id_type_hint']))  # noqa: E501
        if 'assertion_consumer_service_url' in local_var_params:
            query_params.append(('assertionConsumerServiceURL', local_var_params['assertion_consumer_service_url']))  # noqa: E501
        if 'assertion_consumer_service_url_type_hint' in local_var_params:
            query_params.append(('assertionConsumerServiceURL@TypeHint', local_var_params['assertion_consumer_service_url_type_hint']))  # noqa: E501
        if 'handle_logout' in local_var_params:
            query_params.append(('handleLogout', local_var_params['handle_logout']))  # noqa: E501
        if 'handle_logout_type_hint' in local_var_params:
            query_params.append(('handleLogout@TypeHint', local_var_params['handle_logout_type_hint']))  # noqa: E501
        if 'sp_private_key_alias' in local_var_params:
            query_params.append(('spPrivateKeyAlias', local_var_params['sp_private_key_alias']))  # noqa: E501
        if 'sp_private_key_alias_type_hint' in local_var_params:
            query_params.append(('spPrivateKeyAlias@TypeHint', local_var_params['sp_private_key_alias_type_hint']))  # noqa: E501
        if 'use_encryption' in local_var_params:
            query_params.append(('useEncryption', local_var_params['use_encryption']))  # noqa: E501
        if 'use_encryption_type_hint' in local_var_params:
            query_params.append(('useEncryption@TypeHint', local_var_params['use_encryption_type_hint']))  # noqa: E501
        if 'name_id_format' in local_var_params:
            query_params.append(('nameIdFormat', local_var_params['name_id_format']))  # noqa: E501
        if 'name_id_format_type_hint' in local_var_params:
            query_params.append(('nameIdFormat@TypeHint', local_var_params['name_id_format_type_hint']))  # noqa: E501
        if 'digest_method' in local_var_params:
            query_params.append(('digestMethod', local_var_params['digest_method']))  # noqa: E501
        if 'digest_method_type_hint' in local_var_params:
            query_params.append(('digestMethod@TypeHint', local_var_params['digest_method_type_hint']))  # noqa: E501
        if 'signature_method' in local_var_params:
            query_params.append(('signatureMethod', local_var_params['signature_method']))  # noqa: E501
        if 'signature_method_type_hint' in local_var_params:
            query_params.append(('signatureMethod@TypeHint', local_var_params['signature_method_type_hint']))  # noqa: E501
        if 'user_intermediate_path' in local_var_params:
            query_params.append(('userIntermediatePath', local_var_params['user_intermediate_path']))  # noqa: E501
        if 'user_intermediate_path_type_hint' in local_var_params:
            query_params.append(('userIntermediatePath@TypeHint', local_var_params['user_intermediate_path_type_hint']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_apache_felix_jetty_based_http_service(self, **kwargs):  # noqa: E501
        """post_config_apache_felix_jetty_based_http_service  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_apache_felix_jetty_based_http_service(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool org_apache_felix_https_nio:
        :param str org_apache_felix_https_nio_type_hint:
        :param str org_apache_felix_https_keystore:
        :param str org_apache_felix_https_keystore_type_hint:
        :param str org_apache_felix_https_keystore_password:
        :param str org_apache_felix_https_keystore_password_type_hint:
        :param str org_apache_felix_https_keystore_key:
        :param str org_apache_felix_https_keystore_key_type_hint:
        :param str org_apache_felix_https_keystore_key_password:
        :param str org_apache_felix_https_keystore_key_password_type_hint:
        :param str org_apache_felix_https_truststore:
        :param str org_apache_felix_https_truststore_type_hint:
        :param str org_apache_felix_https_truststore_password:
        :param str org_apache_felix_https_truststore_password_type_hint:
        :param str org_apache_felix_https_clientcertificate:
        :param str org_apache_felix_https_clientcertificate_type_hint:
        :param bool org_apache_felix_https_enable:
        :param str org_apache_felix_https_enable_type_hint:
        :param str org_osgi_service_http_port_secure:
        :param str org_osgi_service_http_port_secure_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_apache_felix_jetty_based_http_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_config_apache_felix_jetty_based_http_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_config_apache_felix_jetty_based_http_service_with_http_info(self, **kwargs):  # noqa: E501
        """post_config_apache_felix_jetty_based_http_service  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_apache_felix_jetty_based_http_service_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool org_apache_felix_https_nio:
        :param str org_apache_felix_https_nio_type_hint:
        :param str org_apache_felix_https_keystore:
        :param str org_apache_felix_https_keystore_type_hint:
        :param str org_apache_felix_https_keystore_password:
        :param str org_apache_felix_https_keystore_password_type_hint:
        :param str org_apache_felix_https_keystore_key:
        :param str org_apache_felix_https_keystore_key_type_hint:
        :param str org_apache_felix_https_keystore_key_password:
        :param str org_apache_felix_https_keystore_key_password_type_hint:
        :param str org_apache_felix_https_truststore:
        :param str org_apache_felix_https_truststore_type_hint:
        :param str org_apache_felix_https_truststore_password:
        :param str org_apache_felix_https_truststore_password_type_hint:
        :param str org_apache_felix_https_clientcertificate:
        :param str org_apache_felix_https_clientcertificate_type_hint:
        :param bool org_apache_felix_https_enable:
        :param str org_apache_felix_https_enable_type_hint:
        :param str org_osgi_service_http_port_secure:
        :param str org_osgi_service_http_port_secure_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['org_apache_felix_https_nio', 'org_apache_felix_https_nio_type_hint', 'org_apache_felix_https_keystore', 'org_apache_felix_https_keystore_type_hint', 'org_apache_felix_https_keystore_password', 'org_apache_felix_https_keystore_password_type_hint', 'org_apache_felix_https_keystore_key', 'org_apache_felix_https_keystore_key_type_hint', 'org_apache_felix_https_keystore_key_password', 'org_apache_felix_https_keystore_key_password_type_hint', 'org_apache_felix_https_truststore', 'org_apache_felix_https_truststore_type_hint', 'org_apache_felix_https_truststore_password', 'org_apache_felix_https_truststore_password_type_hint', 'org_apache_felix_https_clientcertificate', 'org_apache_felix_https_clientcertificate_type_hint', 'org_apache_felix_https_enable', 'org_apache_felix_https_enable_type_hint', 'org_osgi_service_http_port_secure', 'org_osgi_service_http_port_secure_type_hint']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_apache_felix_jetty_based_http_service" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'org_apache_felix_https_nio' in local_var_params:
            query_params.append(('org.apache.felix.https.nio', local_var_params['org_apache_felix_https_nio']))  # noqa: E501
        if 'org_apache_felix_https_nio_type_hint' in local_var_params:
            query_params.append(('org.apache.felix.https.nio@TypeHint', local_var_params['org_apache_felix_https_nio_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_keystore' in local_var_params:
            query_params.append(('org.apache.felix.https.keystore', local_var_params['org_apache_felix_https_keystore']))  # noqa: E501
        if 'org_apache_felix_https_keystore_type_hint' in local_var_params:
            query_params.append(('org.apache.felix.https.keystore@TypeHint', local_var_params['org_apache_felix_https_keystore_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_keystore_password' in local_var_params:
            query_params.append(('org.apache.felix.https.keystore.password', local_var_params['org_apache_felix_https_keystore_password']))  # noqa: E501
        if 'org_apache_felix_https_keystore_password_type_hint' in local_var_params:
            query_params.append(('org.apache.felix.https.keystore.password@TypeHint', local_var_params['org_apache_felix_https_keystore_password_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_keystore_key' in local_var_params:
            query_params.append(('org.apache.felix.https.keystore.key', local_var_params['org_apache_felix_https_keystore_key']))  # noqa: E501
        if 'org_apache_felix_https_keystore_key_type_hint' in local_var_params:
            query_params.append(('org.apache.felix.https.keystore.key@TypeHint', local_var_params['org_apache_felix_https_keystore_key_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_keystore_key_password' in local_var_params:
            query_params.append(('org.apache.felix.https.keystore.key.password', local_var_params['org_apache_felix_https_keystore_key_password']))  # noqa: E501
        if 'org_apache_felix_https_keystore_key_password_type_hint' in local_var_params:
            query_params.append(('org.apache.felix.https.keystore.key.password@TypeHint', local_var_params['org_apache_felix_https_keystore_key_password_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_truststore' in local_var_params:
            query_params.append(('org.apache.felix.https.truststore', local_var_params['org_apache_felix_https_truststore']))  # noqa: E501
        if 'org_apache_felix_https_truststore_type_hint' in local_var_params:
            query_params.append(('org.apache.felix.https.truststore@TypeHint', local_var_params['org_apache_felix_https_truststore_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_truststore_password' in local_var_params:
            query_params.append(('org.apache.felix.https.truststore.password', local_var_params['org_apache_felix_https_truststore_password']))  # noqa: E501
        if 'org_apache_felix_https_truststore_password_type_hint' in local_var_params:
            query_params.append(('org.apache.felix.https.truststore.password@TypeHint', local_var_params['org_apache_felix_https_truststore_password_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_clientcertificate' in local_var_params:
            query_params.append(('org.apache.felix.https.clientcertificate', local_var_params['org_apache_felix_https_clientcertificate']))  # noqa: E501
        if 'org_apache_felix_https_clientcertificate_type_hint' in local_var_params:
            query_params.append(('org.apache.felix.https.clientcertificate@TypeHint', local_var_params['org_apache_felix_https_clientcertificate_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_enable' in local_var_params:
            query_params.append(('org.apache.felix.https.enable', local_var_params['org_apache_felix_https_enable']))  # noqa: E501
        if 'org_apache_felix_https_enable_type_hint' in local_var_params:
            query_params.append(('org.apache.felix.https.enable@TypeHint', local_var_params['org_apache_felix_https_enable_type_hint']))  # noqa: E501
        if 'org_osgi_service_http_port_secure' in local_var_params:
            query_params.append(('org.osgi.service.http.port.secure', local_var_params['org_osgi_service_http_port_secure']))  # noqa: E501
        if 'org_osgi_service_http_port_secure_type_hint' in local_var_params:
            query_params.append(('org.osgi.service.http.port.secure@TypeHint', local_var_params['org_osgi_service_http_port_secure_type_hint']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/apps/system/config/org.apache.felix.http', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_apache_http_components_proxy_configuration(self, **kwargs):  # noqa: E501
        """post_config_apache_http_components_proxy_configuration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_apache_http_components_proxy_configuration(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proxy_host:
        :param str proxy_host_type_hint:
        :param int proxy_port:
        :param str proxy_port_type_hint:
        :param list[str] proxy_exceptions:
        :param str proxy_exceptions_type_hint:
        :param bool proxy_enabled:
        :param str proxy_enabled_type_hint:
        :param str proxy_user:
        :param str proxy_user_type_hint:
        :param str proxy_password:
        :param str proxy_password_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_apache_http_components_proxy_configuration_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_config_apache_http_components_proxy_configuration_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_config_apache_http_components_proxy_configuration_with_http_info(self, **kwargs):  # noqa: E501
        """post_config_apache_http_components_proxy_configuration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_apache_http_components_proxy_configuration_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str proxy_host:
        :param str proxy_host_type_hint:
        :param int proxy_port:
        :param str proxy_port_type_hint:
        :param list[str] proxy_exceptions:
        :param str proxy_exceptions_type_hint:
        :param bool proxy_enabled:
        :param str proxy_enabled_type_hint:
        :param str proxy_user:
        :param str proxy_user_type_hint:
        :param str proxy_password:
        :param str proxy_password_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['proxy_host', 'proxy_host_type_hint', 'proxy_port', 'proxy_port_type_hint', 'proxy_exceptions', 'proxy_exceptions_type_hint', 'proxy_enabled', 'proxy_enabled_type_hint', 'proxy_user', 'proxy_user_type_hint', 'proxy_password', 'proxy_password_type_hint']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_apache_http_components_proxy_configuration" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'proxy_host' in local_var_params:
            query_params.append(('proxy.host', local_var_params['proxy_host']))  # noqa: E501
        if 'proxy_host_type_hint' in local_var_params:
            query_params.append(('proxy.host@TypeHint', local_var_params['proxy_host_type_hint']))  # noqa: E501
        if 'proxy_port' in local_var_params:
            query_params.append(('proxy.port', local_var_params['proxy_port']))  # noqa: E501
        if 'proxy_port_type_hint' in local_var_params:
            query_params.append(('proxy.port@TypeHint', local_var_params['proxy_port_type_hint']))  # noqa: E501
        if 'proxy_exceptions' in local_var_params:
            query_params.append(('proxy.exceptions', local_var_params['proxy_exceptions']))  # noqa: E501
            collection_formats['proxy.exceptions'] = 'multi'  # noqa: E501
        if 'proxy_exceptions_type_hint' in local_var_params:
            query_params.append(('proxy.exceptions@TypeHint', local_var_params['proxy_exceptions_type_hint']))  # noqa: E501
        if 'proxy_enabled' in local_var_params:
            query_params.append(('proxy.enabled', local_var_params['proxy_enabled']))  # noqa: E501
        if 'proxy_enabled_type_hint' in local_var_params:
            query_params.append(('proxy.enabled@TypeHint', local_var_params['proxy_enabled_type_hint']))  # noqa: E501
        if 'proxy_user' in local_var_params:
            query_params.append(('proxy.user', local_var_params['proxy_user']))  # noqa: E501
        if 'proxy_user_type_hint' in local_var_params:
            query_params.append(('proxy.user@TypeHint', local_var_params['proxy_user_type_hint']))  # noqa: E501
        if 'proxy_password' in local_var_params:
            query_params.append(('proxy.password', local_var_params['proxy_password']))  # noqa: E501
        if 'proxy_password_type_hint' in local_var_params:
            query_params.append(('proxy.password@TypeHint', local_var_params['proxy_password_type_hint']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/apps/system/config/org.apache.http.proxyconfigurator.config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_apache_sling_dav_ex_servlet(self, **kwargs):  # noqa: E501
        """post_config_apache_sling_dav_ex_servlet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_apache_sling_dav_ex_servlet(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str alias:
        :param str alias_type_hint:
        :param bool dav_create_absolute_uri:
        :param str dav_create_absolute_uri_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_apache_sling_dav_ex_servlet_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_config_apache_sling_dav_ex_servlet_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_config_apache_sling_dav_ex_servlet_with_http_info(self, **kwargs):  # noqa: E501
        """post_config_apache_sling_dav_ex_servlet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_apache_sling_dav_ex_servlet_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str alias:
        :param str alias_type_hint:
        :param bool dav_create_absolute_uri:
        :param str dav_create_absolute_uri_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['alias', 'alias_type_hint', 'dav_create_absolute_uri', 'dav_create_absolute_uri_type_hint']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_apache_sling_dav_ex_servlet" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'alias' in local_var_params:
            query_params.append(('alias', local_var_params['alias']))  # noqa: E501
        if 'alias_type_hint' in local_var_params:
            query_params.append(('alias@TypeHint', local_var_params['alias_type_hint']))  # noqa: E501
        if 'dav_create_absolute_uri' in local_var_params:
            query_params.append(('dav.create-absolute-uri', local_var_params['dav_create_absolute_uri']))  # noqa: E501
        if 'dav_create_absolute_uri_type_hint' in local_var_params:
            query_params.append(('dav.create-absolute-uri@TypeHint', local_var_params['dav_create_absolute_uri_type_hint']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_apache_sling_get_servlet(self, **kwargs):  # noqa: E501
        """post_config_apache_sling_get_servlet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_apache_sling_get_servlet(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str json_maximumresults:
        :param str json_maximumresults_type_hint:
        :param bool enable_html:
        :param str enable_html_type_hint:
        :param bool enable_txt:
        :param str enable_txt_type_hint:
        :param bool enable_xml:
        :param str enable_xml_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_apache_sling_get_servlet_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_config_apache_sling_get_servlet_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_config_apache_sling_get_servlet_with_http_info(self, **kwargs):  # noqa: E501
        """post_config_apache_sling_get_servlet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_apache_sling_get_servlet_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str json_maximumresults:
        :param str json_maximumresults_type_hint:
        :param bool enable_html:
        :param str enable_html_type_hint:
        :param bool enable_txt:
        :param str enable_txt_type_hint:
        :param bool enable_xml:
        :param str enable_xml_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['json_maximumresults', 'json_maximumresults_type_hint', 'enable_html', 'enable_html_type_hint', 'enable_txt', 'enable_txt_type_hint', 'enable_xml', 'enable_xml_type_hint']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_apache_sling_get_servlet" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'json_maximumresults' in local_var_params:
            query_params.append(('json.maximumresults', local_var_params['json_maximumresults']))  # noqa: E501
        if 'json_maximumresults_type_hint' in local_var_params:
            query_params.append(('json.maximumresults@TypeHint', local_var_params['json_maximumresults_type_hint']))  # noqa: E501
        if 'enable_html' in local_var_params:
            query_params.append(('enable.html', local_var_params['enable_html']))  # noqa: E501
        if 'enable_html_type_hint' in local_var_params:
            query_params.append(('enable.html@TypeHint', local_var_params['enable_html_type_hint']))  # noqa: E501
        if 'enable_txt' in local_var_params:
            query_params.append(('enable.txt', local_var_params['enable_txt']))  # noqa: E501
        if 'enable_txt_type_hint' in local_var_params:
            query_params.append(('enable.txt@TypeHint', local_var_params['enable_txt_type_hint']))  # noqa: E501
        if 'enable_xml' in local_var_params:
            query_params.append(('enable.xml', local_var_params['enable_xml']))  # noqa: E501
        if 'enable_xml_type_hint' in local_var_params:
            query_params.append(('enable.xml@TypeHint', local_var_params['enable_xml_type_hint']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_apache_sling_referrer_filter(self, **kwargs):  # noqa: E501
        """post_config_apache_sling_referrer_filter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_apache_sling_referrer_filter(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool allow_empty:
        :param str allow_empty_type_hint:
        :param str allow_hosts:
        :param str allow_hosts_type_hint:
        :param str allow_hosts_regexp:
        :param str allow_hosts_regexp_type_hint:
        :param str filter_methods:
        :param str filter_methods_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_config_apache_sling_referrer_filter_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_config_apache_sling_referrer_filter_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_config_apache_sling_referrer_filter_with_http_info(self, **kwargs):  # noqa: E501
        """post_config_apache_sling_referrer_filter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_config_apache_sling_referrer_filter_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool allow_empty:
        :param str allow_empty_type_hint:
        :param str allow_hosts:
        :param str allow_hosts_type_hint:
        :param str allow_hosts_regexp:
        :param str allow_hosts_regexp_type_hint:
        :param str filter_methods:
        :param str filter_methods_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['allow_empty', 'allow_empty_type_hint', 'allow_hosts', 'allow_hosts_type_hint', 'allow_hosts_regexp', 'allow_hosts_regexp_type_hint', 'filter_methods', 'filter_methods_type_hint']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_apache_sling_referrer_filter" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'allow_empty' in local_var_params:
            query_params.append(('allow.empty', local_var_params['allow_empty']))  # noqa: E501
        if 'allow_empty_type_hint' in local_var_params:
            query_params.append(('allow.empty@TypeHint', local_var_params['allow_empty_type_hint']))  # noqa: E501
        if 'allow_hosts' in local_var_params:
            query_params.append(('allow.hosts', local_var_params['allow_hosts']))  # noqa: E501
        if 'allow_hosts_type_hint' in local_var_params:
            query_params.append(('allow.hosts@TypeHint', local_var_params['allow_hosts_type_hint']))  # noqa: E501
        if 'allow_hosts_regexp' in local_var_params:
            query_params.append(('allow.hosts.regexp', local_var_params['allow_hosts_regexp']))  # noqa: E501
        if 'allow_hosts_regexp_type_hint' in local_var_params:
            query_params.append(('allow.hosts.regexp@TypeHint', local_var_params['allow_hosts_regexp_type_hint']))  # noqa: E501
        if 'filter_methods' in local_var_params:
            query_params.append(('filter.methods', local_var_params['filter_methods']))  # noqa: E501
        if 'filter_methods_type_hint' in local_var_params:
            query_params.append(('filter.methods@TypeHint', local_var_params['filter_methods_type_hint']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/apps/system/config/org.apache.sling.security.impl.ReferrerFilter', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_node(self, path, name, **kwargs):  # noqa: E501
        """post_node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_node(path, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str name: (required)
        :param str operation:
        :param str delete_authorizable:
        :param file file:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_node_with_http_info(path, name, **kwargs)  # noqa: E501
        else:
            (data) = self.post_node_with_http_info(path, name, **kwargs)  # noqa: E501
            return data

    def post_node_with_http_info(self, path, name, **kwargs):  # noqa: E501
        """post_node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_node_with_http_info(path, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str name: (required)
        :param str operation:
        :param str delete_authorizable:
        :param file file:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['path', 'name', 'operation', 'delete_authorizable', 'file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_node" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in local_var_params or
                local_var_params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `post_node`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in local_var_params or
                local_var_params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501
        if 'name' in local_var_params:
            path_params['name'] = local_var_params['name']  # noqa: E501

        query_params = []
        if 'operation' in local_var_params:
            query_params.append((':operation', local_var_params['operation']))  # noqa: E501
        if 'delete_authorizable' in local_var_params:
            query_params.append(('deleteAuthorizable', local_var_params['delete_authorizable']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in local_var_params:
            local_var_files['file'] = local_var_params['file']  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/{path}/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_node_rw(self, path, name, **kwargs):  # noqa: E501
        """post_node_rw  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_node_rw(path, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str name: (required)
        :param str add_members:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_node_rw_with_http_info(path, name, **kwargs)  # noqa: E501
        else:
            (data) = self.post_node_rw_with_http_info(path, name, **kwargs)  # noqa: E501
            return data

    def post_node_rw_with_http_info(self, path, name, **kwargs):  # noqa: E501
        """post_node_rw  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_node_rw_with_http_info(path, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str name: (required)
        :param str add_members:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['path', 'name', 'add_members']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_node_rw" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in local_var_params or
                local_var_params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `post_node_rw`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in local_var_params or
                local_var_params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_node_rw`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501
        if 'name' in local_var_params:
            path_params['name'] = local_var_params['name']  # noqa: E501

        query_params = []
        if 'add_members' in local_var_params:
            query_params.append(('addMembers', local_var_params['add_members']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/{path}/{name}.rw.html', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_path(self, path, jcrprimary_type, name, **kwargs):  # noqa: E501
        """post_path  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_path(path, jcrprimary_type, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str jcrprimary_type: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_path_with_http_info(path, jcrprimary_type, name, **kwargs)  # noqa: E501
        else:
            (data) = self.post_path_with_http_info(path, jcrprimary_type, name, **kwargs)  # noqa: E501
            return data

    def post_path_with_http_info(self, path, jcrprimary_type, name, **kwargs):  # noqa: E501
        """post_path  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_path_with_http_info(path, jcrprimary_type, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str jcrprimary_type: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['path', 'jcrprimary_type', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_path" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in local_var_params or
                local_var_params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `post_path`")  # noqa: E501
        # verify the required parameter 'jcrprimary_type' is set
        if ('jcrprimary_type' not in local_var_params or
                local_var_params['jcrprimary_type'] is None):
            raise ValueError("Missing the required parameter `jcrprimary_type` when calling `post_path`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in local_var_params or
                local_var_params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_path`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []
        if 'jcrprimary_type' in local_var_params:
            query_params.append(('jcr:primaryType', local_var_params['jcrprimary_type']))  # noqa: E501
        if 'name' in local_var_params:
            query_params.append((':name', local_var_params['name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/{path}/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_query(self, path, p_limit, _1_property, _1_property_value, **kwargs):  # noqa: E501
        """post_query  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_query(path, p_limit, _1_property, _1_property_value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param float p_limit: (required)
        :param str _1_property: (required)
        :param str _1_property_value: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_query_with_http_info(path, p_limit, _1_property, _1_property_value, **kwargs)  # noqa: E501
        else:
            (data) = self.post_query_with_http_info(path, p_limit, _1_property, _1_property_value, **kwargs)  # noqa: E501
            return data

    def post_query_with_http_info(self, path, p_limit, _1_property, _1_property_value, **kwargs):  # noqa: E501
        """post_query  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_query_with_http_info(path, p_limit, _1_property, _1_property_value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param float p_limit: (required)
        :param str _1_property: (required)
        :param str _1_property_value: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['path', 'p_limit', '_1_property', '_1_property_value']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_query" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in local_var_params or
                local_var_params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `post_query`")  # noqa: E501
        # verify the required parameter 'p_limit' is set
        if ('p_limit' not in local_var_params or
                local_var_params['p_limit'] is None):
            raise ValueError("Missing the required parameter `p_limit` when calling `post_query`")  # noqa: E501
        # verify the required parameter '_1_property' is set
        if ('_1_property' not in local_var_params or
                local_var_params['_1_property'] is None):
            raise ValueError("Missing the required parameter `_1_property` when calling `post_query`")  # noqa: E501
        # verify the required parameter '_1_property_value' is set
        if ('_1_property_value' not in local_var_params or
                local_var_params['_1_property_value'] is None):
            raise ValueError("Missing the required parameter `_1_property_value` when calling `post_query`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in local_var_params:
            query_params.append(('path', local_var_params['path']))  # noqa: E501
        if 'p_limit' in local_var_params:
            query_params.append(('p.limit', local_var_params['p_limit']))  # noqa: E501
        if '_1_property' in local_var_params:
            query_params.append(('1_property', local_var_params['_1_property']))  # noqa: E501
        if '_1_property_value' in local_var_params:
            query_params.append(('1_property.value', local_var_params['_1_property_value']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bin/querybuilder.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_tree_activation(self, ignoredeactivated, onlymodified, path, **kwargs):  # noqa: E501
        """post_tree_activation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_tree_activation(ignoredeactivated, onlymodified, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool ignoredeactivated: (required)
        :param bool onlymodified: (required)
        :param str path: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_tree_activation_with_http_info(ignoredeactivated, onlymodified, path, **kwargs)  # noqa: E501
        else:
            (data) = self.post_tree_activation_with_http_info(ignoredeactivated, onlymodified, path, **kwargs)  # noqa: E501
            return data

    def post_tree_activation_with_http_info(self, ignoredeactivated, onlymodified, path, **kwargs):  # noqa: E501
        """post_tree_activation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_tree_activation_with_http_info(ignoredeactivated, onlymodified, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool ignoredeactivated: (required)
        :param bool onlymodified: (required)
        :param str path: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['ignoredeactivated', 'onlymodified', 'path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_tree_activation" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'ignoredeactivated' is set
        if ('ignoredeactivated' not in local_var_params or
                local_var_params['ignoredeactivated'] is None):
            raise ValueError("Missing the required parameter `ignoredeactivated` when calling `post_tree_activation`")  # noqa: E501
        # verify the required parameter 'onlymodified' is set
        if ('onlymodified' not in local_var_params or
                local_var_params['onlymodified'] is None):
            raise ValueError("Missing the required parameter `onlymodified` when calling `post_tree_activation`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in local_var_params or
                local_var_params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `post_tree_activation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ignoredeactivated' in local_var_params:
            query_params.append(('ignoredeactivated', local_var_params['ignoredeactivated']))  # noqa: E501
        if 'onlymodified' in local_var_params:
            query_params.append(('onlymodified', local_var_params['onlymodified']))  # noqa: E501
        if 'path' in local_var_params:
            query_params.append(('path', local_var_params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/replication/treeactivation.html', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_truststore(self, **kwargs):  # noqa: E501
        """post_truststore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_truststore(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str operation:
        :param str new_password:
        :param str re_password:
        :param str key_store_type:
        :param str remove_alias:
        :param file certificate:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_truststore_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_truststore_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_truststore_with_http_info(self, **kwargs):  # noqa: E501
        """post_truststore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_truststore_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str operation:
        :param str new_password:
        :param str re_password:
        :param str key_store_type:
        :param str remove_alias:
        :param file certificate:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['operation', 'new_password', 're_password', 'key_store_type', 'remove_alias', 'certificate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_truststore" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'operation' in local_var_params:
            query_params.append((':operation', local_var_params['operation']))  # noqa: E501
        if 'new_password' in local_var_params:
            query_params.append(('newPassword', local_var_params['new_password']))  # noqa: E501
        if 're_password' in local_var_params:
            query_params.append(('rePassword', local_var_params['re_password']))  # noqa: E501
        if 'key_store_type' in local_var_params:
            query_params.append(('keyStoreType', local_var_params['key_store_type']))  # noqa: E501
        if 'remove_alias' in local_var_params:
            query_params.append(('removeAlias', local_var_params['remove_alias']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'certificate' in local_var_params:
            local_var_files['certificate'] = local_var_params['certificate']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/libs/granite/security/post/truststore', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_truststore_pkcs12(self, **kwargs):  # noqa: E501
        """post_truststore_pkcs12  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_truststore_pkcs12(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file truststore_p12:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_truststore_pkcs12_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_truststore_pkcs12_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_truststore_pkcs12_with_http_info(self, **kwargs):  # noqa: E501
        """post_truststore_pkcs12  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_truststore_pkcs12_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file truststore_p12:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['truststore_p12']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_truststore_pkcs12" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'truststore_p12' in local_var_params:
            local_var_files['truststore.p12'] = local_var_params['truststore_p12']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/truststore', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
