/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * OpenAPI spec version: 3.2.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

/* tslint:disable:no-unused-locals */
import { KeystoreInfo } from '../model/keystoreInfo';
import { TruststoreInfo } from '../model/truststoreInfo';

import { ObjectSerializer, Authentication, HttpBasicAuth, ApiKeyAuth, OAuth, VoidAuth } from '../model/models';

let defaultBasePath = 'http://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum SlingApiApiKeys {
}

export class SlingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'aemAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: SlingApiApiKeys, value: string) {
        (this.authentications as any)[SlingApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.aemAuth.username = username;
    }

    set password(password: string) {
        this.authentications.aemAuth.password = password;
    }

    /**
     * 
     * @param runmode 
     * @param name 
     */
    public deleteAgent (runmode: string, name: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'
            .replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling deleteAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteAgent.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param path 
     * @param name 
     */
    public deleteNode (path: string, name: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/{path}/{name}'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling deleteNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNode.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param runmode 
     * @param name 
     */
    public getAgent (runmode: string, name: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'
            .replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling getAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getAgent.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param runmode 
     */
    public getAgents (runmode: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/etc/replication/agents.{runmode}.-1.json'
            .replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling getAgents.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     */
    public getAuthorizableKeystore (intermediatePath: string, authorizableId: string) : Promise<{ response: http.ClientResponse; body: KeystoreInfo;  }> {
        const localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}.ks.json'
            .replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath)))
            .replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling getAuthorizableKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling getAuthorizableKeystore.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: KeystoreInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "KeystoreInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     */
    public getKeystore (intermediatePath: string, authorizableId: string) : Promise<{ response: http.ClientResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}/keystore/store.p12'
            .replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath)))
            .replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling getKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling getKeystore.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param path 
     * @param name 
     */
    public getNode (path: string, name: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/{path}/{name}'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getNode.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param group 
     * @param name 
     * @param version 
     */
    public getPackage (group: string, name: string, version: string) : Promise<{ response: http.ClientResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/etc/packages/{group}/{name}-{version}.zip'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getPackage.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getPackage.');
        }

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getPackage.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param group 
     * @param name 
     * @param version 
     */
    public getPackageFilter (group: string, name: string, version: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getPackageFilter.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getPackageFilter.');
        }

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getPackageFilter.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     */
    public getQuery (path: string, pLimit: number, _1property: string, _1propertyValue: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/bin/querybuilder.json';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getQuery.');
        }

        // verify required parameter 'pLimit' is not null or undefined
        if (pLimit === null || pLimit === undefined) {
            throw new Error('Required parameter pLimit was null or undefined when calling getQuery.');
        }

        // verify required parameter '_1property' is not null or undefined
        if (_1property === null || _1property === undefined) {
            throw new Error('Required parameter _1property was null or undefined when calling getQuery.');
        }

        // verify required parameter '_1propertyValue' is not null or undefined
        if (_1propertyValue === null || _1propertyValue === undefined) {
            throw new Error('Required parameter _1propertyValue was null or undefined when calling getQuery.');
        }

        if (path !== undefined) {
            localVarQueryParameters['path'] = ObjectSerializer.serialize(path, "string");
        }

        if (pLimit !== undefined) {
            localVarQueryParameters['p.limit'] = ObjectSerializer.serialize(pLimit, "number");
        }

        if (_1property !== undefined) {
            localVarQueryParameters['1_property'] = ObjectSerializer.serialize(_1property, "string");
        }

        if (_1propertyValue !== undefined) {
            localVarQueryParameters['1_property.value'] = ObjectSerializer.serialize(_1propertyValue, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     */
    public getTruststore () : Promise<{ response: http.ClientResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/etc/truststore/truststore.p12';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     */
    public getTruststoreInfo () : Promise<{ response: http.ClientResponse; body: TruststoreInfo;  }> {
        const localVarPath = this.basePath + '/libs/granite/security/truststore.json';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TruststoreInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TruststoreInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param runmode 
     * @param name 
     * @param jcr:contentCq:distribute 
     * @param jcr:contentCq:distribute@TypeHint 
     * @param jcr:contentCq:name 
     * @param jcr:contentCq:template 
     * @param jcr:contentEnabled 
     * @param jcr:contentJcr:description 
     * @param jcr:contentJcr:lastModified 
     * @param jcr:contentJcr:lastModifiedBy 
     * @param jcr:contentJcr:mixinTypes 
     * @param jcr:contentJcr:title 
     * @param jcr:contentLogLevel 
     * @param jcr:contentNoStatusUpdate 
     * @param jcr:contentNoVersioning 
     * @param jcr:contentProtocolConnectTimeout 
     * @param jcr:contentProtocolHTTPConnectionClosed 
     * @param jcr:contentProtocolHTTPExpired 
     * @param jcr:contentProtocolHTTPHeaders 
     * @param jcr:contentProtocolHTTPHeaders@TypeHint 
     * @param jcr:contentProtocolHTTPMethod 
     * @param jcr:contentProtocolHTTPSRelaxed 
     * @param jcr:contentProtocolInterface 
     * @param jcr:contentProtocolSocketTimeout 
     * @param jcr:contentProtocolVersion 
     * @param jcr:contentProxyNTLMDomain 
     * @param jcr:contentProxyNTLMHost 
     * @param jcr:contentProxyHost 
     * @param jcr:contentProxyPassword 
     * @param jcr:contentProxyPort 
     * @param jcr:contentProxyUser 
     * @param jcr:contentQueueBatchMaxSize 
     * @param jcr:contentQueueBatchMode 
     * @param jcr:contentQueueBatchWaitTime 
     * @param jcr:contentRetryDelay 
     * @param jcr:contentReverseReplication 
     * @param jcr:contentSerializationType 
     * @param jcr:contentSling:resourceType 
     * @param jcr:contentSsl 
     * @param jcr:contentTransportNTLMDomain 
     * @param jcr:contentTransportNTLMHost 
     * @param jcr:contentTransportPassword 
     * @param jcr:contentTransportUri 
     * @param jcr:contentTransportUser 
     * @param jcr:contentTriggerDistribute 
     * @param jcr:contentTriggerModified 
     * @param jcr:contentTriggerOnOffTime 
     * @param jcr:contentTriggerReceive 
     * @param jcr:contentTriggerSpecific 
     * @param jcr:contentUserId 
     * @param jcr:primaryType 
     * @param :operation 
     */
    public postAgent (runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'
            .replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling postAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postAgent.');
        }

        if (jcr:contentCq:distribute !== undefined) {
            localVarQueryParameters['jcr:content/cq:distribute'] = ObjectSerializer.serialize(jcr:contentCq:distribute, "boolean");
        }

        if (jcr:contentCq:distribute@TypeHint !== undefined) {
            localVarQueryParameters['jcr:content/cq:distribute@TypeHint'] = ObjectSerializer.serialize(jcr:contentCq:distribute@TypeHint, "string");
        }

        if (jcr:contentCq:name !== undefined) {
            localVarQueryParameters['jcr:content/cq:name'] = ObjectSerializer.serialize(jcr:contentCq:name, "string");
        }

        if (jcr:contentCq:template !== undefined) {
            localVarQueryParameters['jcr:content/cq:template'] = ObjectSerializer.serialize(jcr:contentCq:template, "string");
        }

        if (jcr:contentEnabled !== undefined) {
            localVarQueryParameters['jcr:content/enabled'] = ObjectSerializer.serialize(jcr:contentEnabled, "boolean");
        }

        if (jcr:contentJcr:description !== undefined) {
            localVarQueryParameters['jcr:content/jcr:description'] = ObjectSerializer.serialize(jcr:contentJcr:description, "string");
        }

        if (jcr:contentJcr:lastModified !== undefined) {
            localVarQueryParameters['jcr:content/jcr:lastModified'] = ObjectSerializer.serialize(jcr:contentJcr:lastModified, "string");
        }

        if (jcr:contentJcr:lastModifiedBy !== undefined) {
            localVarQueryParameters['jcr:content/jcr:lastModifiedBy'] = ObjectSerializer.serialize(jcr:contentJcr:lastModifiedBy, "string");
        }

        if (jcr:contentJcr:mixinTypes !== undefined) {
            localVarQueryParameters['jcr:content/jcr:mixinTypes'] = ObjectSerializer.serialize(jcr:contentJcr:mixinTypes, "string");
        }

        if (jcr:contentJcr:title !== undefined) {
            localVarQueryParameters['jcr:content/jcr:title'] = ObjectSerializer.serialize(jcr:contentJcr:title, "string");
        }

        if (jcr:contentLogLevel !== undefined) {
            localVarQueryParameters['jcr:content/logLevel'] = ObjectSerializer.serialize(jcr:contentLogLevel, "string");
        }

        if (jcr:contentNoStatusUpdate !== undefined) {
            localVarQueryParameters['jcr:content/noStatusUpdate'] = ObjectSerializer.serialize(jcr:contentNoStatusUpdate, "boolean");
        }

        if (jcr:contentNoVersioning !== undefined) {
            localVarQueryParameters['jcr:content/noVersioning'] = ObjectSerializer.serialize(jcr:contentNoVersioning, "boolean");
        }

        if (jcr:contentProtocolConnectTimeout !== undefined) {
            localVarQueryParameters['jcr:content/protocolConnectTimeout'] = ObjectSerializer.serialize(jcr:contentProtocolConnectTimeout, "number");
        }

        if (jcr:contentProtocolHTTPConnectionClosed !== undefined) {
            localVarQueryParameters['jcr:content/protocolHTTPConnectionClosed'] = ObjectSerializer.serialize(jcr:contentProtocolHTTPConnectionClosed, "boolean");
        }

        if (jcr:contentProtocolHTTPExpired !== undefined) {
            localVarQueryParameters['jcr:content/protocolHTTPExpired'] = ObjectSerializer.serialize(jcr:contentProtocolHTTPExpired, "string");
        }

        if (jcr:contentProtocolHTTPHeaders !== undefined) {
            localVarQueryParameters['jcr:content/protocolHTTPHeaders'] = ObjectSerializer.serialize(jcr:contentProtocolHTTPHeaders, "Array<string>");
        }

        if (jcr:contentProtocolHTTPHeaders@TypeHint !== undefined) {
            localVarQueryParameters['jcr:content/protocolHTTPHeaders@TypeHint'] = ObjectSerializer.serialize(jcr:contentProtocolHTTPHeaders@TypeHint, "string");
        }

        if (jcr:contentProtocolHTTPMethod !== undefined) {
            localVarQueryParameters['jcr:content/protocolHTTPMethod'] = ObjectSerializer.serialize(jcr:contentProtocolHTTPMethod, "string");
        }

        if (jcr:contentProtocolHTTPSRelaxed !== undefined) {
            localVarQueryParameters['jcr:content/protocolHTTPSRelaxed'] = ObjectSerializer.serialize(jcr:contentProtocolHTTPSRelaxed, "boolean");
        }

        if (jcr:contentProtocolInterface !== undefined) {
            localVarQueryParameters['jcr:content/protocolInterface'] = ObjectSerializer.serialize(jcr:contentProtocolInterface, "string");
        }

        if (jcr:contentProtocolSocketTimeout !== undefined) {
            localVarQueryParameters['jcr:content/protocolSocketTimeout'] = ObjectSerializer.serialize(jcr:contentProtocolSocketTimeout, "number");
        }

        if (jcr:contentProtocolVersion !== undefined) {
            localVarQueryParameters['jcr:content/protocolVersion'] = ObjectSerializer.serialize(jcr:contentProtocolVersion, "string");
        }

        if (jcr:contentProxyNTLMDomain !== undefined) {
            localVarQueryParameters['jcr:content/proxyNTLMDomain'] = ObjectSerializer.serialize(jcr:contentProxyNTLMDomain, "string");
        }

        if (jcr:contentProxyNTLMHost !== undefined) {
            localVarQueryParameters['jcr:content/proxyNTLMHost'] = ObjectSerializer.serialize(jcr:contentProxyNTLMHost, "string");
        }

        if (jcr:contentProxyHost !== undefined) {
            localVarQueryParameters['jcr:content/proxyHost'] = ObjectSerializer.serialize(jcr:contentProxyHost, "string");
        }

        if (jcr:contentProxyPassword !== undefined) {
            localVarQueryParameters['jcr:content/proxyPassword'] = ObjectSerializer.serialize(jcr:contentProxyPassword, "string");
        }

        if (jcr:contentProxyPort !== undefined) {
            localVarQueryParameters['jcr:content/proxyPort'] = ObjectSerializer.serialize(jcr:contentProxyPort, "number");
        }

        if (jcr:contentProxyUser !== undefined) {
            localVarQueryParameters['jcr:content/proxyUser'] = ObjectSerializer.serialize(jcr:contentProxyUser, "string");
        }

        if (jcr:contentQueueBatchMaxSize !== undefined) {
            localVarQueryParameters['jcr:content/queueBatchMaxSize'] = ObjectSerializer.serialize(jcr:contentQueueBatchMaxSize, "number");
        }

        if (jcr:contentQueueBatchMode !== undefined) {
            localVarQueryParameters['jcr:content/queueBatchMode'] = ObjectSerializer.serialize(jcr:contentQueueBatchMode, "string");
        }

        if (jcr:contentQueueBatchWaitTime !== undefined) {
            localVarQueryParameters['jcr:content/queueBatchWaitTime'] = ObjectSerializer.serialize(jcr:contentQueueBatchWaitTime, "number");
        }

        if (jcr:contentRetryDelay !== undefined) {
            localVarQueryParameters['jcr:content/retryDelay'] = ObjectSerializer.serialize(jcr:contentRetryDelay, "string");
        }

        if (jcr:contentReverseReplication !== undefined) {
            localVarQueryParameters['jcr:content/reverseReplication'] = ObjectSerializer.serialize(jcr:contentReverseReplication, "boolean");
        }

        if (jcr:contentSerializationType !== undefined) {
            localVarQueryParameters['jcr:content/serializationType'] = ObjectSerializer.serialize(jcr:contentSerializationType, "string");
        }

        if (jcr:contentSling:resourceType !== undefined) {
            localVarQueryParameters['jcr:content/sling:resourceType'] = ObjectSerializer.serialize(jcr:contentSling:resourceType, "string");
        }

        if (jcr:contentSsl !== undefined) {
            localVarQueryParameters['jcr:content/ssl'] = ObjectSerializer.serialize(jcr:contentSsl, "string");
        }

        if (jcr:contentTransportNTLMDomain !== undefined) {
            localVarQueryParameters['jcr:content/transportNTLMDomain'] = ObjectSerializer.serialize(jcr:contentTransportNTLMDomain, "string");
        }

        if (jcr:contentTransportNTLMHost !== undefined) {
            localVarQueryParameters['jcr:content/transportNTLMHost'] = ObjectSerializer.serialize(jcr:contentTransportNTLMHost, "string");
        }

        if (jcr:contentTransportPassword !== undefined) {
            localVarQueryParameters['jcr:content/transportPassword'] = ObjectSerializer.serialize(jcr:contentTransportPassword, "string");
        }

        if (jcr:contentTransportUri !== undefined) {
            localVarQueryParameters['jcr:content/transportUri'] = ObjectSerializer.serialize(jcr:contentTransportUri, "string");
        }

        if (jcr:contentTransportUser !== undefined) {
            localVarQueryParameters['jcr:content/transportUser'] = ObjectSerializer.serialize(jcr:contentTransportUser, "string");
        }

        if (jcr:contentTriggerDistribute !== undefined) {
            localVarQueryParameters['jcr:content/triggerDistribute'] = ObjectSerializer.serialize(jcr:contentTriggerDistribute, "boolean");
        }

        if (jcr:contentTriggerModified !== undefined) {
            localVarQueryParameters['jcr:content/triggerModified'] = ObjectSerializer.serialize(jcr:contentTriggerModified, "boolean");
        }

        if (jcr:contentTriggerOnOffTime !== undefined) {
            localVarQueryParameters['jcr:content/triggerOnOffTime'] = ObjectSerializer.serialize(jcr:contentTriggerOnOffTime, "boolean");
        }

        if (jcr:contentTriggerReceive !== undefined) {
            localVarQueryParameters['jcr:content/triggerReceive'] = ObjectSerializer.serialize(jcr:contentTriggerReceive, "boolean");
        }

        if (jcr:contentTriggerSpecific !== undefined) {
            localVarQueryParameters['jcr:content/triggerSpecific'] = ObjectSerializer.serialize(jcr:contentTriggerSpecific, "boolean");
        }

        if (jcr:contentUserId !== undefined) {
            localVarQueryParameters['jcr:content/userId'] = ObjectSerializer.serialize(jcr:contentUserId, "string");
        }

        if (jcr:primaryType !== undefined) {
            localVarQueryParameters['jcr:primaryType'] = ObjectSerializer.serialize(jcr:primaryType, "string");
        }

        if (:operation !== undefined) {
            localVarQueryParameters[':operation'] = ObjectSerializer.serialize(:operation, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     * @param :operation 
     * @param currentPassword 
     * @param newPassword 
     * @param rePassword 
     * @param keyPassword 
     * @param keyStorePass 
     * @param alias 
     * @param newAlias 
     * @param removeAlias 
     * @param certChain 
     * @param pk 
     * @param keyStore 
     */
    public postAuthorizableKeystore (intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Buffer, pk?: Buffer, keyStore?: Buffer) : Promise<{ response: http.ClientResponse; body: KeystoreInfo;  }> {
        const localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}.ks.html'
            .replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath)))
            .replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizableKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizableKeystore.');
        }

        if (:operation !== undefined) {
            localVarQueryParameters[':operation'] = ObjectSerializer.serialize(:operation, "string");
        }

        if (currentPassword !== undefined) {
            localVarQueryParameters['currentPassword'] = ObjectSerializer.serialize(currentPassword, "string");
        }

        if (newPassword !== undefined) {
            localVarQueryParameters['newPassword'] = ObjectSerializer.serialize(newPassword, "string");
        }

        if (rePassword !== undefined) {
            localVarQueryParameters['rePassword'] = ObjectSerializer.serialize(rePassword, "string");
        }

        if (keyPassword !== undefined) {
            localVarQueryParameters['keyPassword'] = ObjectSerializer.serialize(keyPassword, "string");
        }

        if (keyStorePass !== undefined) {
            localVarQueryParameters['keyStorePass'] = ObjectSerializer.serialize(keyStorePass, "string");
        }

        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }

        if (newAlias !== undefined) {
            localVarQueryParameters['newAlias'] = ObjectSerializer.serialize(newAlias, "string");
        }

        if (removeAlias !== undefined) {
            localVarQueryParameters['removeAlias'] = ObjectSerializer.serialize(removeAlias, "string");
        }


        let localVarUseFormData = false;

        if (certChain !== undefined) {
            localVarFormParams['cert-chain'] = certChain;
        }
        localVarUseFormData = true;

        if (pk !== undefined) {
            localVarFormParams['pk'] = pk;
        }
        localVarUseFormData = true;

        if (keyStore !== undefined) {
            localVarFormParams['keyStore'] = keyStore;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: KeystoreInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "KeystoreInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param authorizableId 
     * @param intermediatePath 
     * @param createUser 
     * @param createGroup 
     * @param rep:password 
     * @param profileGivenName 
     */
    public postAuthorizables (authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/libs/granite/security/post/authorizables';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizables.');
        }

        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizables.');
        }

        if (authorizableId !== undefined) {
            localVarQueryParameters['authorizableId'] = ObjectSerializer.serialize(authorizableId, "string");
        }

        if (intermediatePath !== undefined) {
            localVarQueryParameters['intermediatePath'] = ObjectSerializer.serialize(intermediatePath, "string");
        }

        if (createUser !== undefined) {
            localVarQueryParameters['createUser'] = ObjectSerializer.serialize(createUser, "string");
        }

        if (createGroup !== undefined) {
            localVarQueryParameters['createGroup'] = ObjectSerializer.serialize(createGroup, "string");
        }

        if (rep:password !== undefined) {
            localVarQueryParameters['rep:password'] = ObjectSerializer.serialize(rep:password, "string");
        }

        if (profileGivenName !== undefined) {
            localVarQueryParameters['profile/givenName'] = ObjectSerializer.serialize(profileGivenName, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param keyStorePassword 
     * @param keyStorePassword@TypeHint 
     * @param serviceRanking 
     * @param serviceRanking@TypeHint 
     * @param idpHttpRedirect 
     * @param idpHttpRedirect@TypeHint 
     * @param createUser 
     * @param createUser@TypeHint 
     * @param defaultRedirectUrl 
     * @param defaultRedirectUrl@TypeHint 
     * @param userIDAttribute 
     * @param userIDAttribute@TypeHint 
     * @param defaultGroups 
     * @param defaultGroups@TypeHint 
     * @param idpCertAlias 
     * @param idpCertAlias@TypeHint 
     * @param addGroupMemberships 
     * @param addGroupMemberships@TypeHint 
     * @param path 
     * @param path@TypeHint 
     * @param synchronizeAttributes 
     * @param synchronizeAttributes@TypeHint 
     * @param clockTolerance 
     * @param clockTolerance@TypeHint 
     * @param groupMembershipAttribute 
     * @param groupMembershipAttribute@TypeHint 
     * @param idpUrl 
     * @param idpUrl@TypeHint 
     * @param logoutUrl 
     * @param logoutUrl@TypeHint 
     * @param serviceProviderEntityId 
     * @param serviceProviderEntityId@TypeHint 
     * @param assertionConsumerServiceURL 
     * @param assertionConsumerServiceURL@TypeHint 
     * @param handleLogout 
     * @param handleLogout@TypeHint 
     * @param spPrivateKeyAlias 
     * @param spPrivateKeyAlias@TypeHint 
     * @param useEncryption 
     * @param useEncryption@TypeHint 
     * @param nameIdFormat 
     * @param nameIdFormat@TypeHint 
     * @param digestMethod 
     * @param digestMethod@TypeHint 
     * @param signatureMethod 
     * @param signatureMethod@TypeHint 
     * @param userIntermediatePath 
     * @param userIntermediatePath@TypeHint 
     */
    public postConfigAdobeGraniteSamlAuthenticationHandler (keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (keyStorePassword !== undefined) {
            localVarQueryParameters['keyStorePassword'] = ObjectSerializer.serialize(keyStorePassword, "string");
        }

        if (keyStorePassword@TypeHint !== undefined) {
            localVarQueryParameters['keyStorePassword@TypeHint'] = ObjectSerializer.serialize(keyStorePassword@TypeHint, "string");
        }

        if (serviceRanking !== undefined) {
            localVarQueryParameters['service.ranking'] = ObjectSerializer.serialize(serviceRanking, "number");
        }

        if (serviceRanking@TypeHint !== undefined) {
            localVarQueryParameters['service.ranking@TypeHint'] = ObjectSerializer.serialize(serviceRanking@TypeHint, "string");
        }

        if (idpHttpRedirect !== undefined) {
            localVarQueryParameters['idpHttpRedirect'] = ObjectSerializer.serialize(idpHttpRedirect, "boolean");
        }

        if (idpHttpRedirect@TypeHint !== undefined) {
            localVarQueryParameters['idpHttpRedirect@TypeHint'] = ObjectSerializer.serialize(idpHttpRedirect@TypeHint, "string");
        }

        if (createUser !== undefined) {
            localVarQueryParameters['createUser'] = ObjectSerializer.serialize(createUser, "boolean");
        }

        if (createUser@TypeHint !== undefined) {
            localVarQueryParameters['createUser@TypeHint'] = ObjectSerializer.serialize(createUser@TypeHint, "string");
        }

        if (defaultRedirectUrl !== undefined) {
            localVarQueryParameters['defaultRedirectUrl'] = ObjectSerializer.serialize(defaultRedirectUrl, "string");
        }

        if (defaultRedirectUrl@TypeHint !== undefined) {
            localVarQueryParameters['defaultRedirectUrl@TypeHint'] = ObjectSerializer.serialize(defaultRedirectUrl@TypeHint, "string");
        }

        if (userIDAttribute !== undefined) {
            localVarQueryParameters['userIDAttribute'] = ObjectSerializer.serialize(userIDAttribute, "string");
        }

        if (userIDAttribute@TypeHint !== undefined) {
            localVarQueryParameters['userIDAttribute@TypeHint'] = ObjectSerializer.serialize(userIDAttribute@TypeHint, "string");
        }

        if (defaultGroups !== undefined) {
            localVarQueryParameters['defaultGroups'] = ObjectSerializer.serialize(defaultGroups, "Array<string>");
        }

        if (defaultGroups@TypeHint !== undefined) {
            localVarQueryParameters['defaultGroups@TypeHint'] = ObjectSerializer.serialize(defaultGroups@TypeHint, "string");
        }

        if (idpCertAlias !== undefined) {
            localVarQueryParameters['idpCertAlias'] = ObjectSerializer.serialize(idpCertAlias, "string");
        }

        if (idpCertAlias@TypeHint !== undefined) {
            localVarQueryParameters['idpCertAlias@TypeHint'] = ObjectSerializer.serialize(idpCertAlias@TypeHint, "string");
        }

        if (addGroupMemberships !== undefined) {
            localVarQueryParameters['addGroupMemberships'] = ObjectSerializer.serialize(addGroupMemberships, "boolean");
        }

        if (addGroupMemberships@TypeHint !== undefined) {
            localVarQueryParameters['addGroupMemberships@TypeHint'] = ObjectSerializer.serialize(addGroupMemberships@TypeHint, "string");
        }

        if (path !== undefined) {
            localVarQueryParameters['path'] = ObjectSerializer.serialize(path, "Array<string>");
        }

        if (path@TypeHint !== undefined) {
            localVarQueryParameters['path@TypeHint'] = ObjectSerializer.serialize(path@TypeHint, "string");
        }

        if (synchronizeAttributes !== undefined) {
            localVarQueryParameters['synchronizeAttributes'] = ObjectSerializer.serialize(synchronizeAttributes, "Array<string>");
        }

        if (synchronizeAttributes@TypeHint !== undefined) {
            localVarQueryParameters['synchronizeAttributes@TypeHint'] = ObjectSerializer.serialize(synchronizeAttributes@TypeHint, "string");
        }

        if (clockTolerance !== undefined) {
            localVarQueryParameters['clockTolerance'] = ObjectSerializer.serialize(clockTolerance, "number");
        }

        if (clockTolerance@TypeHint !== undefined) {
            localVarQueryParameters['clockTolerance@TypeHint'] = ObjectSerializer.serialize(clockTolerance@TypeHint, "string");
        }

        if (groupMembershipAttribute !== undefined) {
            localVarQueryParameters['groupMembershipAttribute'] = ObjectSerializer.serialize(groupMembershipAttribute, "string");
        }

        if (groupMembershipAttribute@TypeHint !== undefined) {
            localVarQueryParameters['groupMembershipAttribute@TypeHint'] = ObjectSerializer.serialize(groupMembershipAttribute@TypeHint, "string");
        }

        if (idpUrl !== undefined) {
            localVarQueryParameters['idpUrl'] = ObjectSerializer.serialize(idpUrl, "string");
        }

        if (idpUrl@TypeHint !== undefined) {
            localVarQueryParameters['idpUrl@TypeHint'] = ObjectSerializer.serialize(idpUrl@TypeHint, "string");
        }

        if (logoutUrl !== undefined) {
            localVarQueryParameters['logoutUrl'] = ObjectSerializer.serialize(logoutUrl, "string");
        }

        if (logoutUrl@TypeHint !== undefined) {
            localVarQueryParameters['logoutUrl@TypeHint'] = ObjectSerializer.serialize(logoutUrl@TypeHint, "string");
        }

        if (serviceProviderEntityId !== undefined) {
            localVarQueryParameters['serviceProviderEntityId'] = ObjectSerializer.serialize(serviceProviderEntityId, "string");
        }

        if (serviceProviderEntityId@TypeHint !== undefined) {
            localVarQueryParameters['serviceProviderEntityId@TypeHint'] = ObjectSerializer.serialize(serviceProviderEntityId@TypeHint, "string");
        }

        if (assertionConsumerServiceURL !== undefined) {
            localVarQueryParameters['assertionConsumerServiceURL'] = ObjectSerializer.serialize(assertionConsumerServiceURL, "string");
        }

        if (assertionConsumerServiceURL@TypeHint !== undefined) {
            localVarQueryParameters['assertionConsumerServiceURL@TypeHint'] = ObjectSerializer.serialize(assertionConsumerServiceURL@TypeHint, "string");
        }

        if (handleLogout !== undefined) {
            localVarQueryParameters['handleLogout'] = ObjectSerializer.serialize(handleLogout, "boolean");
        }

        if (handleLogout@TypeHint !== undefined) {
            localVarQueryParameters['handleLogout@TypeHint'] = ObjectSerializer.serialize(handleLogout@TypeHint, "string");
        }

        if (spPrivateKeyAlias !== undefined) {
            localVarQueryParameters['spPrivateKeyAlias'] = ObjectSerializer.serialize(spPrivateKeyAlias, "string");
        }

        if (spPrivateKeyAlias@TypeHint !== undefined) {
            localVarQueryParameters['spPrivateKeyAlias@TypeHint'] = ObjectSerializer.serialize(spPrivateKeyAlias@TypeHint, "string");
        }

        if (useEncryption !== undefined) {
            localVarQueryParameters['useEncryption'] = ObjectSerializer.serialize(useEncryption, "boolean");
        }

        if (useEncryption@TypeHint !== undefined) {
            localVarQueryParameters['useEncryption@TypeHint'] = ObjectSerializer.serialize(useEncryption@TypeHint, "string");
        }

        if (nameIdFormat !== undefined) {
            localVarQueryParameters['nameIdFormat'] = ObjectSerializer.serialize(nameIdFormat, "string");
        }

        if (nameIdFormat@TypeHint !== undefined) {
            localVarQueryParameters['nameIdFormat@TypeHint'] = ObjectSerializer.serialize(nameIdFormat@TypeHint, "string");
        }

        if (digestMethod !== undefined) {
            localVarQueryParameters['digestMethod'] = ObjectSerializer.serialize(digestMethod, "string");
        }

        if (digestMethod@TypeHint !== undefined) {
            localVarQueryParameters['digestMethod@TypeHint'] = ObjectSerializer.serialize(digestMethod@TypeHint, "string");
        }

        if (signatureMethod !== undefined) {
            localVarQueryParameters['signatureMethod'] = ObjectSerializer.serialize(signatureMethod, "string");
        }

        if (signatureMethod@TypeHint !== undefined) {
            localVarQueryParameters['signatureMethod@TypeHint'] = ObjectSerializer.serialize(signatureMethod@TypeHint, "string");
        }

        if (userIntermediatePath !== undefined) {
            localVarQueryParameters['userIntermediatePath'] = ObjectSerializer.serialize(userIntermediatePath, "string");
        }

        if (userIntermediatePath@TypeHint !== undefined) {
            localVarQueryParameters['userIntermediatePath@TypeHint'] = ObjectSerializer.serialize(userIntermediatePath@TypeHint, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param orgApacheFelixHttpsNio 
     * @param orgApacheFelixHttpsNio@TypeHint 
     * @param orgApacheFelixHttpsKeystore 
     * @param orgApacheFelixHttpsKeystore@TypeHint 
     * @param orgApacheFelixHttpsKeystorePassword 
     * @param orgApacheFelixHttpsKeystorePassword@TypeHint 
     * @param orgApacheFelixHttpsKeystoreKey 
     * @param orgApacheFelixHttpsKeystoreKey@TypeHint 
     * @param orgApacheFelixHttpsKeystoreKeyPassword 
     * @param orgApacheFelixHttpsKeystoreKeyPassword@TypeHint 
     * @param orgApacheFelixHttpsTruststore 
     * @param orgApacheFelixHttpsTruststore@TypeHint 
     * @param orgApacheFelixHttpsTruststorePassword 
     * @param orgApacheFelixHttpsTruststorePassword@TypeHint 
     * @param orgApacheFelixHttpsClientcertificate 
     * @param orgApacheFelixHttpsClientcertificate@TypeHint 
     * @param orgApacheFelixHttpsEnable 
     * @param orgApacheFelixHttpsEnable@TypeHint 
     * @param orgOsgiServiceHttpPortSecure 
     * @param orgOsgiServiceHttpPortSecure@TypeHint 
     */
    public postConfigApacheFelixJettyBasedHttpService (orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.felix.http';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (orgApacheFelixHttpsNio !== undefined) {
            localVarQueryParameters['org.apache.felix.https.nio'] = ObjectSerializer.serialize(orgApacheFelixHttpsNio, "boolean");
        }

        if (orgApacheFelixHttpsNio@TypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.nio@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsNio@TypeHint, "string");
        }

        if (orgApacheFelixHttpsKeystore !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystore, "string");
        }

        if (orgApacheFelixHttpsKeystore@TypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystore@TypeHint, "string");
        }

        if (orgApacheFelixHttpsKeystorePassword !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore.password'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystorePassword, "string");
        }

        if (orgApacheFelixHttpsKeystorePassword@TypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore.password@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystorePassword@TypeHint, "string");
        }

        if (orgApacheFelixHttpsKeystoreKey !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore.key'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystoreKey, "string");
        }

        if (orgApacheFelixHttpsKeystoreKey@TypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore.key@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystoreKey@TypeHint, "string");
        }

        if (orgApacheFelixHttpsKeystoreKeyPassword !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore.key.password'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystoreKeyPassword, "string");
        }

        if (orgApacheFelixHttpsKeystoreKeyPassword@TypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore.key.password@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystoreKeyPassword@TypeHint, "string");
        }

        if (orgApacheFelixHttpsTruststore !== undefined) {
            localVarQueryParameters['org.apache.felix.https.truststore'] = ObjectSerializer.serialize(orgApacheFelixHttpsTruststore, "string");
        }

        if (orgApacheFelixHttpsTruststore@TypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.truststore@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsTruststore@TypeHint, "string");
        }

        if (orgApacheFelixHttpsTruststorePassword !== undefined) {
            localVarQueryParameters['org.apache.felix.https.truststore.password'] = ObjectSerializer.serialize(orgApacheFelixHttpsTruststorePassword, "string");
        }

        if (orgApacheFelixHttpsTruststorePassword@TypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.truststore.password@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsTruststorePassword@TypeHint, "string");
        }

        if (orgApacheFelixHttpsClientcertificate !== undefined) {
            localVarQueryParameters['org.apache.felix.https.clientcertificate'] = ObjectSerializer.serialize(orgApacheFelixHttpsClientcertificate, "string");
        }

        if (orgApacheFelixHttpsClientcertificate@TypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.clientcertificate@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsClientcertificate@TypeHint, "string");
        }

        if (orgApacheFelixHttpsEnable !== undefined) {
            localVarQueryParameters['org.apache.felix.https.enable'] = ObjectSerializer.serialize(orgApacheFelixHttpsEnable, "boolean");
        }

        if (orgApacheFelixHttpsEnable@TypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.enable@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsEnable@TypeHint, "string");
        }

        if (orgOsgiServiceHttpPortSecure !== undefined) {
            localVarQueryParameters['org.osgi.service.http.port.secure'] = ObjectSerializer.serialize(orgOsgiServiceHttpPortSecure, "string");
        }

        if (orgOsgiServiceHttpPortSecure@TypeHint !== undefined) {
            localVarQueryParameters['org.osgi.service.http.port.secure@TypeHint'] = ObjectSerializer.serialize(orgOsgiServiceHttpPortSecure@TypeHint, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param proxyHost 
     * @param proxyHost@TypeHint 
     * @param proxyPort 
     * @param proxyPort@TypeHint 
     * @param proxyExceptions 
     * @param proxyExceptions@TypeHint 
     * @param proxyEnabled 
     * @param proxyEnabled@TypeHint 
     * @param proxyUser 
     * @param proxyUser@TypeHint 
     * @param proxyPassword 
     * @param proxyPassword@TypeHint 
     */
    public postConfigApacheHttpComponentsProxyConfiguration (proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.http.proxyconfigurator.config';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (proxyHost !== undefined) {
            localVarQueryParameters['proxy.host'] = ObjectSerializer.serialize(proxyHost, "string");
        }

        if (proxyHost@TypeHint !== undefined) {
            localVarQueryParameters['proxy.host@TypeHint'] = ObjectSerializer.serialize(proxyHost@TypeHint, "string");
        }

        if (proxyPort !== undefined) {
            localVarQueryParameters['proxy.port'] = ObjectSerializer.serialize(proxyPort, "number");
        }

        if (proxyPort@TypeHint !== undefined) {
            localVarQueryParameters['proxy.port@TypeHint'] = ObjectSerializer.serialize(proxyPort@TypeHint, "string");
        }

        if (proxyExceptions !== undefined) {
            localVarQueryParameters['proxy.exceptions'] = ObjectSerializer.serialize(proxyExceptions, "Array<string>");
        }

        if (proxyExceptions@TypeHint !== undefined) {
            localVarQueryParameters['proxy.exceptions@TypeHint'] = ObjectSerializer.serialize(proxyExceptions@TypeHint, "string");
        }

        if (proxyEnabled !== undefined) {
            localVarQueryParameters['proxy.enabled'] = ObjectSerializer.serialize(proxyEnabled, "boolean");
        }

        if (proxyEnabled@TypeHint !== undefined) {
            localVarQueryParameters['proxy.enabled@TypeHint'] = ObjectSerializer.serialize(proxyEnabled@TypeHint, "string");
        }

        if (proxyUser !== undefined) {
            localVarQueryParameters['proxy.user'] = ObjectSerializer.serialize(proxyUser, "string");
        }

        if (proxyUser@TypeHint !== undefined) {
            localVarQueryParameters['proxy.user@TypeHint'] = ObjectSerializer.serialize(proxyUser@TypeHint, "string");
        }

        if (proxyPassword !== undefined) {
            localVarQueryParameters['proxy.password'] = ObjectSerializer.serialize(proxyPassword, "string");
        }

        if (proxyPassword@TypeHint !== undefined) {
            localVarQueryParameters['proxy.password@TypeHint'] = ObjectSerializer.serialize(proxyPassword@TypeHint, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param alias 
     * @param alias@TypeHint 
     * @param davCreateAbsoluteUri 
     * @param davCreateAbsoluteUri@TypeHint 
     */
    public postConfigApacheSlingDavExServlet (alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }

        if (alias@TypeHint !== undefined) {
            localVarQueryParameters['alias@TypeHint'] = ObjectSerializer.serialize(alias@TypeHint, "string");
        }

        if (davCreateAbsoluteUri !== undefined) {
            localVarQueryParameters['dav.create-absolute-uri'] = ObjectSerializer.serialize(davCreateAbsoluteUri, "boolean");
        }

        if (davCreateAbsoluteUri@TypeHint !== undefined) {
            localVarQueryParameters['dav.create-absolute-uri@TypeHint'] = ObjectSerializer.serialize(davCreateAbsoluteUri@TypeHint, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param jsonMaximumresults 
     * @param jsonMaximumresults@TypeHint 
     * @param enableHtml 
     * @param enableHtml@TypeHint 
     * @param enableTxt 
     * @param enableTxt@TypeHint 
     * @param enableXml 
     * @param enableXml@TypeHint 
     */
    public postConfigApacheSlingGetServlet (jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (jsonMaximumresults !== undefined) {
            localVarQueryParameters['json.maximumresults'] = ObjectSerializer.serialize(jsonMaximumresults, "string");
        }

        if (jsonMaximumresults@TypeHint !== undefined) {
            localVarQueryParameters['json.maximumresults@TypeHint'] = ObjectSerializer.serialize(jsonMaximumresults@TypeHint, "string");
        }

        if (enableHtml !== undefined) {
            localVarQueryParameters['enable.html'] = ObjectSerializer.serialize(enableHtml, "boolean");
        }

        if (enableHtml@TypeHint !== undefined) {
            localVarQueryParameters['enable.html@TypeHint'] = ObjectSerializer.serialize(enableHtml@TypeHint, "string");
        }

        if (enableTxt !== undefined) {
            localVarQueryParameters['enable.txt'] = ObjectSerializer.serialize(enableTxt, "boolean");
        }

        if (enableTxt@TypeHint !== undefined) {
            localVarQueryParameters['enable.txt@TypeHint'] = ObjectSerializer.serialize(enableTxt@TypeHint, "string");
        }

        if (enableXml !== undefined) {
            localVarQueryParameters['enable.xml'] = ObjectSerializer.serialize(enableXml, "boolean");
        }

        if (enableXml@TypeHint !== undefined) {
            localVarQueryParameters['enable.xml@TypeHint'] = ObjectSerializer.serialize(enableXml@TypeHint, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param allowEmpty 
     * @param allowEmpty@TypeHint 
     * @param allowHosts 
     * @param allowHosts@TypeHint 
     * @param allowHostsRegexp 
     * @param allowHostsRegexp@TypeHint 
     * @param filterMethods 
     * @param filterMethods@TypeHint 
     */
    public postConfigApacheSlingReferrerFilter (allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.sling.security.impl.ReferrerFilter';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (allowEmpty !== undefined) {
            localVarQueryParameters['allow.empty'] = ObjectSerializer.serialize(allowEmpty, "boolean");
        }

        if (allowEmpty@TypeHint !== undefined) {
            localVarQueryParameters['allow.empty@TypeHint'] = ObjectSerializer.serialize(allowEmpty@TypeHint, "string");
        }

        if (allowHosts !== undefined) {
            localVarQueryParameters['allow.hosts'] = ObjectSerializer.serialize(allowHosts, "string");
        }

        if (allowHosts@TypeHint !== undefined) {
            localVarQueryParameters['allow.hosts@TypeHint'] = ObjectSerializer.serialize(allowHosts@TypeHint, "string");
        }

        if (allowHostsRegexp !== undefined) {
            localVarQueryParameters['allow.hosts.regexp'] = ObjectSerializer.serialize(allowHostsRegexp, "string");
        }

        if (allowHostsRegexp@TypeHint !== undefined) {
            localVarQueryParameters['allow.hosts.regexp@TypeHint'] = ObjectSerializer.serialize(allowHostsRegexp@TypeHint, "string");
        }

        if (filterMethods !== undefined) {
            localVarQueryParameters['filter.methods'] = ObjectSerializer.serialize(filterMethods, "string");
        }

        if (filterMethods@TypeHint !== undefined) {
            localVarQueryParameters['filter.methods@TypeHint'] = ObjectSerializer.serialize(filterMethods@TypeHint, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param path 
     * @param name 
     * @param :operation 
     * @param deleteAuthorizable 
     * @param file 
     */
    public postNode (path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: Buffer) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/{path}/{name}'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postNode.');
        }

        if (:operation !== undefined) {
            localVarQueryParameters[':operation'] = ObjectSerializer.serialize(:operation, "string");
        }

        if (deleteAuthorizable !== undefined) {
            localVarQueryParameters['deleteAuthorizable'] = ObjectSerializer.serialize(deleteAuthorizable, "string");
        }


        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param path 
     * @param name 
     * @param addMembers 
     */
    public postNodeRw (path: string, name: string, addMembers?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/{path}/{name}.rw.html'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postNodeRw.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postNodeRw.');
        }

        if (addMembers !== undefined) {
            localVarQueryParameters['addMembers'] = ObjectSerializer.serialize(addMembers, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param path 
     * @param jcr:primaryType 
     * @param :name 
     */
    public postPath (path: string, jcr:primaryType: string, :name: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/{path}/'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postPath.');
        }

        // verify required parameter 'jcr:primaryType' is not null or undefined
        if (jcr:primaryType === null || jcr:primaryType === undefined) {
            throw new Error('Required parameter jcr:primaryType was null or undefined when calling postPath.');
        }

        // verify required parameter ':name' is not null or undefined
        if (:name === null || :name === undefined) {
            throw new Error('Required parameter :name was null or undefined when calling postPath.');
        }

        if (jcr:primaryType !== undefined) {
            localVarQueryParameters['jcr:primaryType'] = ObjectSerializer.serialize(jcr:primaryType, "string");
        }

        if (:name !== undefined) {
            localVarQueryParameters[':name'] = ObjectSerializer.serialize(:name, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     */
    public postQuery (path: string, pLimit: number, _1property: string, _1propertyValue: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/bin/querybuilder.json';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postQuery.');
        }

        // verify required parameter 'pLimit' is not null or undefined
        if (pLimit === null || pLimit === undefined) {
            throw new Error('Required parameter pLimit was null or undefined when calling postQuery.');
        }

        // verify required parameter '_1property' is not null or undefined
        if (_1property === null || _1property === undefined) {
            throw new Error('Required parameter _1property was null or undefined when calling postQuery.');
        }

        // verify required parameter '_1propertyValue' is not null or undefined
        if (_1propertyValue === null || _1propertyValue === undefined) {
            throw new Error('Required parameter _1propertyValue was null or undefined when calling postQuery.');
        }

        if (path !== undefined) {
            localVarQueryParameters['path'] = ObjectSerializer.serialize(path, "string");
        }

        if (pLimit !== undefined) {
            localVarQueryParameters['p.limit'] = ObjectSerializer.serialize(pLimit, "number");
        }

        if (_1property !== undefined) {
            localVarQueryParameters['1_property'] = ObjectSerializer.serialize(_1property, "string");
        }

        if (_1propertyValue !== undefined) {
            localVarQueryParameters['1_property.value'] = ObjectSerializer.serialize(_1propertyValue, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param ignoredeactivated 
     * @param onlymodified 
     * @param path 
     */
    public postTreeActivation (ignoredeactivated: boolean, onlymodified: boolean, path: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/etc/replication/treeactivation.html';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ignoredeactivated' is not null or undefined
        if (ignoredeactivated === null || ignoredeactivated === undefined) {
            throw new Error('Required parameter ignoredeactivated was null or undefined when calling postTreeActivation.');
        }

        // verify required parameter 'onlymodified' is not null or undefined
        if (onlymodified === null || onlymodified === undefined) {
            throw new Error('Required parameter onlymodified was null or undefined when calling postTreeActivation.');
        }

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postTreeActivation.');
        }

        if (ignoredeactivated !== undefined) {
            localVarQueryParameters['ignoredeactivated'] = ObjectSerializer.serialize(ignoredeactivated, "boolean");
        }

        if (onlymodified !== undefined) {
            localVarQueryParameters['onlymodified'] = ObjectSerializer.serialize(onlymodified, "boolean");
        }

        if (path !== undefined) {
            localVarQueryParameters['path'] = ObjectSerializer.serialize(path, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param :operation 
     * @param newPassword 
     * @param rePassword 
     * @param keyStoreType 
     * @param removeAlias 
     * @param certificate 
     */
    public postTruststore (:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Buffer) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/libs/granite/security/post/truststore';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (:operation !== undefined) {
            localVarQueryParameters[':operation'] = ObjectSerializer.serialize(:operation, "string");
        }

        if (newPassword !== undefined) {
            localVarQueryParameters['newPassword'] = ObjectSerializer.serialize(newPassword, "string");
        }

        if (rePassword !== undefined) {
            localVarQueryParameters['rePassword'] = ObjectSerializer.serialize(rePassword, "string");
        }

        if (keyStoreType !== undefined) {
            localVarQueryParameters['keyStoreType'] = ObjectSerializer.serialize(keyStoreType, "string");
        }

        if (removeAlias !== undefined) {
            localVarQueryParameters['removeAlias'] = ObjectSerializer.serialize(removeAlias, "string");
        }


        let localVarUseFormData = false;

        if (certificate !== undefined) {
            localVarFormParams['certificate'] = certificate;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param truststoreP12 
     */
    public postTruststorePKCS12 (truststoreP12?: Buffer) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/etc/truststore';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        if (truststoreP12 !== undefined) {
            localVarFormParams['truststore.p12'] = truststoreP12;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.aemAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
