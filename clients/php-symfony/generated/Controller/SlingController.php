<?php

/**
 * SlingController
 * PHP version 5
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */

/**
 * Adobe Experience Manager (AEM) API
 *
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * OpenAPI spec version: 3.2.0-pre.0
 * Contact: opensource@shinesolutions.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 *
 */

/**
 * NOTE: This class is auto generated by the openapi generator program.
 * https://github.com/openapitools/openapi-generator
 * Do not edit the class manually.
 */

namespace OpenAPI\Server\Controller;

use \Exception;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\HttpException;
use Symfony\Component\Validator\Constraints as Assert;
use OpenAPI\Server\Api\SlingApiInterface;
use OpenAPI\Server\Model\KeystoreInfo;
use OpenAPI\Server\Model\TruststoreInfo;

/**
 * SlingController Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */
class SlingController extends Controller
{

    /**
     * Operation deleteAgent
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function deleteAgentAction(Request $request, $runmode, $name)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $runmode = $this->deserialize($runmode, 'string', 'string');
        $name = $this->deserialize($name, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($runmode, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->deleteAgent($runmode, $name, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation deleteNode
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function deleteNodeAction(Request $request, $path, $name)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $path = $this->deserialize($path, 'string', 'string');
        $name = $this->deserialize($name, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->deleteNode($path, $name, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getAgent
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getAgentAction(Request $request, $runmode, $name)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $runmode = $this->deserialize($runmode, 'string', 'string');
        $name = $this->deserialize($name, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($runmode, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->getAgent($runmode, $name, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getAgents
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getAgentsAction(Request $request, $runmode)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $runmode = $this->deserialize($runmode, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($runmode, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getAgents($runmode, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getAuthorizableKeystore
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getAuthorizableKeystoreAction(Request $request, $intermediatePath, $authorizableId)
    {
        // Figure out what data format to return to the client
        $produces = ['text/plain'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $intermediatePath = $this->deserialize($intermediatePath, 'string', 'string');
        $authorizableId = $this->deserialize($authorizableId, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($intermediatePath, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($authorizableId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getAuthorizableKeystore($intermediatePath, $authorizableId, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Retrieved Authorizable Keystore info';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Retrieved Authorizable Keystore info';
                    break;
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getKeystore
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getKeystoreAction(Request $request, $intermediatePath, $authorizableId)
    {
        // Figure out what data format to return to the client
        $produces = ['application/octet-stream'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $intermediatePath = $this->deserialize($intermediatePath, 'string', 'string');
        $authorizableId = $this->deserialize($authorizableId, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($intermediatePath, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($authorizableId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getKeystore($intermediatePath, $authorizableId, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getNode
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getNodeAction(Request $request, $path, $name)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $path = $this->deserialize($path, 'string', 'string');
        $name = $this->deserialize($name, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->getNode($path, $name, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getPackage
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getPackageAction(Request $request, $group, $name, $version)
    {
        // Figure out what data format to return to the client
        $produces = ['application/octet-stream'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $group = $this->deserialize($group, 'string', 'string');
        $name = $this->deserialize($name, 'string', 'string');
        $version = $this->deserialize($version, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($group, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($version, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getPackage($group, $name, $version, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getPackageFilter
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getPackageFilterAction(Request $request, $group, $name, $version)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $group = $this->deserialize($group, 'string', 'string');
        $name = $this->deserialize($name, 'string', 'string');
        $version = $this->deserialize($version, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($group, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($version, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getPackageFilter($group, $name, $version, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getQuery
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getQueryAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $path = $request->query->get('path');
        $pLimit = $request->query->get('pLimit');
        $_1property = $request->query->get('_1property');
        $_1propertyValue = $request->query->get('_1propertyValue');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $path = $this->deserialize($path, 'string', 'string');
        $pLimit = $this->deserialize($pLimit, 'float', 'string');
        $_1property = $this->deserialize($_1property, 'string', 'string');
        $_1propertyValue = $this->deserialize($_1propertyValue, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($pLimit, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($_1property, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($_1propertyValue, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getQuery($path, $pLimit, $_1property, $_1propertyValue, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getTruststore
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getTruststoreAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/octet-stream'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getTruststore($responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getTruststoreInfo
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getTruststoreInfoAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getTruststoreInfo($responseCode, $responseHeaders);

            // Find default response message
            $message = 'Retrieved AEM Truststore info';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Retrieved AEM Truststore info';
                    break;
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postAgent
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postAgentAction(Request $request, $runmode, $name)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $jcrcontentcqdistribute = $request->query->get('jcrcontentcqdistribute');
        $jcrcontentcqdistributeTypeHint = $request->query->get('jcrcontentcqdistributeTypeHint');
        $jcrcontentcqname = $request->query->get('jcrcontentcqname');
        $jcrcontentcqtemplate = $request->query->get('jcrcontentcqtemplate');
        $jcrcontentenabled = $request->query->get('jcrcontentenabled');
        $jcrcontentjcrdescription = $request->query->get('jcrcontentjcrdescription');
        $jcrcontentjcrlastModified = $request->query->get('jcrcontentjcrlastModified');
        $jcrcontentjcrlastModifiedBy = $request->query->get('jcrcontentjcrlastModifiedBy');
        $jcrcontentjcrmixinTypes = $request->query->get('jcrcontentjcrmixinTypes');
        $jcrcontentjcrtitle = $request->query->get('jcrcontentjcrtitle');
        $jcrcontentlogLevel = $request->query->get('jcrcontentlogLevel');
        $jcrcontentnoStatusUpdate = $request->query->get('jcrcontentnoStatusUpdate');
        $jcrcontentnoVersioning = $request->query->get('jcrcontentnoVersioning');
        $jcrcontentprotocolConnectTimeout = $request->query->get('jcrcontentprotocolConnectTimeout');
        $jcrcontentprotocolHTTPConnectionClosed = $request->query->get('jcrcontentprotocolHTTPConnectionClosed');
        $jcrcontentprotocolHTTPExpired = $request->query->get('jcrcontentprotocolHTTPExpired');
        $jcrcontentprotocolHTTPHeaders = $request->query->get('jcrcontentprotocolHTTPHeaders');
        $jcrcontentprotocolHTTPHeadersTypeHint = $request->query->get('jcrcontentprotocolHTTPHeadersTypeHint');
        $jcrcontentprotocolHTTPMethod = $request->query->get('jcrcontentprotocolHTTPMethod');
        $jcrcontentprotocolHTTPSRelaxed = $request->query->get('jcrcontentprotocolHTTPSRelaxed');
        $jcrcontentprotocolInterface = $request->query->get('jcrcontentprotocolInterface');
        $jcrcontentprotocolSocketTimeout = $request->query->get('jcrcontentprotocolSocketTimeout');
        $jcrcontentprotocolVersion = $request->query->get('jcrcontentprotocolVersion');
        $jcrcontentproxyNTLMDomain = $request->query->get('jcrcontentproxyNTLMDomain');
        $jcrcontentproxyNTLMHost = $request->query->get('jcrcontentproxyNTLMHost');
        $jcrcontentproxyHost = $request->query->get('jcrcontentproxyHost');
        $jcrcontentproxyPassword = $request->query->get('jcrcontentproxyPassword');
        $jcrcontentproxyPort = $request->query->get('jcrcontentproxyPort');
        $jcrcontentproxyUser = $request->query->get('jcrcontentproxyUser');
        $jcrcontentqueueBatchMaxSize = $request->query->get('jcrcontentqueueBatchMaxSize');
        $jcrcontentqueueBatchMode = $request->query->get('jcrcontentqueueBatchMode');
        $jcrcontentqueueBatchWaitTime = $request->query->get('jcrcontentqueueBatchWaitTime');
        $jcrcontentretryDelay = $request->query->get('jcrcontentretryDelay');
        $jcrcontentreverseReplication = $request->query->get('jcrcontentreverseReplication');
        $jcrcontentserializationType = $request->query->get('jcrcontentserializationType');
        $jcrcontentslingresourceType = $request->query->get('jcrcontentslingresourceType');
        $jcrcontentssl = $request->query->get('jcrcontentssl');
        $jcrcontenttransportNTLMDomain = $request->query->get('jcrcontenttransportNTLMDomain');
        $jcrcontenttransportNTLMHost = $request->query->get('jcrcontenttransportNTLMHost');
        $jcrcontenttransportPassword = $request->query->get('jcrcontenttransportPassword');
        $jcrcontenttransportUri = $request->query->get('jcrcontenttransportUri');
        $jcrcontenttransportUser = $request->query->get('jcrcontenttransportUser');
        $jcrcontenttriggerDistribute = $request->query->get('jcrcontenttriggerDistribute');
        $jcrcontenttriggerModified = $request->query->get('jcrcontenttriggerModified');
        $jcrcontenttriggerOnOffTime = $request->query->get('jcrcontenttriggerOnOffTime');
        $jcrcontenttriggerReceive = $request->query->get('jcrcontenttriggerReceive');
        $jcrcontenttriggerSpecific = $request->query->get('jcrcontenttriggerSpecific');
        $jcrcontentuserId = $request->query->get('jcrcontentuserId');
        $jcrprimaryType = $request->query->get('jcrprimaryType');
        $operation = $request->query->get('operation');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $runmode = $this->deserialize($runmode, 'string', 'string');
        $name = $this->deserialize($name, 'string', 'string');
        $jcrcontentcqdistribute = $this->deserialize($jcrcontentcqdistribute, 'bool', 'string');
        $jcrcontentcqdistributeTypeHint = $this->deserialize($jcrcontentcqdistributeTypeHint, 'string', 'string');
        $jcrcontentcqname = $this->deserialize($jcrcontentcqname, 'string', 'string');
        $jcrcontentcqtemplate = $this->deserialize($jcrcontentcqtemplate, 'string', 'string');
        $jcrcontentenabled = $this->deserialize($jcrcontentenabled, 'bool', 'string');
        $jcrcontentjcrdescription = $this->deserialize($jcrcontentjcrdescription, 'string', 'string');
        $jcrcontentjcrlastModified = $this->deserialize($jcrcontentjcrlastModified, 'string', 'string');
        $jcrcontentjcrlastModifiedBy = $this->deserialize($jcrcontentjcrlastModifiedBy, 'string', 'string');
        $jcrcontentjcrmixinTypes = $this->deserialize($jcrcontentjcrmixinTypes, 'string', 'string');
        $jcrcontentjcrtitle = $this->deserialize($jcrcontentjcrtitle, 'string', 'string');
        $jcrcontentlogLevel = $this->deserialize($jcrcontentlogLevel, 'string', 'string');
        $jcrcontentnoStatusUpdate = $this->deserialize($jcrcontentnoStatusUpdate, 'bool', 'string');
        $jcrcontentnoVersioning = $this->deserialize($jcrcontentnoVersioning, 'bool', 'string');
        $jcrcontentprotocolConnectTimeout = $this->deserialize($jcrcontentprotocolConnectTimeout, 'float', 'string');
        $jcrcontentprotocolHTTPConnectionClosed = $this->deserialize($jcrcontentprotocolHTTPConnectionClosed, 'bool', 'string');
        $jcrcontentprotocolHTTPExpired = $this->deserialize($jcrcontentprotocolHTTPExpired, 'string', 'string');
        $jcrcontentprotocolHTTPHeaders = $this->deserialize($jcrcontentprotocolHTTPHeaders, 'array<multi,string>', 'string');
        $jcrcontentprotocolHTTPHeadersTypeHint = $this->deserialize($jcrcontentprotocolHTTPHeadersTypeHint, 'string', 'string');
        $jcrcontentprotocolHTTPMethod = $this->deserialize($jcrcontentprotocolHTTPMethod, 'string', 'string');
        $jcrcontentprotocolHTTPSRelaxed = $this->deserialize($jcrcontentprotocolHTTPSRelaxed, 'bool', 'string');
        $jcrcontentprotocolInterface = $this->deserialize($jcrcontentprotocolInterface, 'string', 'string');
        $jcrcontentprotocolSocketTimeout = $this->deserialize($jcrcontentprotocolSocketTimeout, 'float', 'string');
        $jcrcontentprotocolVersion = $this->deserialize($jcrcontentprotocolVersion, 'string', 'string');
        $jcrcontentproxyNTLMDomain = $this->deserialize($jcrcontentproxyNTLMDomain, 'string', 'string');
        $jcrcontentproxyNTLMHost = $this->deserialize($jcrcontentproxyNTLMHost, 'string', 'string');
        $jcrcontentproxyHost = $this->deserialize($jcrcontentproxyHost, 'string', 'string');
        $jcrcontentproxyPassword = $this->deserialize($jcrcontentproxyPassword, 'string', 'string');
        $jcrcontentproxyPort = $this->deserialize($jcrcontentproxyPort, 'float', 'string');
        $jcrcontentproxyUser = $this->deserialize($jcrcontentproxyUser, 'string', 'string');
        $jcrcontentqueueBatchMaxSize = $this->deserialize($jcrcontentqueueBatchMaxSize, 'float', 'string');
        $jcrcontentqueueBatchMode = $this->deserialize($jcrcontentqueueBatchMode, 'string', 'string');
        $jcrcontentqueueBatchWaitTime = $this->deserialize($jcrcontentqueueBatchWaitTime, 'float', 'string');
        $jcrcontentretryDelay = $this->deserialize($jcrcontentretryDelay, 'string', 'string');
        $jcrcontentreverseReplication = $this->deserialize($jcrcontentreverseReplication, 'bool', 'string');
        $jcrcontentserializationType = $this->deserialize($jcrcontentserializationType, 'string', 'string');
        $jcrcontentslingresourceType = $this->deserialize($jcrcontentslingresourceType, 'string', 'string');
        $jcrcontentssl = $this->deserialize($jcrcontentssl, 'string', 'string');
        $jcrcontenttransportNTLMDomain = $this->deserialize($jcrcontenttransportNTLMDomain, 'string', 'string');
        $jcrcontenttransportNTLMHost = $this->deserialize($jcrcontenttransportNTLMHost, 'string', 'string');
        $jcrcontenttransportPassword = $this->deserialize($jcrcontenttransportPassword, 'string', 'string');
        $jcrcontenttransportUri = $this->deserialize($jcrcontenttransportUri, 'string', 'string');
        $jcrcontenttransportUser = $this->deserialize($jcrcontenttransportUser, 'string', 'string');
        $jcrcontenttriggerDistribute = $this->deserialize($jcrcontenttriggerDistribute, 'bool', 'string');
        $jcrcontenttriggerModified = $this->deserialize($jcrcontenttriggerModified, 'bool', 'string');
        $jcrcontenttriggerOnOffTime = $this->deserialize($jcrcontenttriggerOnOffTime, 'bool', 'string');
        $jcrcontenttriggerReceive = $this->deserialize($jcrcontenttriggerReceive, 'bool', 'string');
        $jcrcontenttriggerSpecific = $this->deserialize($jcrcontenttriggerSpecific, 'bool', 'string');
        $jcrcontentuserId = $this->deserialize($jcrcontentuserId, 'string', 'string');
        $jcrprimaryType = $this->deserialize($jcrprimaryType, 'string', 'string');
        $operation = $this->deserialize($operation, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($runmode, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentcqdistribute, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentcqdistributeTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentcqname, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentcqtemplate, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentenabled, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentjcrdescription, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentjcrlastModified, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentjcrlastModifiedBy, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentjcrmixinTypes, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentjcrtitle, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentlogLevel, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentnoStatusUpdate, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentnoVersioning, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($jcrcontentprotocolConnectTimeout, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentprotocolHTTPConnectionClosed, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentprotocolHTTPExpired, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string")
        ]);
        $response = $this->validate($jcrcontentprotocolHTTPHeaders, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentprotocolHTTPHeadersTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentprotocolHTTPMethod, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentprotocolHTTPSRelaxed, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentprotocolInterface, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($jcrcontentprotocolSocketTimeout, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentprotocolVersion, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentproxyNTLMDomain, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentproxyNTLMHost, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentproxyHost, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentproxyPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($jcrcontentproxyPort, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentproxyUser, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($jcrcontentqueueBatchMaxSize, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentqueueBatchMode, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($jcrcontentqueueBatchWaitTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentretryDelay, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentreverseReplication, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentserializationType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentslingresourceType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentssl, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontenttransportNTLMDomain, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontenttransportNTLMHost, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontenttransportPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontenttransportUri, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontenttransportUser, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontenttriggerDistribute, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontenttriggerModified, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontenttriggerOnOffTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontenttriggerReceive, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontenttriggerSpecific, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentuserId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrprimaryType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($operation, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postAgent($runmode, $name, $jcrcontentcqdistribute, $jcrcontentcqdistributeTypeHint, $jcrcontentcqname, $jcrcontentcqtemplate, $jcrcontentenabled, $jcrcontentjcrdescription, $jcrcontentjcrlastModified, $jcrcontentjcrlastModifiedBy, $jcrcontentjcrmixinTypes, $jcrcontentjcrtitle, $jcrcontentlogLevel, $jcrcontentnoStatusUpdate, $jcrcontentnoVersioning, $jcrcontentprotocolConnectTimeout, $jcrcontentprotocolHTTPConnectionClosed, $jcrcontentprotocolHTTPExpired, $jcrcontentprotocolHTTPHeaders, $jcrcontentprotocolHTTPHeadersTypeHint, $jcrcontentprotocolHTTPMethod, $jcrcontentprotocolHTTPSRelaxed, $jcrcontentprotocolInterface, $jcrcontentprotocolSocketTimeout, $jcrcontentprotocolVersion, $jcrcontentproxyNTLMDomain, $jcrcontentproxyNTLMHost, $jcrcontentproxyHost, $jcrcontentproxyPassword, $jcrcontentproxyPort, $jcrcontentproxyUser, $jcrcontentqueueBatchMaxSize, $jcrcontentqueueBatchMode, $jcrcontentqueueBatchWaitTime, $jcrcontentretryDelay, $jcrcontentreverseReplication, $jcrcontentserializationType, $jcrcontentslingresourceType, $jcrcontentssl, $jcrcontenttransportNTLMDomain, $jcrcontenttransportNTLMHost, $jcrcontenttransportPassword, $jcrcontenttransportUri, $jcrcontenttransportUser, $jcrcontenttriggerDistribute, $jcrcontenttriggerModified, $jcrcontenttriggerOnOffTime, $jcrcontenttriggerReceive, $jcrcontenttriggerSpecific, $jcrcontentuserId, $jcrprimaryType, $operation, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postAuthorizableKeystore
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postAuthorizableKeystoreAction(Request $request, $intermediatePath, $authorizableId)
    {
        // Figure out what data format to return to the client
        $produces = ['text/plain'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $operation = $request->query->get('operation');
        $currentPassword = $request->query->get('currentPassword');
        $newPassword = $request->query->get('newPassword');
        $rePassword = $request->query->get('rePassword');
        $keyPassword = $request->query->get('keyPassword');
        $keyStorePass = $request->query->get('keyStorePass');
        $alias = $request->query->get('alias');
        $newAlias = $request->query->get('newAlias');
        $removeAlias = $request->query->get('removeAlias');
        $certChain = $request->files->get('certChain');
        $pk = $request->files->get('pk');
        $keyStore = $request->files->get('keyStore');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $intermediatePath = $this->deserialize($intermediatePath, 'string', 'string');
        $authorizableId = $this->deserialize($authorizableId, 'string', 'string');
        $operation = $this->deserialize($operation, 'string', 'string');
        $currentPassword = $this->deserialize($currentPassword, 'string', 'string');
        $newPassword = $this->deserialize($newPassword, 'string', 'string');
        $rePassword = $this->deserialize($rePassword, 'string', 'string');
        $keyPassword = $this->deserialize($keyPassword, 'string', 'string');
        $keyStorePass = $this->deserialize($keyStorePass, 'string', 'string');
        $alias = $this->deserialize($alias, 'string', 'string');
        $newAlias = $this->deserialize($newAlias, 'string', 'string');
        $removeAlias = $this->deserialize($removeAlias, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($intermediatePath, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($authorizableId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($operation, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($currentPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($newPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($rePassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($keyPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($keyStorePass, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($alias, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($newAlias, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($removeAlias, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\File();
        $response = $this->validate($certChain, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\File();
        $response = $this->validate($pk, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\File();
        $response = $this->validate($keyStore, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->postAuthorizableKeystore($intermediatePath, $authorizableId, $operation, $currentPassword, $newPassword, $rePassword, $keyPassword, $keyStorePass, $alias, $newAlias, $removeAlias, $certChain, $pk, $keyStore, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Retrieved Authorizable Keystore info';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Retrieved Authorizable Keystore info';
                    break;
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postAuthorizables
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postAuthorizablesAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['text/html'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $authorizableId = $request->query->get('authorizableId');
        $intermediatePath = $request->query->get('intermediatePath');
        $createUser = $request->query->get('createUser');
        $createGroup = $request->query->get('createGroup');
        $reppassword = $request->query->get('reppassword');
        $profilegivenName = $request->query->get('profilegivenName');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $authorizableId = $this->deserialize($authorizableId, 'string', 'string');
        $intermediatePath = $this->deserialize($intermediatePath, 'string', 'string');
        $createUser = $this->deserialize($createUser, 'string', 'string');
        $createGroup = $this->deserialize($createGroup, 'string', 'string');
        $reppassword = $this->deserialize($reppassword, 'string', 'string');
        $profilegivenName = $this->deserialize($profilegivenName, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($authorizableId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($intermediatePath, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($createUser, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($createGroup, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($reppassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($profilegivenName, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->postAuthorizables($authorizableId, $intermediatePath, $createUser, $createGroup, $reppassword, $profilegivenName, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postConfigAdobeGraniteSamlAuthenticationHandler
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postConfigAdobeGraniteSamlAuthenticationHandlerAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $keyStorePassword = $request->query->get('keyStorePassword');
        $keyStorePasswordTypeHint = $request->query->get('keyStorePasswordTypeHint');
        $serviceRanking = $request->query->get('serviceRanking');
        $serviceRankingTypeHint = $request->query->get('serviceRankingTypeHint');
        $idpHttpRedirect = $request->query->get('idpHttpRedirect');
        $idpHttpRedirectTypeHint = $request->query->get('idpHttpRedirectTypeHint');
        $createUser = $request->query->get('createUser');
        $createUserTypeHint = $request->query->get('createUserTypeHint');
        $defaultRedirectUrl = $request->query->get('defaultRedirectUrl');
        $defaultRedirectUrlTypeHint = $request->query->get('defaultRedirectUrlTypeHint');
        $userIDAttribute = $request->query->get('userIDAttribute');
        $userIDAttributeTypeHint = $request->query->get('userIDAttributeTypeHint');
        $defaultGroups = $request->query->get('defaultGroups');
        $defaultGroupsTypeHint = $request->query->get('defaultGroupsTypeHint');
        $idpCertAlias = $request->query->get('idpCertAlias');
        $idpCertAliasTypeHint = $request->query->get('idpCertAliasTypeHint');
        $addGroupMemberships = $request->query->get('addGroupMemberships');
        $addGroupMembershipsTypeHint = $request->query->get('addGroupMembershipsTypeHint');
        $path = $request->query->get('path');
        $pathTypeHint = $request->query->get('pathTypeHint');
        $synchronizeAttributes = $request->query->get('synchronizeAttributes');
        $synchronizeAttributesTypeHint = $request->query->get('synchronizeAttributesTypeHint');
        $clockTolerance = $request->query->get('clockTolerance');
        $clockToleranceTypeHint = $request->query->get('clockToleranceTypeHint');
        $groupMembershipAttribute = $request->query->get('groupMembershipAttribute');
        $groupMembershipAttributeTypeHint = $request->query->get('groupMembershipAttributeTypeHint');
        $idpUrl = $request->query->get('idpUrl');
        $idpUrlTypeHint = $request->query->get('idpUrlTypeHint');
        $logoutUrl = $request->query->get('logoutUrl');
        $logoutUrlTypeHint = $request->query->get('logoutUrlTypeHint');
        $serviceProviderEntityId = $request->query->get('serviceProviderEntityId');
        $serviceProviderEntityIdTypeHint = $request->query->get('serviceProviderEntityIdTypeHint');
        $assertionConsumerServiceURL = $request->query->get('assertionConsumerServiceURL');
        $assertionConsumerServiceURLTypeHint = $request->query->get('assertionConsumerServiceURLTypeHint');
        $handleLogout = $request->query->get('handleLogout');
        $handleLogoutTypeHint = $request->query->get('handleLogoutTypeHint');
        $spPrivateKeyAlias = $request->query->get('spPrivateKeyAlias');
        $spPrivateKeyAliasTypeHint = $request->query->get('spPrivateKeyAliasTypeHint');
        $useEncryption = $request->query->get('useEncryption');
        $useEncryptionTypeHint = $request->query->get('useEncryptionTypeHint');
        $nameIdFormat = $request->query->get('nameIdFormat');
        $nameIdFormatTypeHint = $request->query->get('nameIdFormatTypeHint');
        $digestMethod = $request->query->get('digestMethod');
        $digestMethodTypeHint = $request->query->get('digestMethodTypeHint');
        $signatureMethod = $request->query->get('signatureMethod');
        $signatureMethodTypeHint = $request->query->get('signatureMethodTypeHint');
        $userIntermediatePath = $request->query->get('userIntermediatePath');
        $userIntermediatePathTypeHint = $request->query->get('userIntermediatePathTypeHint');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $keyStorePassword = $this->deserialize($keyStorePassword, 'string', 'string');
        $keyStorePasswordTypeHint = $this->deserialize($keyStorePasswordTypeHint, 'string', 'string');
        $serviceRanking = $this->deserialize($serviceRanking, 'int', 'string');
        $serviceRankingTypeHint = $this->deserialize($serviceRankingTypeHint, 'string', 'string');
        $idpHttpRedirect = $this->deserialize($idpHttpRedirect, 'bool', 'string');
        $idpHttpRedirectTypeHint = $this->deserialize($idpHttpRedirectTypeHint, 'string', 'string');
        $createUser = $this->deserialize($createUser, 'bool', 'string');
        $createUserTypeHint = $this->deserialize($createUserTypeHint, 'string', 'string');
        $defaultRedirectUrl = $this->deserialize($defaultRedirectUrl, 'string', 'string');
        $defaultRedirectUrlTypeHint = $this->deserialize($defaultRedirectUrlTypeHint, 'string', 'string');
        $userIDAttribute = $this->deserialize($userIDAttribute, 'string', 'string');
        $userIDAttributeTypeHint = $this->deserialize($userIDAttributeTypeHint, 'string', 'string');
        $defaultGroups = $this->deserialize($defaultGroups, 'array<multi,string>', 'string');
        $defaultGroupsTypeHint = $this->deserialize($defaultGroupsTypeHint, 'string', 'string');
        $idpCertAlias = $this->deserialize($idpCertAlias, 'string', 'string');
        $idpCertAliasTypeHint = $this->deserialize($idpCertAliasTypeHint, 'string', 'string');
        $addGroupMemberships = $this->deserialize($addGroupMemberships, 'bool', 'string');
        $addGroupMembershipsTypeHint = $this->deserialize($addGroupMembershipsTypeHint, 'string', 'string');
        $path = $this->deserialize($path, 'array<multi,string>', 'string');
        $pathTypeHint = $this->deserialize($pathTypeHint, 'string', 'string');
        $synchronizeAttributes = $this->deserialize($synchronizeAttributes, 'array<multi,string>', 'string');
        $synchronizeAttributesTypeHint = $this->deserialize($synchronizeAttributesTypeHint, 'string', 'string');
        $clockTolerance = $this->deserialize($clockTolerance, 'int', 'string');
        $clockToleranceTypeHint = $this->deserialize($clockToleranceTypeHint, 'string', 'string');
        $groupMembershipAttribute = $this->deserialize($groupMembershipAttribute, 'string', 'string');
        $groupMembershipAttributeTypeHint = $this->deserialize($groupMembershipAttributeTypeHint, 'string', 'string');
        $idpUrl = $this->deserialize($idpUrl, 'string', 'string');
        $idpUrlTypeHint = $this->deserialize($idpUrlTypeHint, 'string', 'string');
        $logoutUrl = $this->deserialize($logoutUrl, 'string', 'string');
        $logoutUrlTypeHint = $this->deserialize($logoutUrlTypeHint, 'string', 'string');
        $serviceProviderEntityId = $this->deserialize($serviceProviderEntityId, 'string', 'string');
        $serviceProviderEntityIdTypeHint = $this->deserialize($serviceProviderEntityIdTypeHint, 'string', 'string');
        $assertionConsumerServiceURL = $this->deserialize($assertionConsumerServiceURL, 'string', 'string');
        $assertionConsumerServiceURLTypeHint = $this->deserialize($assertionConsumerServiceURLTypeHint, 'string', 'string');
        $handleLogout = $this->deserialize($handleLogout, 'bool', 'string');
        $handleLogoutTypeHint = $this->deserialize($handleLogoutTypeHint, 'string', 'string');
        $spPrivateKeyAlias = $this->deserialize($spPrivateKeyAlias, 'string', 'string');
        $spPrivateKeyAliasTypeHint = $this->deserialize($spPrivateKeyAliasTypeHint, 'string', 'string');
        $useEncryption = $this->deserialize($useEncryption, 'bool', 'string');
        $useEncryptionTypeHint = $this->deserialize($useEncryptionTypeHint, 'string', 'string');
        $nameIdFormat = $this->deserialize($nameIdFormat, 'string', 'string');
        $nameIdFormatTypeHint = $this->deserialize($nameIdFormatTypeHint, 'string', 'string');
        $digestMethod = $this->deserialize($digestMethod, 'string', 'string');
        $digestMethodTypeHint = $this->deserialize($digestMethodTypeHint, 'string', 'string');
        $signatureMethod = $this->deserialize($signatureMethod, 'string', 'string');
        $signatureMethodTypeHint = $this->deserialize($signatureMethodTypeHint, 'string', 'string');
        $userIntermediatePath = $this->deserialize($userIntermediatePath, 'string', 'string');
        $userIntermediatePathTypeHint = $this->deserialize($userIntermediatePathTypeHint, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($keyStorePassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($keyStorePasswordTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($serviceRanking, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($serviceRankingTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($idpHttpRedirect, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($idpHttpRedirectTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($createUser, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($createUserTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($defaultRedirectUrl, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($defaultRedirectUrlTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($userIDAttribute, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($userIDAttributeTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string")
        ]);
        $response = $this->validate($defaultGroups, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($defaultGroupsTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($idpCertAlias, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($idpCertAliasTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($addGroupMemberships, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($addGroupMembershipsTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string")
        ]);
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($pathTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string")
        ]);
        $response = $this->validate($synchronizeAttributes, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($synchronizeAttributesTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($clockTolerance, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($clockToleranceTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($groupMembershipAttribute, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($groupMembershipAttributeTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($idpUrl, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($idpUrlTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($logoutUrl, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($logoutUrlTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($serviceProviderEntityId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($serviceProviderEntityIdTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($assertionConsumerServiceURL, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($assertionConsumerServiceURLTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($handleLogout, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($handleLogoutTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($spPrivateKeyAlias, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($spPrivateKeyAliasTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($useEncryption, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($useEncryptionTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($nameIdFormat, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($nameIdFormatTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($digestMethod, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($digestMethodTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($signatureMethod, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($signatureMethodTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($userIntermediatePath, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($userIntermediatePathTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postConfigAdobeGraniteSamlAuthenticationHandler($keyStorePassword, $keyStorePasswordTypeHint, $serviceRanking, $serviceRankingTypeHint, $idpHttpRedirect, $idpHttpRedirectTypeHint, $createUser, $createUserTypeHint, $defaultRedirectUrl, $defaultRedirectUrlTypeHint, $userIDAttribute, $userIDAttributeTypeHint, $defaultGroups, $defaultGroupsTypeHint, $idpCertAlias, $idpCertAliasTypeHint, $addGroupMemberships, $addGroupMembershipsTypeHint, $path, $pathTypeHint, $synchronizeAttributes, $synchronizeAttributesTypeHint, $clockTolerance, $clockToleranceTypeHint, $groupMembershipAttribute, $groupMembershipAttributeTypeHint, $idpUrl, $idpUrlTypeHint, $logoutUrl, $logoutUrlTypeHint, $serviceProviderEntityId, $serviceProviderEntityIdTypeHint, $assertionConsumerServiceURL, $assertionConsumerServiceURLTypeHint, $handleLogout, $handleLogoutTypeHint, $spPrivateKeyAlias, $spPrivateKeyAliasTypeHint, $useEncryption, $useEncryptionTypeHint, $nameIdFormat, $nameIdFormatTypeHint, $digestMethod, $digestMethodTypeHint, $signatureMethod, $signatureMethodTypeHint, $userIntermediatePath, $userIntermediatePathTypeHint, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postConfigApacheFelixJettyBasedHttpService
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postConfigApacheFelixJettyBasedHttpServiceAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $orgApacheFelixHttpsNio = $request->query->get('orgApacheFelixHttpsNio');
        $orgApacheFelixHttpsNioTypeHint = $request->query->get('orgApacheFelixHttpsNioTypeHint');
        $orgApacheFelixHttpsKeystore = $request->query->get('orgApacheFelixHttpsKeystore');
        $orgApacheFelixHttpsKeystoreTypeHint = $request->query->get('orgApacheFelixHttpsKeystoreTypeHint');
        $orgApacheFelixHttpsKeystorePassword = $request->query->get('orgApacheFelixHttpsKeystorePassword');
        $orgApacheFelixHttpsKeystorePasswordTypeHint = $request->query->get('orgApacheFelixHttpsKeystorePasswordTypeHint');
        $orgApacheFelixHttpsKeystoreKey = $request->query->get('orgApacheFelixHttpsKeystoreKey');
        $orgApacheFelixHttpsKeystoreKeyTypeHint = $request->query->get('orgApacheFelixHttpsKeystoreKeyTypeHint');
        $orgApacheFelixHttpsKeystoreKeyPassword = $request->query->get('orgApacheFelixHttpsKeystoreKeyPassword');
        $orgApacheFelixHttpsKeystoreKeyPasswordTypeHint = $request->query->get('orgApacheFelixHttpsKeystoreKeyPasswordTypeHint');
        $orgApacheFelixHttpsTruststore = $request->query->get('orgApacheFelixHttpsTruststore');
        $orgApacheFelixHttpsTruststoreTypeHint = $request->query->get('orgApacheFelixHttpsTruststoreTypeHint');
        $orgApacheFelixHttpsTruststorePassword = $request->query->get('orgApacheFelixHttpsTruststorePassword');
        $orgApacheFelixHttpsTruststorePasswordTypeHint = $request->query->get('orgApacheFelixHttpsTruststorePasswordTypeHint');
        $orgApacheFelixHttpsClientcertificate = $request->query->get('orgApacheFelixHttpsClientcertificate');
        $orgApacheFelixHttpsClientcertificateTypeHint = $request->query->get('orgApacheFelixHttpsClientcertificateTypeHint');
        $orgApacheFelixHttpsEnable = $request->query->get('orgApacheFelixHttpsEnable');
        $orgApacheFelixHttpsEnableTypeHint = $request->query->get('orgApacheFelixHttpsEnableTypeHint');
        $orgOsgiServiceHttpPortSecure = $request->query->get('orgOsgiServiceHttpPortSecure');
        $orgOsgiServiceHttpPortSecureTypeHint = $request->query->get('orgOsgiServiceHttpPortSecureTypeHint');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $orgApacheFelixHttpsNio = $this->deserialize($orgApacheFelixHttpsNio, 'bool', 'string');
        $orgApacheFelixHttpsNioTypeHint = $this->deserialize($orgApacheFelixHttpsNioTypeHint, 'string', 'string');
        $orgApacheFelixHttpsKeystore = $this->deserialize($orgApacheFelixHttpsKeystore, 'string', 'string');
        $orgApacheFelixHttpsKeystoreTypeHint = $this->deserialize($orgApacheFelixHttpsKeystoreTypeHint, 'string', 'string');
        $orgApacheFelixHttpsKeystorePassword = $this->deserialize($orgApacheFelixHttpsKeystorePassword, 'string', 'string');
        $orgApacheFelixHttpsKeystorePasswordTypeHint = $this->deserialize($orgApacheFelixHttpsKeystorePasswordTypeHint, 'string', 'string');
        $orgApacheFelixHttpsKeystoreKey = $this->deserialize($orgApacheFelixHttpsKeystoreKey, 'string', 'string');
        $orgApacheFelixHttpsKeystoreKeyTypeHint = $this->deserialize($orgApacheFelixHttpsKeystoreKeyTypeHint, 'string', 'string');
        $orgApacheFelixHttpsKeystoreKeyPassword = $this->deserialize($orgApacheFelixHttpsKeystoreKeyPassword, 'string', 'string');
        $orgApacheFelixHttpsKeystoreKeyPasswordTypeHint = $this->deserialize($orgApacheFelixHttpsKeystoreKeyPasswordTypeHint, 'string', 'string');
        $orgApacheFelixHttpsTruststore = $this->deserialize($orgApacheFelixHttpsTruststore, 'string', 'string');
        $orgApacheFelixHttpsTruststoreTypeHint = $this->deserialize($orgApacheFelixHttpsTruststoreTypeHint, 'string', 'string');
        $orgApacheFelixHttpsTruststorePassword = $this->deserialize($orgApacheFelixHttpsTruststorePassword, 'string', 'string');
        $orgApacheFelixHttpsTruststorePasswordTypeHint = $this->deserialize($orgApacheFelixHttpsTruststorePasswordTypeHint, 'string', 'string');
        $orgApacheFelixHttpsClientcertificate = $this->deserialize($orgApacheFelixHttpsClientcertificate, 'string', 'string');
        $orgApacheFelixHttpsClientcertificateTypeHint = $this->deserialize($orgApacheFelixHttpsClientcertificateTypeHint, 'string', 'string');
        $orgApacheFelixHttpsEnable = $this->deserialize($orgApacheFelixHttpsEnable, 'bool', 'string');
        $orgApacheFelixHttpsEnableTypeHint = $this->deserialize($orgApacheFelixHttpsEnableTypeHint, 'string', 'string');
        $orgOsgiServiceHttpPortSecure = $this->deserialize($orgOsgiServiceHttpPortSecure, 'string', 'string');
        $orgOsgiServiceHttpPortSecureTypeHint = $this->deserialize($orgOsgiServiceHttpPortSecureTypeHint, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($orgApacheFelixHttpsNio, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsNioTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystore, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystoreTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystorePassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystorePasswordTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystoreKey, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystoreKeyTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystoreKeyPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystoreKeyPasswordTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsTruststore, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsTruststoreTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsTruststorePassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsTruststorePasswordTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsClientcertificate, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsClientcertificateTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($orgApacheFelixHttpsEnable, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsEnableTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgOsgiServiceHttpPortSecure, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgOsgiServiceHttpPortSecureTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postConfigApacheFelixJettyBasedHttpService($orgApacheFelixHttpsNio, $orgApacheFelixHttpsNioTypeHint, $orgApacheFelixHttpsKeystore, $orgApacheFelixHttpsKeystoreTypeHint, $orgApacheFelixHttpsKeystorePassword, $orgApacheFelixHttpsKeystorePasswordTypeHint, $orgApacheFelixHttpsKeystoreKey, $orgApacheFelixHttpsKeystoreKeyTypeHint, $orgApacheFelixHttpsKeystoreKeyPassword, $orgApacheFelixHttpsKeystoreKeyPasswordTypeHint, $orgApacheFelixHttpsTruststore, $orgApacheFelixHttpsTruststoreTypeHint, $orgApacheFelixHttpsTruststorePassword, $orgApacheFelixHttpsTruststorePasswordTypeHint, $orgApacheFelixHttpsClientcertificate, $orgApacheFelixHttpsClientcertificateTypeHint, $orgApacheFelixHttpsEnable, $orgApacheFelixHttpsEnableTypeHint, $orgOsgiServiceHttpPortSecure, $orgOsgiServiceHttpPortSecureTypeHint, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postConfigApacheHttpComponentsProxyConfiguration
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postConfigApacheHttpComponentsProxyConfigurationAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $proxyHost = $request->query->get('proxyHost');
        $proxyHostTypeHint = $request->query->get('proxyHostTypeHint');
        $proxyPort = $request->query->get('proxyPort');
        $proxyPortTypeHint = $request->query->get('proxyPortTypeHint');
        $proxyExceptions = $request->query->get('proxyExceptions');
        $proxyExceptionsTypeHint = $request->query->get('proxyExceptionsTypeHint');
        $proxyEnabled = $request->query->get('proxyEnabled');
        $proxyEnabledTypeHint = $request->query->get('proxyEnabledTypeHint');
        $proxyUser = $request->query->get('proxyUser');
        $proxyUserTypeHint = $request->query->get('proxyUserTypeHint');
        $proxyPassword = $request->query->get('proxyPassword');
        $proxyPasswordTypeHint = $request->query->get('proxyPasswordTypeHint');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $proxyHost = $this->deserialize($proxyHost, 'string', 'string');
        $proxyHostTypeHint = $this->deserialize($proxyHostTypeHint, 'string', 'string');
        $proxyPort = $this->deserialize($proxyPort, 'int', 'string');
        $proxyPortTypeHint = $this->deserialize($proxyPortTypeHint, 'string', 'string');
        $proxyExceptions = $this->deserialize($proxyExceptions, 'array<multi,string>', 'string');
        $proxyExceptionsTypeHint = $this->deserialize($proxyExceptionsTypeHint, 'string', 'string');
        $proxyEnabled = $this->deserialize($proxyEnabled, 'bool', 'string');
        $proxyEnabledTypeHint = $this->deserialize($proxyEnabledTypeHint, 'string', 'string');
        $proxyUser = $this->deserialize($proxyUser, 'string', 'string');
        $proxyUserTypeHint = $this->deserialize($proxyUserTypeHint, 'string', 'string');
        $proxyPassword = $this->deserialize($proxyPassword, 'string', 'string');
        $proxyPasswordTypeHint = $this->deserialize($proxyPasswordTypeHint, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyHost, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyHostTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($proxyPort, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyPortTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string")
        ]);
        $response = $this->validate($proxyExceptions, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyExceptionsTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($proxyEnabled, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyEnabledTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyUser, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyUserTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyPasswordTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postConfigApacheHttpComponentsProxyConfiguration($proxyHost, $proxyHostTypeHint, $proxyPort, $proxyPortTypeHint, $proxyExceptions, $proxyExceptionsTypeHint, $proxyEnabled, $proxyEnabledTypeHint, $proxyUser, $proxyUserTypeHint, $proxyPassword, $proxyPasswordTypeHint, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postConfigApacheSlingDavExServlet
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postConfigApacheSlingDavExServletAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $alias = $request->query->get('alias');
        $aliasTypeHint = $request->query->get('aliasTypeHint');
        $davCreateAbsoluteUri = $request->query->get('davCreateAbsoluteUri');
        $davCreateAbsoluteUriTypeHint = $request->query->get('davCreateAbsoluteUriTypeHint');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $alias = $this->deserialize($alias, 'string', 'string');
        $aliasTypeHint = $this->deserialize($aliasTypeHint, 'string', 'string');
        $davCreateAbsoluteUri = $this->deserialize($davCreateAbsoluteUri, 'bool', 'string');
        $davCreateAbsoluteUriTypeHint = $this->deserialize($davCreateAbsoluteUriTypeHint, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($alias, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($aliasTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($davCreateAbsoluteUri, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($davCreateAbsoluteUriTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postConfigApacheSlingDavExServlet($alias, $aliasTypeHint, $davCreateAbsoluteUri, $davCreateAbsoluteUriTypeHint, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postConfigApacheSlingGetServlet
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postConfigApacheSlingGetServletAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $jsonMaximumresults = $request->query->get('jsonMaximumresults');
        $jsonMaximumresultsTypeHint = $request->query->get('jsonMaximumresultsTypeHint');
        $enableHtml = $request->query->get('enableHtml');
        $enableHtmlTypeHint = $request->query->get('enableHtmlTypeHint');
        $enableTxt = $request->query->get('enableTxt');
        $enableTxtTypeHint = $request->query->get('enableTxtTypeHint');
        $enableXml = $request->query->get('enableXml');
        $enableXmlTypeHint = $request->query->get('enableXmlTypeHint');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $jsonMaximumresults = $this->deserialize($jsonMaximumresults, 'string', 'string');
        $jsonMaximumresultsTypeHint = $this->deserialize($jsonMaximumresultsTypeHint, 'string', 'string');
        $enableHtml = $this->deserialize($enableHtml, 'bool', 'string');
        $enableHtmlTypeHint = $this->deserialize($enableHtmlTypeHint, 'string', 'string');
        $enableTxt = $this->deserialize($enableTxt, 'bool', 'string');
        $enableTxtTypeHint = $this->deserialize($enableTxtTypeHint, 'string', 'string');
        $enableXml = $this->deserialize($enableXml, 'bool', 'string');
        $enableXmlTypeHint = $this->deserialize($enableXmlTypeHint, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jsonMaximumresults, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jsonMaximumresultsTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($enableHtml, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($enableHtmlTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($enableTxt, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($enableTxtTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($enableXml, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($enableXmlTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postConfigApacheSlingGetServlet($jsonMaximumresults, $jsonMaximumresultsTypeHint, $enableHtml, $enableHtmlTypeHint, $enableTxt, $enableTxtTypeHint, $enableXml, $enableXmlTypeHint, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postConfigApacheSlingReferrerFilter
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postConfigApacheSlingReferrerFilterAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $allowEmpty = $request->query->get('allowEmpty');
        $allowEmptyTypeHint = $request->query->get('allowEmptyTypeHint');
        $allowHosts = $request->query->get('allowHosts');
        $allowHostsTypeHint = $request->query->get('allowHostsTypeHint');
        $allowHostsRegexp = $request->query->get('allowHostsRegexp');
        $allowHostsRegexpTypeHint = $request->query->get('allowHostsRegexpTypeHint');
        $filterMethods = $request->query->get('filterMethods');
        $filterMethodsTypeHint = $request->query->get('filterMethodsTypeHint');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $allowEmpty = $this->deserialize($allowEmpty, 'bool', 'string');
        $allowEmptyTypeHint = $this->deserialize($allowEmptyTypeHint, 'string', 'string');
        $allowHosts = $this->deserialize($allowHosts, 'string', 'string');
        $allowHostsTypeHint = $this->deserialize($allowHostsTypeHint, 'string', 'string');
        $allowHostsRegexp = $this->deserialize($allowHostsRegexp, 'string', 'string');
        $allowHostsRegexpTypeHint = $this->deserialize($allowHostsRegexpTypeHint, 'string', 'string');
        $filterMethods = $this->deserialize($filterMethods, 'string', 'string');
        $filterMethodsTypeHint = $this->deserialize($filterMethodsTypeHint, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($allowEmpty, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($allowEmptyTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($allowHosts, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($allowHostsTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($allowHostsRegexp, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($allowHostsRegexpTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($filterMethods, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($filterMethodsTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postConfigApacheSlingReferrerFilter($allowEmpty, $allowEmptyTypeHint, $allowHosts, $allowHostsTypeHint, $allowHostsRegexp, $allowHostsRegexpTypeHint, $filterMethods, $filterMethodsTypeHint, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postNode
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postNodeAction(Request $request, $path, $name)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $operation = $request->query->get('operation');
        $deleteAuthorizable = $request->query->get('deleteAuthorizable');
        $file = $request->files->get('file');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $path = $this->deserialize($path, 'string', 'string');
        $name = $this->deserialize($name, 'string', 'string');
        $operation = $this->deserialize($operation, 'string', 'string');
        $deleteAuthorizable = $this->deserialize($deleteAuthorizable, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($operation, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($deleteAuthorizable, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\File();
        $response = $this->validate($file, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postNode($path, $name, $operation, $deleteAuthorizable, $file, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postNodeRw
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postNodeRwAction(Request $request, $path, $name)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $addMembers = $request->query->get('addMembers');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $path = $this->deserialize($path, 'string', 'string');
        $name = $this->deserialize($name, 'string', 'string');
        $addMembers = $this->deserialize($addMembers, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($addMembers, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postNodeRw($path, $name, $addMembers, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postPath
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postPathAction(Request $request, $path)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $jcrprimaryType = $request->query->get('jcrprimaryType');
        $name = $request->query->get('name');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $path = $this->deserialize($path, 'string', 'string');
        $jcrprimaryType = $this->deserialize($jcrprimaryType, 'string', 'string');
        $name = $this->deserialize($name, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrprimaryType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postPath($path, $jcrprimaryType, $name, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postQuery
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postQueryAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $path = $request->query->get('path');
        $pLimit = $request->query->get('pLimit');
        $_1property = $request->query->get('_1property');
        $_1propertyValue = $request->query->get('_1propertyValue');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $path = $this->deserialize($path, 'string', 'string');
        $pLimit = $this->deserialize($pLimit, 'float', 'string');
        $_1property = $this->deserialize($_1property, 'string', 'string');
        $_1propertyValue = $this->deserialize($_1propertyValue, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($pLimit, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($_1property, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($_1propertyValue, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->postQuery($path, $pLimit, $_1property, $_1propertyValue, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postTreeActivation
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postTreeActivationAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = [];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $ignoredeactivated = $request->query->get('ignoredeactivated');
        $onlymodified = $request->query->get('onlymodified');
        $path = $request->query->get('path');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $ignoredeactivated = $this->deserialize($ignoredeactivated, 'bool', 'string');
        $onlymodified = $this->deserialize($onlymodified, 'bool', 'string');
        $path = $this->deserialize($path, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($ignoredeactivated, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($onlymodified, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postTreeActivation($ignoredeactivated, $onlymodified, $path, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postTruststore
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postTruststoreAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['text/plain'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $operation = $request->query->get('operation');
        $newPassword = $request->query->get('newPassword');
        $rePassword = $request->query->get('rePassword');
        $keyStoreType = $request->query->get('keyStoreType');
        $removeAlias = $request->query->get('removeAlias');
        $certificate = $request->files->get('certificate');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        $operation = $this->deserialize($operation, 'string', 'string');
        $newPassword = $this->deserialize($newPassword, 'string', 'string');
        $rePassword = $this->deserialize($rePassword, 'string', 'string');
        $keyStoreType = $this->deserialize($keyStoreType, 'string', 'string');
        $removeAlias = $this->deserialize($removeAlias, 'string', 'string');

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($operation, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($newPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($rePassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($keyStoreType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($removeAlias, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\File();
        $response = $this->validate($certificate, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->postTruststore($operation, $newPassword, $rePassword, $keyStoreType, $removeAlias, $certificate, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postTruststorePKCS12
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postTruststorePKCS12Action(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['text/plain'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $truststoreP12 = $request->files->get('truststoreP12');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\File();
        $response = $this->validate($truststoreP12, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->postTruststorePKCS12($truststoreP12, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Returns the handler for this API controller.
     * @return SlingApiInterface
     */
    public function getApiHandler()
    {
        return $this->apiServer->getApiHandler('sling');
    }
}
