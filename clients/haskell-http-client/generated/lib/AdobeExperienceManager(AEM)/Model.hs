{-
   Adobe Experience Manager (AEM) API

   Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API

   OpenAPI Version: 3.0.0
   Adobe Experience Manager (AEM) API API version: 3.2.0-pre.0
   Contact: opensource@shinesolutions.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : AdobeExperienceManager(AEM).Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module AdobeExperienceManager(AEM).Model where

import AdobeExperienceManager(AEM).Core
import AdobeExperienceManager(AEM).MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Action
newtype Action = Action { unAction :: Text } deriving (P.Eq, P.Show)

-- ** AddGroupMemberships
newtype AddGroupMemberships = AddGroupMemberships { unAddGroupMemberships :: Bool } deriving (P.Eq, P.Show)

-- ** AddGroupMembershipsTypeHint
newtype AddGroupMembershipsTypeHint = AddGroupMembershipsTypeHint { unAddGroupMembershipsTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** AddMembers
newtype AddMembers = AddMembers { unAddMembers :: Text } deriving (P.Eq, P.Show)

-- ** Alias
newtype Alias = Alias { unAlias :: Text } deriving (P.Eq, P.Show)

-- ** AliasTypeHint
newtype AliasTypeHint = AliasTypeHint { unAliasTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** AllowEmpty
newtype AllowEmpty = AllowEmpty { unAllowEmpty :: Bool } deriving (P.Eq, P.Show)

-- ** AllowEmptyTypeHint
newtype AllowEmptyTypeHint = AllowEmptyTypeHint { unAllowEmptyTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** AllowHosts
newtype AllowHosts = AllowHosts { unAllowHosts :: Text } deriving (P.Eq, P.Show)

-- ** AllowHostsRegexp
newtype AllowHostsRegexp = AllowHostsRegexp { unAllowHostsRegexp :: Text } deriving (P.Eq, P.Show)

-- ** AllowHostsRegexpTypeHint
newtype AllowHostsRegexpTypeHint = AllowHostsRegexpTypeHint { unAllowHostsRegexpTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** AllowHostsTypeHint
newtype AllowHostsTypeHint = AllowHostsTypeHint { unAllowHostsTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Apply
newtype Apply = Apply { unApply :: Bool } deriving (P.Eq, P.Show)

-- ** AssertionConsumerServiceUrl
newtype AssertionConsumerServiceUrl = AssertionConsumerServiceUrl { unAssertionConsumerServiceUrl :: Text } deriving (P.Eq, P.Show)

-- ** AssertionConsumerServiceUrlTypeHint
newtype AssertionConsumerServiceUrlTypeHint = AssertionConsumerServiceUrlTypeHint { unAssertionConsumerServiceUrlTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** AuthorizableId
newtype AuthorizableId = AuthorizableId { unAuthorizableId :: Text } deriving (P.Eq, P.Show)

-- ** BundlesIgnored
newtype BundlesIgnored = BundlesIgnored { unBundlesIgnored :: [Text] } deriving (P.Eq, P.Show)

-- ** BundlesIgnoredTypeHint
newtype BundlesIgnoredTypeHint = BundlesIgnoredTypeHint { unBundlesIgnoredTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** CertChain
newtype CertChain = CertChain { unCertChain :: FilePath } deriving (P.Eq, P.Show)

-- ** Certificate
newtype Certificate = Certificate { unCertificate :: FilePath } deriving (P.Eq, P.Show)

-- ** Changelog
newtype Changelog = Changelog { unChangelog :: Text } deriving (P.Eq, P.Show)

-- ** Charset
newtype Charset = Charset { unCharset :: Text } deriving (P.Eq, P.Show)

-- ** ClockTolerance
newtype ClockTolerance = ClockTolerance { unClockTolerance :: Int } deriving (P.Eq, P.Show)

-- ** ClockToleranceTypeHint
newtype ClockToleranceTypeHint = ClockToleranceTypeHint { unClockToleranceTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Cmd
newtype Cmd = Cmd { unCmd :: Text } deriving (P.Eq, P.Show)

-- ** CombineTagsOr
newtype CombineTagsOr = CombineTagsOr { unCombineTagsOr :: Bool } deriving (P.Eq, P.Show)

-- ** CreateGroup
newtype CreateGroup = CreateGroup { unCreateGroup :: Text } deriving (P.Eq, P.Show)

-- ** CreateUser
newtype CreateUser = CreateUser { unCreateUser :: Text } deriving (P.Eq, P.Show)

-- ** CreateUserBool
newtype CreateUserBool = CreateUserBool { unCreateUserBool :: Bool } deriving (P.Eq, P.Show)

-- ** CreateUserTypeHint
newtype CreateUserTypeHint = CreateUserTypeHint { unCreateUserTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** CurrentPassword
newtype CurrentPassword = CurrentPassword { unCurrentPassword :: Text } deriving (P.Eq, P.Show)

-- ** DavCreateAbsoluteUri
newtype DavCreateAbsoluteUri = DavCreateAbsoluteUri { unDavCreateAbsoluteUri :: Bool } deriving (P.Eq, P.Show)

-- ** DavCreateAbsoluteUriTypeHint
newtype DavCreateAbsoluteUriTypeHint = DavCreateAbsoluteUriTypeHint { unDavCreateAbsoluteUriTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** DefaultGroups
newtype DefaultGroups = DefaultGroups { unDefaultGroups :: [Text] } deriving (P.Eq, P.Show)

-- ** DefaultGroupsTypeHint
newtype DefaultGroupsTypeHint = DefaultGroupsTypeHint { unDefaultGroupsTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** DefaultRedirectUrl
newtype DefaultRedirectUrl = DefaultRedirectUrl { unDefaultRedirectUrl :: Text } deriving (P.Eq, P.Show)

-- ** DefaultRedirectUrlTypeHint
newtype DefaultRedirectUrlTypeHint = DefaultRedirectUrlTypeHint { unDefaultRedirectUrlTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Delete
newtype Delete = Delete { unDelete :: Bool } deriving (P.Eq, P.Show)

-- ** DeleteAuthorizable
newtype DeleteAuthorizable = DeleteAuthorizable { unDeleteAuthorizable :: Text } deriving (P.Eq, P.Show)

-- ** DigestMethod
newtype DigestMethod = DigestMethod { unDigestMethod :: Text } deriving (P.Eq, P.Show)

-- ** DigestMethodTypeHint
newtype DigestMethodTypeHint = DigestMethodTypeHint { unDigestMethodTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** EnableHtml
newtype EnableHtml = EnableHtml { unEnableHtml :: Bool } deriving (P.Eq, P.Show)

-- ** EnableHtmlTypeHint
newtype EnableHtmlTypeHint = EnableHtmlTypeHint { unEnableHtmlTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** EnableTxt
newtype EnableTxt = EnableTxt { unEnableTxt :: Bool } deriving (P.Eq, P.Show)

-- ** EnableTxtTypeHint
newtype EnableTxtTypeHint = EnableTxtTypeHint { unEnableTxtTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** EnableXml
newtype EnableXml = EnableXml { unEnableXml :: Bool } deriving (P.Eq, P.Show)

-- ** EnableXmlTypeHint
newtype EnableXmlTypeHint = EnableXmlTypeHint { unEnableXmlTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** File
newtype File = File { unFile :: FilePath } deriving (P.Eq, P.Show)

-- ** Filter
newtype Filter = Filter { unFilter :: Text } deriving (P.Eq, P.Show)

-- ** FilterMethods
newtype FilterMethods = FilterMethods { unFilterMethods :: Text } deriving (P.Eq, P.Show)

-- ** FilterMethodsTypeHint
newtype FilterMethodsTypeHint = FilterMethodsTypeHint { unFilterMethodsTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Force
newtype Force = Force { unForce :: Bool } deriving (P.Eq, P.Show)

-- ** Group
newtype Group = Group { unGroup :: Text } deriving (P.Eq, P.Show)

-- ** GroupMembershipAttribute
newtype GroupMembershipAttribute = GroupMembershipAttribute { unGroupMembershipAttribute :: Text } deriving (P.Eq, P.Show)

-- ** GroupMembershipAttributeTypeHint
newtype GroupMembershipAttributeTypeHint = GroupMembershipAttributeTypeHint { unGroupMembershipAttributeTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** GroupName
newtype GroupName = GroupName { unGroupName :: Text } deriving (P.Eq, P.Show)

-- ** HandleLogout
newtype HandleLogout = HandleLogout { unHandleLogout :: Bool } deriving (P.Eq, P.Show)

-- ** HandleLogoutTypeHint
newtype HandleLogoutTypeHint = HandleLogoutTypeHint { unHandleLogoutTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** IdpCertAlias
newtype IdpCertAlias = IdpCertAlias { unIdpCertAlias :: Text } deriving (P.Eq, P.Show)

-- ** IdpCertAliasTypeHint
newtype IdpCertAliasTypeHint = IdpCertAliasTypeHint { unIdpCertAliasTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** IdpHttpRedirect
newtype IdpHttpRedirect = IdpHttpRedirect { unIdpHttpRedirect :: Bool } deriving (P.Eq, P.Show)

-- ** IdpHttpRedirectTypeHint
newtype IdpHttpRedirectTypeHint = IdpHttpRedirectTypeHint { unIdpHttpRedirectTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** IdpUrl
newtype IdpUrl = IdpUrl { unIdpUrl :: Text } deriving (P.Eq, P.Show)

-- ** IdpUrlTypeHint
newtype IdpUrlTypeHint = IdpUrlTypeHint { unIdpUrlTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Ignoredeactivated
newtype Ignoredeactivated = Ignoredeactivated { unIgnoredeactivated :: Bool } deriving (P.Eq, P.Show)

-- ** IntermediatePath
newtype IntermediatePath = IntermediatePath { unIntermediatePath :: Text } deriving (P.Eq, P.Show)

-- ** Jcrcontentcqdistribute
newtype Jcrcontentcqdistribute = Jcrcontentcqdistribute { unJcrcontentcqdistribute :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentcqdistributeTypeHint
newtype JcrcontentcqdistributeTypeHint = JcrcontentcqdistributeTypeHint { unJcrcontentcqdistributeTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Jcrcontentcqname
newtype Jcrcontentcqname = Jcrcontentcqname { unJcrcontentcqname :: Text } deriving (P.Eq, P.Show)

-- ** Jcrcontentcqtemplate
newtype Jcrcontentcqtemplate = Jcrcontentcqtemplate { unJcrcontentcqtemplate :: Text } deriving (P.Eq, P.Show)

-- ** Jcrcontentenabled
newtype Jcrcontentenabled = Jcrcontentenabled { unJcrcontentenabled :: Bool } deriving (P.Eq, P.Show)

-- ** Jcrcontentjcrdescription
newtype Jcrcontentjcrdescription = Jcrcontentjcrdescription { unJcrcontentjcrdescription :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentjcrlastModified
newtype JcrcontentjcrlastModified = JcrcontentjcrlastModified { unJcrcontentjcrlastModified :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentjcrlastModifiedBy
newtype JcrcontentjcrlastModifiedBy = JcrcontentjcrlastModifiedBy { unJcrcontentjcrlastModifiedBy :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentjcrmixinTypes
newtype JcrcontentjcrmixinTypes = JcrcontentjcrmixinTypes { unJcrcontentjcrmixinTypes :: Text } deriving (P.Eq, P.Show)

-- ** Jcrcontentjcrtitle
newtype Jcrcontentjcrtitle = Jcrcontentjcrtitle { unJcrcontentjcrtitle :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentlogLevel
newtype JcrcontentlogLevel = JcrcontentlogLevel { unJcrcontentlogLevel :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentnoStatusUpdate
newtype JcrcontentnoStatusUpdate = JcrcontentnoStatusUpdate { unJcrcontentnoStatusUpdate :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentnoVersioning
newtype JcrcontentnoVersioning = JcrcontentnoVersioning { unJcrcontentnoVersioning :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentprotocolConnectTimeout
newtype JcrcontentprotocolConnectTimeout = JcrcontentprotocolConnectTimeout { unJcrcontentprotocolConnectTimeout :: Double } deriving (P.Eq, P.Show)

-- ** JcrcontentprotocolHttpConnectionClosed
newtype JcrcontentprotocolHttpConnectionClosed = JcrcontentprotocolHttpConnectionClosed { unJcrcontentprotocolHttpConnectionClosed :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentprotocolHttpExpired
newtype JcrcontentprotocolHttpExpired = JcrcontentprotocolHttpExpired { unJcrcontentprotocolHttpExpired :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentprotocolHttpHeaders
newtype JcrcontentprotocolHttpHeaders = JcrcontentprotocolHttpHeaders { unJcrcontentprotocolHttpHeaders :: [Text] } deriving (P.Eq, P.Show)

-- ** JcrcontentprotocolHttpHeadersTypeHint
newtype JcrcontentprotocolHttpHeadersTypeHint = JcrcontentprotocolHttpHeadersTypeHint { unJcrcontentprotocolHttpHeadersTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentprotocolHttpMethod
newtype JcrcontentprotocolHttpMethod = JcrcontentprotocolHttpMethod { unJcrcontentprotocolHttpMethod :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentprotocolHttpsRelaxed
newtype JcrcontentprotocolHttpsRelaxed = JcrcontentprotocolHttpsRelaxed { unJcrcontentprotocolHttpsRelaxed :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentprotocolInterface
newtype JcrcontentprotocolInterface = JcrcontentprotocolInterface { unJcrcontentprotocolInterface :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentprotocolSocketTimeout
newtype JcrcontentprotocolSocketTimeout = JcrcontentprotocolSocketTimeout { unJcrcontentprotocolSocketTimeout :: Double } deriving (P.Eq, P.Show)

-- ** JcrcontentprotocolVersion
newtype JcrcontentprotocolVersion = JcrcontentprotocolVersion { unJcrcontentprotocolVersion :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentproxyHost
newtype JcrcontentproxyHost = JcrcontentproxyHost { unJcrcontentproxyHost :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentproxyNtlmDomain
newtype JcrcontentproxyNtlmDomain = JcrcontentproxyNtlmDomain { unJcrcontentproxyNtlmDomain :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentproxyNtlmHost
newtype JcrcontentproxyNtlmHost = JcrcontentproxyNtlmHost { unJcrcontentproxyNtlmHost :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentproxyPassword
newtype JcrcontentproxyPassword = JcrcontentproxyPassword { unJcrcontentproxyPassword :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentproxyPort
newtype JcrcontentproxyPort = JcrcontentproxyPort { unJcrcontentproxyPort :: Double } deriving (P.Eq, P.Show)

-- ** JcrcontentproxyUser
newtype JcrcontentproxyUser = JcrcontentproxyUser { unJcrcontentproxyUser :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentqueueBatchMaxSize
newtype JcrcontentqueueBatchMaxSize = JcrcontentqueueBatchMaxSize { unJcrcontentqueueBatchMaxSize :: Double } deriving (P.Eq, P.Show)

-- ** JcrcontentqueueBatchMode
newtype JcrcontentqueueBatchMode = JcrcontentqueueBatchMode { unJcrcontentqueueBatchMode :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentqueueBatchWaitTime
newtype JcrcontentqueueBatchWaitTime = JcrcontentqueueBatchWaitTime { unJcrcontentqueueBatchWaitTime :: Double } deriving (P.Eq, P.Show)

-- ** JcrcontentretryDelay
newtype JcrcontentretryDelay = JcrcontentretryDelay { unJcrcontentretryDelay :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentreverseReplication
newtype JcrcontentreverseReplication = JcrcontentreverseReplication { unJcrcontentreverseReplication :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentserializationType
newtype JcrcontentserializationType = JcrcontentserializationType { unJcrcontentserializationType :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentslingresourceType
newtype JcrcontentslingresourceType = JcrcontentslingresourceType { unJcrcontentslingresourceType :: Text } deriving (P.Eq, P.Show)

-- ** Jcrcontentssl
newtype Jcrcontentssl = Jcrcontentssl { unJcrcontentssl :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontenttransportNtlmDomain
newtype JcrcontenttransportNtlmDomain = JcrcontenttransportNtlmDomain { unJcrcontenttransportNtlmDomain :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontenttransportNtlmHost
newtype JcrcontenttransportNtlmHost = JcrcontenttransportNtlmHost { unJcrcontenttransportNtlmHost :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontenttransportPassword
newtype JcrcontenttransportPassword = JcrcontenttransportPassword { unJcrcontenttransportPassword :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontenttransportUri
newtype JcrcontenttransportUri = JcrcontenttransportUri { unJcrcontenttransportUri :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontenttransportUser
newtype JcrcontenttransportUser = JcrcontenttransportUser { unJcrcontenttransportUser :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontenttriggerDistribute
newtype JcrcontenttriggerDistribute = JcrcontenttriggerDistribute { unJcrcontenttriggerDistribute :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontenttriggerModified
newtype JcrcontenttriggerModified = JcrcontenttriggerModified { unJcrcontenttriggerModified :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontenttriggerOnOffTime
newtype JcrcontenttriggerOnOffTime = JcrcontenttriggerOnOffTime { unJcrcontenttriggerOnOffTime :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontenttriggerReceive
newtype JcrcontenttriggerReceive = JcrcontenttriggerReceive { unJcrcontenttriggerReceive :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontenttriggerSpecific
newtype JcrcontenttriggerSpecific = JcrcontenttriggerSpecific { unJcrcontenttriggerSpecific :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentuserId
newtype JcrcontentuserId = JcrcontentuserId { unJcrcontentuserId :: Text } deriving (P.Eq, P.Show)

-- ** JcrprimaryType
newtype JcrprimaryType = JcrprimaryType { unJcrprimaryType :: Text } deriving (P.Eq, P.Show)

-- ** JsonMaximumresults
newtype JsonMaximumresults = JsonMaximumresults { unJsonMaximumresults :: Text } deriving (P.Eq, P.Show)

-- ** JsonMaximumresultsTypeHint
newtype JsonMaximumresultsTypeHint = JsonMaximumresultsTypeHint { unJsonMaximumresultsTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** KeyPassword
newtype KeyPassword = KeyPassword { unKeyPassword :: Text } deriving (P.Eq, P.Show)

-- ** KeyStore
newtype KeyStore = KeyStore { unKeyStore :: FilePath } deriving (P.Eq, P.Show)

-- ** KeyStorePass
newtype KeyStorePass = KeyStorePass { unKeyStorePass :: Text } deriving (P.Eq, P.Show)

-- ** KeyStorePassword
newtype KeyStorePassword = KeyStorePassword { unKeyStorePassword :: Text } deriving (P.Eq, P.Show)

-- ** KeyStorePasswordTypeHint
newtype KeyStorePasswordTypeHint = KeyStorePasswordTypeHint { unKeyStorePasswordTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** KeyStoreType
newtype KeyStoreType = KeyStoreType { unKeyStoreType :: Text } deriving (P.Eq, P.Show)

-- ** Location
newtype Location = Location { unLocation :: Text } deriving (P.Eq, P.Show)

-- ** LogoutUrl
newtype LogoutUrl = LogoutUrl { unLogoutUrl :: Text } deriving (P.Eq, P.Show)

-- ** LogoutUrlTypeHint
newtype LogoutUrlTypeHint = LogoutUrlTypeHint { unLogoutUrlTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** NameIdFormat
newtype NameIdFormat = NameIdFormat { unNameIdFormat :: Text } deriving (P.Eq, P.Show)

-- ** NameIdFormatTypeHint
newtype NameIdFormatTypeHint = NameIdFormatTypeHint { unNameIdFormatTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** NewAlias
newtype NewAlias = NewAlias { unNewAlias :: Text } deriving (P.Eq, P.Show)

-- ** NewPassword
newtype NewPassword = NewPassword { unNewPassword :: Text } deriving (P.Eq, P.Show)

-- ** Old
newtype Old = Old { unOld :: Text } deriving (P.Eq, P.Show)

-- ** Onlymodified
newtype Onlymodified = Onlymodified { unOnlymodified :: Bool } deriving (P.Eq, P.Show)

-- ** Operation
newtype Operation = Operation { unOperation :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsClientcertificate
newtype OrgApacheFelixHttpsClientcertificate = OrgApacheFelixHttpsClientcertificate { unOrgApacheFelixHttpsClientcertificate :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsClientcertificateTypeHint
newtype OrgApacheFelixHttpsClientcertificateTypeHint = OrgApacheFelixHttpsClientcertificateTypeHint { unOrgApacheFelixHttpsClientcertificateTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsEnable
newtype OrgApacheFelixHttpsEnable = OrgApacheFelixHttpsEnable { unOrgApacheFelixHttpsEnable :: Bool } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsEnableTypeHint
newtype OrgApacheFelixHttpsEnableTypeHint = OrgApacheFelixHttpsEnableTypeHint { unOrgApacheFelixHttpsEnableTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystore
newtype OrgApacheFelixHttpsKeystore = OrgApacheFelixHttpsKeystore { unOrgApacheFelixHttpsKeystore :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystoreKey
newtype OrgApacheFelixHttpsKeystoreKey = OrgApacheFelixHttpsKeystoreKey { unOrgApacheFelixHttpsKeystoreKey :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystoreKeyPassword
newtype OrgApacheFelixHttpsKeystoreKeyPassword = OrgApacheFelixHttpsKeystoreKeyPassword { unOrgApacheFelixHttpsKeystoreKeyPassword :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystoreKeyPasswordTypeHint
newtype OrgApacheFelixHttpsKeystoreKeyPasswordTypeHint = OrgApacheFelixHttpsKeystoreKeyPasswordTypeHint { unOrgApacheFelixHttpsKeystoreKeyPasswordTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystoreKeyTypeHint
newtype OrgApacheFelixHttpsKeystoreKeyTypeHint = OrgApacheFelixHttpsKeystoreKeyTypeHint { unOrgApacheFelixHttpsKeystoreKeyTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystorePassword
newtype OrgApacheFelixHttpsKeystorePassword = OrgApacheFelixHttpsKeystorePassword { unOrgApacheFelixHttpsKeystorePassword :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystorePasswordTypeHint
newtype OrgApacheFelixHttpsKeystorePasswordTypeHint = OrgApacheFelixHttpsKeystorePasswordTypeHint { unOrgApacheFelixHttpsKeystorePasswordTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystoreTypeHint
newtype OrgApacheFelixHttpsKeystoreTypeHint = OrgApacheFelixHttpsKeystoreTypeHint { unOrgApacheFelixHttpsKeystoreTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsNio
newtype OrgApacheFelixHttpsNio = OrgApacheFelixHttpsNio { unOrgApacheFelixHttpsNio :: Bool } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsNioTypeHint
newtype OrgApacheFelixHttpsNioTypeHint = OrgApacheFelixHttpsNioTypeHint { unOrgApacheFelixHttpsNioTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsTruststore
newtype OrgApacheFelixHttpsTruststore = OrgApacheFelixHttpsTruststore { unOrgApacheFelixHttpsTruststore :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsTruststorePassword
newtype OrgApacheFelixHttpsTruststorePassword = OrgApacheFelixHttpsTruststorePassword { unOrgApacheFelixHttpsTruststorePassword :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsTruststorePasswordTypeHint
newtype OrgApacheFelixHttpsTruststorePasswordTypeHint = OrgApacheFelixHttpsTruststorePasswordTypeHint { unOrgApacheFelixHttpsTruststorePasswordTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsTruststoreTypeHint
newtype OrgApacheFelixHttpsTruststoreTypeHint = OrgApacheFelixHttpsTruststoreTypeHint { unOrgApacheFelixHttpsTruststoreTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgOsgiServiceHttpPortSecure
newtype OrgOsgiServiceHttpPortSecure = OrgOsgiServiceHttpPortSecure { unOrgOsgiServiceHttpPortSecure :: Text } deriving (P.Eq, P.Show)

-- ** OrgOsgiServiceHttpPortSecureTypeHint
newtype OrgOsgiServiceHttpPortSecureTypeHint = OrgOsgiServiceHttpPortSecureTypeHint { unOrgOsgiServiceHttpPortSecureTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** PLimit
newtype PLimit = PLimit { unPLimit :: Double } deriving (P.Eq, P.Show)

-- ** Package
newtype Package = Package { unPackage :: FilePath } deriving (P.Eq, P.Show)

-- ** PackageName
newtype PackageName = PackageName { unPackageName :: Text } deriving (P.Eq, P.Show)

-- ** PackageVersion
newtype PackageVersion = PackageVersion { unPackageVersion :: Text } deriving (P.Eq, P.Show)

-- ** Param1property
newtype Param1property = Param1property { unParam1property :: Text } deriving (P.Eq, P.Show)

-- ** Param1propertyValue
newtype Param1propertyValue = Param1propertyValue { unParam1propertyValue :: Text } deriving (P.Eq, P.Show)

-- ** Path
newtype Path = Path { unPath :: Text } deriving (P.Eq, P.Show)

-- ** PathTypeHint
newtype PathTypeHint = PathTypeHint { unPathTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Path[Text]
newtype Path[Text] = Path[Text] { unPath[Text] :: [Text] } deriving (P.Eq, P.Show)

-- ** Pk
newtype Pk = Pk { unPk :: FilePath } deriving (P.Eq, P.Show)

-- ** Plain
newtype Plain = Plain { unPlain :: Text } deriving (P.Eq, P.Show)

-- ** Post
newtype Post = Post { unPost :: Bool } deriving (P.Eq, P.Show)

-- ** ProfilegivenName
newtype ProfilegivenName = ProfilegivenName { unProfilegivenName :: Text } deriving (P.Eq, P.Show)

-- ** Propertylist
newtype Propertylist = Propertylist { unPropertylist :: [Text] } deriving (P.Eq, P.Show)

-- ** ProxyEnabled
newtype ProxyEnabled = ProxyEnabled { unProxyEnabled :: Bool } deriving (P.Eq, P.Show)

-- ** ProxyEnabledTypeHint
newtype ProxyEnabledTypeHint = ProxyEnabledTypeHint { unProxyEnabledTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** ProxyExceptions
newtype ProxyExceptions = ProxyExceptions { unProxyExceptions :: [Text] } deriving (P.Eq, P.Show)

-- ** ProxyExceptionsTypeHint
newtype ProxyExceptionsTypeHint = ProxyExceptionsTypeHint { unProxyExceptionsTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** ProxyHost
newtype ProxyHost = ProxyHost { unProxyHost :: Text } deriving (P.Eq, P.Show)

-- ** ProxyHostTypeHint
newtype ProxyHostTypeHint = ProxyHostTypeHint { unProxyHostTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** ProxyPassword
newtype ProxyPassword = ProxyPassword { unProxyPassword :: Text } deriving (P.Eq, P.Show)

-- ** ProxyPasswordTypeHint
newtype ProxyPasswordTypeHint = ProxyPasswordTypeHint { unProxyPasswordTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** ProxyPort
newtype ProxyPort = ProxyPort { unProxyPort :: Int } deriving (P.Eq, P.Show)

-- ** ProxyPortTypeHint
newtype ProxyPortTypeHint = ProxyPortTypeHint { unProxyPortTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** ProxyUser
newtype ProxyUser = ProxyUser { unProxyUser :: Text } deriving (P.Eq, P.Show)

-- ** ProxyUserTypeHint
newtype ProxyUserTypeHint = ProxyUserTypeHint { unProxyUserTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** PwdresetAuthorizables
newtype PwdresetAuthorizables = PwdresetAuthorizables { unPwdresetAuthorizables :: [Text] } deriving (P.Eq, P.Show)

-- ** PwdresetAuthorizablesTypeHint
newtype PwdresetAuthorizablesTypeHint = PwdresetAuthorizablesTypeHint { unPwdresetAuthorizablesTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** RePassword
newtype RePassword = RePassword { unRePassword :: Text } deriving (P.Eq, P.Show)

-- ** Recursive
newtype Recursive = Recursive { unRecursive :: Bool } deriving (P.Eq, P.Show)

-- ** RemoveAlias
newtype RemoveAlias = RemoveAlias { unRemoveAlias :: Text } deriving (P.Eq, P.Show)

-- ** Reppassword
newtype Reppassword = Reppassword { unReppassword :: Text } deriving (P.Eq, P.Show)

-- ** Runmode
newtype Runmode = Runmode { unRunmode :: Text } deriving (P.Eq, P.Show)

-- ** ServiceProviderEntityId
newtype ServiceProviderEntityId = ServiceProviderEntityId { unServiceProviderEntityId :: Text } deriving (P.Eq, P.Show)

-- ** ServiceProviderEntityIdTypeHint
newtype ServiceProviderEntityIdTypeHint = ServiceProviderEntityIdTypeHint { unServiceProviderEntityIdTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** ServiceRanking
newtype ServiceRanking = ServiceRanking { unServiceRanking :: Int } deriving (P.Eq, P.Show)

-- ** ServiceRankingTypeHint
newtype ServiceRankingTypeHint = ServiceRankingTypeHint { unServiceRankingTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** SignatureMethod
newtype SignatureMethod = SignatureMethod { unSignatureMethod :: Text } deriving (P.Eq, P.Show)

-- ** SignatureMethodTypeHint
newtype SignatureMethodTypeHint = SignatureMethodTypeHint { unSignatureMethodTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** SpPrivateKeyAlias
newtype SpPrivateKeyAlias = SpPrivateKeyAlias { unSpPrivateKeyAlias :: Text } deriving (P.Eq, P.Show)

-- ** SpPrivateKeyAliasTypeHint
newtype SpPrivateKeyAliasTypeHint = SpPrivateKeyAliasTypeHint { unSpPrivateKeyAliasTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** SynchronizeAttributes
newtype SynchronizeAttributes = SynchronizeAttributes { unSynchronizeAttributes :: [Text] } deriving (P.Eq, P.Show)

-- ** SynchronizeAttributesTypeHint
newtype SynchronizeAttributesTypeHint = SynchronizeAttributesTypeHint { unSynchronizeAttributesTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Tags
newtype Tags = Tags { unTags :: Text } deriving (P.Eq, P.Show)

-- ** TruststoreP12
newtype TruststoreP12 = TruststoreP12 { unTruststoreP12 :: FilePath } deriving (P.Eq, P.Show)

-- ** UseEncryption
newtype UseEncryption = UseEncryption { unUseEncryption :: Bool } deriving (P.Eq, P.Show)

-- ** UseEncryptionTypeHint
newtype UseEncryptionTypeHint = UseEncryptionTypeHint { unUseEncryptionTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** UserIdAttribute
newtype UserIdAttribute = UserIdAttribute { unUserIdAttribute :: Text } deriving (P.Eq, P.Show)

-- ** UserIdAttributeTypeHint
newtype UserIdAttributeTypeHint = UserIdAttributeTypeHint { unUserIdAttributeTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** UserIntermediatePath
newtype UserIntermediatePath = UserIntermediatePath { unUserIntermediatePath :: Text } deriving (P.Eq, P.Show)

-- ** UserIntermediatePathTypeHint
newtype UserIntermediatePathTypeHint = UserIntermediatePathTypeHint { unUserIntermediatePathTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Verify
newtype Verify = Verify { unVerify :: Text } deriving (P.Eq, P.Show)

-- ** Version
newtype Version = Version { unVersion :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** InstallStatus
-- | InstallStatus
data InstallStatus = InstallStatus
  { installStatusStatus :: !(Maybe InstallStatusStatus) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstallStatus
instance A.FromJSON InstallStatus where
  parseJSON = A.withObject "InstallStatus" $ \o ->
    InstallStatus
      <$> (o .:? "status")

-- | ToJSON InstallStatus
instance A.ToJSON InstallStatus where
  toJSON InstallStatus {..} =
   _omitNulls
      [ "status" .= installStatusStatus
      ]


-- | Construct a value of type 'InstallStatus' (by applying it's required fields, if any)
mkInstallStatus
  :: InstallStatus
mkInstallStatus =
  InstallStatus
  { installStatusStatus = Nothing
  }

-- ** InstallStatusStatus
-- | InstallStatusStatus
data InstallStatusStatus = InstallStatusStatus
  { installStatusStatusFinished :: !(Maybe Bool) -- ^ "finished"
  , installStatusStatusItemCount :: !(Maybe Int) -- ^ "itemCount"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstallStatusStatus
instance A.FromJSON InstallStatusStatus where
  parseJSON = A.withObject "InstallStatusStatus" $ \o ->
    InstallStatusStatus
      <$> (o .:? "finished")
      <*> (o .:? "itemCount")

-- | ToJSON InstallStatusStatus
instance A.ToJSON InstallStatusStatus where
  toJSON InstallStatusStatus {..} =
   _omitNulls
      [ "finished" .= installStatusStatusFinished
      , "itemCount" .= installStatusStatusItemCount
      ]


-- | Construct a value of type 'InstallStatusStatus' (by applying it's required fields, if any)
mkInstallStatusStatus
  :: InstallStatusStatus
mkInstallStatusStatus =
  InstallStatusStatus
  { installStatusStatusFinished = Nothing
  , installStatusStatusItemCount = Nothing
  }

-- ** KeystoreChainItems
-- | KeystoreChainItems
data KeystoreChainItems = KeystoreChainItems
  { keystoreChainItemsSubject :: !(Maybe Text) -- ^ "subject" - e.g. \&quot;CN&#x3D;localhost\&quot;
  , keystoreChainItemsIssuer :: !(Maybe Text) -- ^ "issuer" - e.g. \&quot;CN&#x3D;Admin\&quot;
  , keystoreChainItemsNotBefore :: !(Maybe Text) -- ^ "notBefore" - e.g. \&quot;Sun Jul 01 12:00:00 AEST 2018\&quot;
  , keystoreChainItemsNotAfter :: !(Maybe Text) -- ^ "notAfter" - e.g. \&quot;Sun Jun 30 23:59:50 AEST 2019\&quot;
  , keystoreChainItemsSerialNumber :: !(Maybe Int) -- ^ "serialNumber" - 18165099476682912368
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON KeystoreChainItems
instance A.FromJSON KeystoreChainItems where
  parseJSON = A.withObject "KeystoreChainItems" $ \o ->
    KeystoreChainItems
      <$> (o .:? "subject")
      <*> (o .:? "issuer")
      <*> (o .:? "notBefore")
      <*> (o .:? "notAfter")
      <*> (o .:? "serialNumber")

-- | ToJSON KeystoreChainItems
instance A.ToJSON KeystoreChainItems where
  toJSON KeystoreChainItems {..} =
   _omitNulls
      [ "subject" .= keystoreChainItemsSubject
      , "issuer" .= keystoreChainItemsIssuer
      , "notBefore" .= keystoreChainItemsNotBefore
      , "notAfter" .= keystoreChainItemsNotAfter
      , "serialNumber" .= keystoreChainItemsSerialNumber
      ]


-- | Construct a value of type 'KeystoreChainItems' (by applying it's required fields, if any)
mkKeystoreChainItems
  :: KeystoreChainItems
mkKeystoreChainItems =
  KeystoreChainItems
  { keystoreChainItemsSubject = Nothing
  , keystoreChainItemsIssuer = Nothing
  , keystoreChainItemsNotBefore = Nothing
  , keystoreChainItemsNotAfter = Nothing
  , keystoreChainItemsSerialNumber = Nothing
  }

-- ** KeystoreInfo
-- | KeystoreInfo
data KeystoreInfo = KeystoreInfo
  { keystoreInfoAliases :: !(Maybe [KeystoreItems]) -- ^ "aliases"
  , keystoreInfoExists :: !(Maybe Bool) -- ^ "exists" - False if truststore don&#39;t exist
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON KeystoreInfo
instance A.FromJSON KeystoreInfo where
  parseJSON = A.withObject "KeystoreInfo" $ \o ->
    KeystoreInfo
      <$> (o .:? "aliases")
      <*> (o .:? "exists")

-- | ToJSON KeystoreInfo
instance A.ToJSON KeystoreInfo where
  toJSON KeystoreInfo {..} =
   _omitNulls
      [ "aliases" .= keystoreInfoAliases
      , "exists" .= keystoreInfoExists
      ]


-- | Construct a value of type 'KeystoreInfo' (by applying it's required fields, if any)
mkKeystoreInfo
  :: KeystoreInfo
mkKeystoreInfo =
  KeystoreInfo
  { keystoreInfoAliases = Nothing
  , keystoreInfoExists = Nothing
  }

-- ** KeystoreItems
-- | KeystoreItems
data KeystoreItems = KeystoreItems
  { keystoreItemsAlias :: !(Maybe Text) -- ^ "alias" - Keystore alias name
  , keystoreItemsEntryType :: !(Maybe Text) -- ^ "entryType" - e.g. \&quot;privateKey\&quot;
  , keystoreItemsAlgorithm :: !(Maybe Text) -- ^ "algorithm" - e.g. \&quot;RSA\&quot;
  , keystoreItemsFormat :: !(Maybe Text) -- ^ "format" - e.g. \&quot;PKCS#8\&quot;
  , keystoreItemsChain :: !(Maybe [KeystoreChainItems]) -- ^ "chain"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON KeystoreItems
instance A.FromJSON KeystoreItems where
  parseJSON = A.withObject "KeystoreItems" $ \o ->
    KeystoreItems
      <$> (o .:? "alias")
      <*> (o .:? "entryType")
      <*> (o .:? "algorithm")
      <*> (o .:? "format")
      <*> (o .:? "chain")

-- | ToJSON KeystoreItems
instance A.ToJSON KeystoreItems where
  toJSON KeystoreItems {..} =
   _omitNulls
      [ "alias" .= keystoreItemsAlias
      , "entryType" .= keystoreItemsEntryType
      , "algorithm" .= keystoreItemsAlgorithm
      , "format" .= keystoreItemsFormat
      , "chain" .= keystoreItemsChain
      ]


-- | Construct a value of type 'KeystoreItems' (by applying it's required fields, if any)
mkKeystoreItems
  :: KeystoreItems
mkKeystoreItems =
  KeystoreItems
  { keystoreItemsAlias = Nothing
  , keystoreItemsEntryType = Nothing
  , keystoreItemsAlgorithm = Nothing
  , keystoreItemsFormat = Nothing
  , keystoreItemsChain = Nothing
  }

-- ** SamlConfigurationInfo
-- | SamlConfigurationInfo
data SamlConfigurationInfo = SamlConfigurationInfo
  { samlConfigurationInfoPid :: !(Maybe Text) -- ^ "pid" - Persistent Identity (PID)
  , samlConfigurationInfoTitle :: !(Maybe Text) -- ^ "title" - Title
  , samlConfigurationInfoDescription :: !(Maybe Text) -- ^ "description" - Title
  , samlConfigurationInfoBundleLocation :: !(Maybe Text) -- ^ "bundle_location" - needed for configuration binding
  , samlConfigurationInfoServiceLocation :: !(Maybe Text) -- ^ "service_location" - needed for configuraiton binding
  , samlConfigurationInfoProperties :: !(Maybe SamlConfigurationProperties) -- ^ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlConfigurationInfo
instance A.FromJSON SamlConfigurationInfo where
  parseJSON = A.withObject "SamlConfigurationInfo" $ \o ->
    SamlConfigurationInfo
      <$> (o .:? "pid")
      <*> (o .:? "title")
      <*> (o .:? "description")
      <*> (o .:? "bundle_location")
      <*> (o .:? "service_location")
      <*> (o .:? "properties")

-- | ToJSON SamlConfigurationInfo
instance A.ToJSON SamlConfigurationInfo where
  toJSON SamlConfigurationInfo {..} =
   _omitNulls
      [ "pid" .= samlConfigurationInfoPid
      , "title" .= samlConfigurationInfoTitle
      , "description" .= samlConfigurationInfoDescription
      , "bundle_location" .= samlConfigurationInfoBundleLocation
      , "service_location" .= samlConfigurationInfoServiceLocation
      , "properties" .= samlConfigurationInfoProperties
      ]


-- | Construct a value of type 'SamlConfigurationInfo' (by applying it's required fields, if any)
mkSamlConfigurationInfo
  :: SamlConfigurationInfo
mkSamlConfigurationInfo =
  SamlConfigurationInfo
  { samlConfigurationInfoPid = Nothing
  , samlConfigurationInfoTitle = Nothing
  , samlConfigurationInfoDescription = Nothing
  , samlConfigurationInfoBundleLocation = Nothing
  , samlConfigurationInfoServiceLocation = Nothing
  , samlConfigurationInfoProperties = Nothing
  }

-- ** SamlConfigurationProperties
-- | SamlConfigurationProperties
data SamlConfigurationProperties = SamlConfigurationProperties
  { samlConfigurationPropertiesPath :: !(Maybe SamlConfigurationPropertyItemsArray) -- ^ "path"
  , samlConfigurationPropertiesServiceRanking :: !(Maybe SamlConfigurationPropertyItemsLong) -- ^ "service.ranking"
  , samlConfigurationPropertiesIdpUrl :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "idpUrl"
  , samlConfigurationPropertiesIdpCertAlias :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "idpCertAlias"
  , samlConfigurationPropertiesIdpHttpRedirect :: !(Maybe SamlConfigurationPropertyItemsBoolean) -- ^ "idpHttpRedirect"
  , samlConfigurationPropertiesServiceProviderEntityId :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "serviceProviderEntityId"
  , samlConfigurationPropertiesAssertionConsumerServiceUrl :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "assertionConsumerServiceURL"
  , samlConfigurationPropertiesSpPrivateKeyAlias :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "spPrivateKeyAlias"
  , samlConfigurationPropertiesKeyStorePassword :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "keyStorePassword"
  , samlConfigurationPropertiesDefaultRedirectUrl :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "defaultRedirectUrl"
  , samlConfigurationPropertiesUserIdAttribute :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "userIDAttribute"
  , samlConfigurationPropertiesUseEncryption :: !(Maybe SamlConfigurationPropertyItemsBoolean) -- ^ "useEncryption"
  , samlConfigurationPropertiesCreateUser :: !(Maybe SamlConfigurationPropertyItemsBoolean) -- ^ "createUser"
  , samlConfigurationPropertiesAddGroupMemberships :: !(Maybe SamlConfigurationPropertyItemsBoolean) -- ^ "addGroupMemberships"
  , samlConfigurationPropertiesGroupMembershipAttribute :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "groupMembershipAttribute"
  , samlConfigurationPropertiesDefaultGroups :: !(Maybe SamlConfigurationPropertyItemsArray) -- ^ "defaultGroups"
  , samlConfigurationPropertiesNameIdFormat :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "nameIdFormat"
  , samlConfigurationPropertiesSynchronizeAttributes :: !(Maybe SamlConfigurationPropertyItemsArray) -- ^ "synchronizeAttributes"
  , samlConfigurationPropertiesHandleLogout :: !(Maybe SamlConfigurationPropertyItemsBoolean) -- ^ "handleLogout"
  , samlConfigurationPropertiesLogoutUrl :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "logoutUrl"
  , samlConfigurationPropertiesClockTolerance :: !(Maybe SamlConfigurationPropertyItemsLong) -- ^ "clockTolerance"
  , samlConfigurationPropertiesDigestMethod :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "digestMethod"
  , samlConfigurationPropertiesSignatureMethod :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "signatureMethod"
  , samlConfigurationPropertiesUserIntermediatePath :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "userIntermediatePath"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlConfigurationProperties
instance A.FromJSON SamlConfigurationProperties where
  parseJSON = A.withObject "SamlConfigurationProperties" $ \o ->
    SamlConfigurationProperties
      <$> (o .:? "path")
      <*> (o .:? "service.ranking")
      <*> (o .:? "idpUrl")
      <*> (o .:? "idpCertAlias")
      <*> (o .:? "idpHttpRedirect")
      <*> (o .:? "serviceProviderEntityId")
      <*> (o .:? "assertionConsumerServiceURL")
      <*> (o .:? "spPrivateKeyAlias")
      <*> (o .:? "keyStorePassword")
      <*> (o .:? "defaultRedirectUrl")
      <*> (o .:? "userIDAttribute")
      <*> (o .:? "useEncryption")
      <*> (o .:? "createUser")
      <*> (o .:? "addGroupMemberships")
      <*> (o .:? "groupMembershipAttribute")
      <*> (o .:? "defaultGroups")
      <*> (o .:? "nameIdFormat")
      <*> (o .:? "synchronizeAttributes")
      <*> (o .:? "handleLogout")
      <*> (o .:? "logoutUrl")
      <*> (o .:? "clockTolerance")
      <*> (o .:? "digestMethod")
      <*> (o .:? "signatureMethod")
      <*> (o .:? "userIntermediatePath")

-- | ToJSON SamlConfigurationProperties
instance A.ToJSON SamlConfigurationProperties where
  toJSON SamlConfigurationProperties {..} =
   _omitNulls
      [ "path" .= samlConfigurationPropertiesPath
      , "service.ranking" .= samlConfigurationPropertiesServiceRanking
      , "idpUrl" .= samlConfigurationPropertiesIdpUrl
      , "idpCertAlias" .= samlConfigurationPropertiesIdpCertAlias
      , "idpHttpRedirect" .= samlConfigurationPropertiesIdpHttpRedirect
      , "serviceProviderEntityId" .= samlConfigurationPropertiesServiceProviderEntityId
      , "assertionConsumerServiceURL" .= samlConfigurationPropertiesAssertionConsumerServiceUrl
      , "spPrivateKeyAlias" .= samlConfigurationPropertiesSpPrivateKeyAlias
      , "keyStorePassword" .= samlConfigurationPropertiesKeyStorePassword
      , "defaultRedirectUrl" .= samlConfigurationPropertiesDefaultRedirectUrl
      , "userIDAttribute" .= samlConfigurationPropertiesUserIdAttribute
      , "useEncryption" .= samlConfigurationPropertiesUseEncryption
      , "createUser" .= samlConfigurationPropertiesCreateUser
      , "addGroupMemberships" .= samlConfigurationPropertiesAddGroupMemberships
      , "groupMembershipAttribute" .= samlConfigurationPropertiesGroupMembershipAttribute
      , "defaultGroups" .= samlConfigurationPropertiesDefaultGroups
      , "nameIdFormat" .= samlConfigurationPropertiesNameIdFormat
      , "synchronizeAttributes" .= samlConfigurationPropertiesSynchronizeAttributes
      , "handleLogout" .= samlConfigurationPropertiesHandleLogout
      , "logoutUrl" .= samlConfigurationPropertiesLogoutUrl
      , "clockTolerance" .= samlConfigurationPropertiesClockTolerance
      , "digestMethod" .= samlConfigurationPropertiesDigestMethod
      , "signatureMethod" .= samlConfigurationPropertiesSignatureMethod
      , "userIntermediatePath" .= samlConfigurationPropertiesUserIntermediatePath
      ]


-- | Construct a value of type 'SamlConfigurationProperties' (by applying it's required fields, if any)
mkSamlConfigurationProperties
  :: SamlConfigurationProperties
mkSamlConfigurationProperties =
  SamlConfigurationProperties
  { samlConfigurationPropertiesPath = Nothing
  , samlConfigurationPropertiesServiceRanking = Nothing
  , samlConfigurationPropertiesIdpUrl = Nothing
  , samlConfigurationPropertiesIdpCertAlias = Nothing
  , samlConfigurationPropertiesIdpHttpRedirect = Nothing
  , samlConfigurationPropertiesServiceProviderEntityId = Nothing
  , samlConfigurationPropertiesAssertionConsumerServiceUrl = Nothing
  , samlConfigurationPropertiesSpPrivateKeyAlias = Nothing
  , samlConfigurationPropertiesKeyStorePassword = Nothing
  , samlConfigurationPropertiesDefaultRedirectUrl = Nothing
  , samlConfigurationPropertiesUserIdAttribute = Nothing
  , samlConfigurationPropertiesUseEncryption = Nothing
  , samlConfigurationPropertiesCreateUser = Nothing
  , samlConfigurationPropertiesAddGroupMemberships = Nothing
  , samlConfigurationPropertiesGroupMembershipAttribute = Nothing
  , samlConfigurationPropertiesDefaultGroups = Nothing
  , samlConfigurationPropertiesNameIdFormat = Nothing
  , samlConfigurationPropertiesSynchronizeAttributes = Nothing
  , samlConfigurationPropertiesHandleLogout = Nothing
  , samlConfigurationPropertiesLogoutUrl = Nothing
  , samlConfigurationPropertiesClockTolerance = Nothing
  , samlConfigurationPropertiesDigestMethod = Nothing
  , samlConfigurationPropertiesSignatureMethod = Nothing
  , samlConfigurationPropertiesUserIntermediatePath = Nothing
  }

-- ** SamlConfigurationPropertyItemsArray
-- | SamlConfigurationPropertyItemsArray
data SamlConfigurationPropertyItemsArray = SamlConfigurationPropertyItemsArray
  { samlConfigurationPropertyItemsArrayName :: !(Maybe Text) -- ^ "name" - property name
  , samlConfigurationPropertyItemsArrayOptional :: !(Maybe Bool) -- ^ "optional" - True if optional
  , samlConfigurationPropertyItemsArrayIsSet :: !(Maybe Bool) -- ^ "is_set" - True if property is set
  , samlConfigurationPropertyItemsArrayType :: !(Maybe Int) -- ^ "type" - Property type, 1&#x3D;String, 3&#x3D;long, 11&#x3D;boolean, 12&#x3D;Password
  , samlConfigurationPropertyItemsArrayValues :: !(Maybe [Text]) -- ^ "values" - Property value
  , samlConfigurationPropertyItemsArrayDescription :: !(Maybe Text) -- ^ "description" - Property description
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlConfigurationPropertyItemsArray
instance A.FromJSON SamlConfigurationPropertyItemsArray where
  parseJSON = A.withObject "SamlConfigurationPropertyItemsArray" $ \o ->
    SamlConfigurationPropertyItemsArray
      <$> (o .:? "name")
      <*> (o .:? "optional")
      <*> (o .:? "is_set")
      <*> (o .:? "type")
      <*> (o .:? "values")
      <*> (o .:? "description")

-- | ToJSON SamlConfigurationPropertyItemsArray
instance A.ToJSON SamlConfigurationPropertyItemsArray where
  toJSON SamlConfigurationPropertyItemsArray {..} =
   _omitNulls
      [ "name" .= samlConfigurationPropertyItemsArrayName
      , "optional" .= samlConfigurationPropertyItemsArrayOptional
      , "is_set" .= samlConfigurationPropertyItemsArrayIsSet
      , "type" .= samlConfigurationPropertyItemsArrayType
      , "values" .= samlConfigurationPropertyItemsArrayValues
      , "description" .= samlConfigurationPropertyItemsArrayDescription
      ]


-- | Construct a value of type 'SamlConfigurationPropertyItemsArray' (by applying it's required fields, if any)
mkSamlConfigurationPropertyItemsArray
  :: SamlConfigurationPropertyItemsArray
mkSamlConfigurationPropertyItemsArray =
  SamlConfigurationPropertyItemsArray
  { samlConfigurationPropertyItemsArrayName = Nothing
  , samlConfigurationPropertyItemsArrayOptional = Nothing
  , samlConfigurationPropertyItemsArrayIsSet = Nothing
  , samlConfigurationPropertyItemsArrayType = Nothing
  , samlConfigurationPropertyItemsArrayValues = Nothing
  , samlConfigurationPropertyItemsArrayDescription = Nothing
  }

-- ** SamlConfigurationPropertyItemsBoolean
-- | SamlConfigurationPropertyItemsBoolean
data SamlConfigurationPropertyItemsBoolean = SamlConfigurationPropertyItemsBoolean
  { samlConfigurationPropertyItemsBooleanName :: !(Maybe Text) -- ^ "name" - property name
  , samlConfigurationPropertyItemsBooleanOptional :: !(Maybe Bool) -- ^ "optional" - True if optional
  , samlConfigurationPropertyItemsBooleanIsSet :: !(Maybe Bool) -- ^ "is_set" - True if property is set
  , samlConfigurationPropertyItemsBooleanType :: !(Maybe Int) -- ^ "type" - Property type, 1&#x3D;String, 3&#x3D;long, 11&#x3D;boolean, 12&#x3D;Password
  , samlConfigurationPropertyItemsBooleanValue :: !(Maybe Bool) -- ^ "value" - Property value
  , samlConfigurationPropertyItemsBooleanDescription :: !(Maybe Text) -- ^ "description" - Property description
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlConfigurationPropertyItemsBoolean
instance A.FromJSON SamlConfigurationPropertyItemsBoolean where
  parseJSON = A.withObject "SamlConfigurationPropertyItemsBoolean" $ \o ->
    SamlConfigurationPropertyItemsBoolean
      <$> (o .:? "name")
      <*> (o .:? "optional")
      <*> (o .:? "is_set")
      <*> (o .:? "type")
      <*> (o .:? "value")
      <*> (o .:? "description")

-- | ToJSON SamlConfigurationPropertyItemsBoolean
instance A.ToJSON SamlConfigurationPropertyItemsBoolean where
  toJSON SamlConfigurationPropertyItemsBoolean {..} =
   _omitNulls
      [ "name" .= samlConfigurationPropertyItemsBooleanName
      , "optional" .= samlConfigurationPropertyItemsBooleanOptional
      , "is_set" .= samlConfigurationPropertyItemsBooleanIsSet
      , "type" .= samlConfigurationPropertyItemsBooleanType
      , "value" .= samlConfigurationPropertyItemsBooleanValue
      , "description" .= samlConfigurationPropertyItemsBooleanDescription
      ]


-- | Construct a value of type 'SamlConfigurationPropertyItemsBoolean' (by applying it's required fields, if any)
mkSamlConfigurationPropertyItemsBoolean
  :: SamlConfigurationPropertyItemsBoolean
mkSamlConfigurationPropertyItemsBoolean =
  SamlConfigurationPropertyItemsBoolean
  { samlConfigurationPropertyItemsBooleanName = Nothing
  , samlConfigurationPropertyItemsBooleanOptional = Nothing
  , samlConfigurationPropertyItemsBooleanIsSet = Nothing
  , samlConfigurationPropertyItemsBooleanType = Nothing
  , samlConfigurationPropertyItemsBooleanValue = Nothing
  , samlConfigurationPropertyItemsBooleanDescription = Nothing
  }

-- ** SamlConfigurationPropertyItemsLong
-- | SamlConfigurationPropertyItemsLong
data SamlConfigurationPropertyItemsLong = SamlConfigurationPropertyItemsLong
  { samlConfigurationPropertyItemsLongName :: !(Maybe Text) -- ^ "name" - property name
  , samlConfigurationPropertyItemsLongOptional :: !(Maybe Bool) -- ^ "optional" - True if optional
  , samlConfigurationPropertyItemsLongIsSet :: !(Maybe Bool) -- ^ "is_set" - True if property is set
  , samlConfigurationPropertyItemsLongType :: !(Maybe Int) -- ^ "type" - Property type, 1&#x3D;String, 3&#x3D;long, 11&#x3D;boolean, 12&#x3D;Password
  , samlConfigurationPropertyItemsLongValue :: !(Maybe Int) -- ^ "value" - Property value
  , samlConfigurationPropertyItemsLongDescription :: !(Maybe Text) -- ^ "description" - Property description
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlConfigurationPropertyItemsLong
instance A.FromJSON SamlConfigurationPropertyItemsLong where
  parseJSON = A.withObject "SamlConfigurationPropertyItemsLong" $ \o ->
    SamlConfigurationPropertyItemsLong
      <$> (o .:? "name")
      <*> (o .:? "optional")
      <*> (o .:? "is_set")
      <*> (o .:? "type")
      <*> (o .:? "value")
      <*> (o .:? "description")

-- | ToJSON SamlConfigurationPropertyItemsLong
instance A.ToJSON SamlConfigurationPropertyItemsLong where
  toJSON SamlConfigurationPropertyItemsLong {..} =
   _omitNulls
      [ "name" .= samlConfigurationPropertyItemsLongName
      , "optional" .= samlConfigurationPropertyItemsLongOptional
      , "is_set" .= samlConfigurationPropertyItemsLongIsSet
      , "type" .= samlConfigurationPropertyItemsLongType
      , "value" .= samlConfigurationPropertyItemsLongValue
      , "description" .= samlConfigurationPropertyItemsLongDescription
      ]


-- | Construct a value of type 'SamlConfigurationPropertyItemsLong' (by applying it's required fields, if any)
mkSamlConfigurationPropertyItemsLong
  :: SamlConfigurationPropertyItemsLong
mkSamlConfigurationPropertyItemsLong =
  SamlConfigurationPropertyItemsLong
  { samlConfigurationPropertyItemsLongName = Nothing
  , samlConfigurationPropertyItemsLongOptional = Nothing
  , samlConfigurationPropertyItemsLongIsSet = Nothing
  , samlConfigurationPropertyItemsLongType = Nothing
  , samlConfigurationPropertyItemsLongValue = Nothing
  , samlConfigurationPropertyItemsLongDescription = Nothing
  }

-- ** SamlConfigurationPropertyItemsString
-- | SamlConfigurationPropertyItemsString
data SamlConfigurationPropertyItemsString = SamlConfigurationPropertyItemsString
  { samlConfigurationPropertyItemsStringName :: !(Maybe Text) -- ^ "name" - property name
  , samlConfigurationPropertyItemsStringOptional :: !(Maybe Bool) -- ^ "optional" - True if optional
  , samlConfigurationPropertyItemsStringIsSet :: !(Maybe Bool) -- ^ "is_set" - True if property is set
  , samlConfigurationPropertyItemsStringType :: !(Maybe Int) -- ^ "type" - Property type, 1&#x3D;String, 3&#x3D;long, 11&#x3D;boolean, 12&#x3D;Password
  , samlConfigurationPropertyItemsStringValue :: !(Maybe Text) -- ^ "value" - Property value
  , samlConfigurationPropertyItemsStringDescription :: !(Maybe Text) -- ^ "description" - Property description
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlConfigurationPropertyItemsString
instance A.FromJSON SamlConfigurationPropertyItemsString where
  parseJSON = A.withObject "SamlConfigurationPropertyItemsString" $ \o ->
    SamlConfigurationPropertyItemsString
      <$> (o .:? "name")
      <*> (o .:? "optional")
      <*> (o .:? "is_set")
      <*> (o .:? "type")
      <*> (o .:? "value")
      <*> (o .:? "description")

-- | ToJSON SamlConfigurationPropertyItemsString
instance A.ToJSON SamlConfigurationPropertyItemsString where
  toJSON SamlConfigurationPropertyItemsString {..} =
   _omitNulls
      [ "name" .= samlConfigurationPropertyItemsStringName
      , "optional" .= samlConfigurationPropertyItemsStringOptional
      , "is_set" .= samlConfigurationPropertyItemsStringIsSet
      , "type" .= samlConfigurationPropertyItemsStringType
      , "value" .= samlConfigurationPropertyItemsStringValue
      , "description" .= samlConfigurationPropertyItemsStringDescription
      ]


-- | Construct a value of type 'SamlConfigurationPropertyItemsString' (by applying it's required fields, if any)
mkSamlConfigurationPropertyItemsString
  :: SamlConfigurationPropertyItemsString
mkSamlConfigurationPropertyItemsString =
  SamlConfigurationPropertyItemsString
  { samlConfigurationPropertyItemsStringName = Nothing
  , samlConfigurationPropertyItemsStringOptional = Nothing
  , samlConfigurationPropertyItemsStringIsSet = Nothing
  , samlConfigurationPropertyItemsStringType = Nothing
  , samlConfigurationPropertyItemsStringValue = Nothing
  , samlConfigurationPropertyItemsStringDescription = Nothing
  }

-- ** TruststoreInfo
-- | TruststoreInfo
data TruststoreInfo = TruststoreInfo
  { truststoreInfoAliases :: !(Maybe [TruststoreItems]) -- ^ "aliases"
  , truststoreInfoExists :: !(Maybe Bool) -- ^ "exists" - False if truststore don&#39;t exist
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TruststoreInfo
instance A.FromJSON TruststoreInfo where
  parseJSON = A.withObject "TruststoreInfo" $ \o ->
    TruststoreInfo
      <$> (o .:? "aliases")
      <*> (o .:? "exists")

-- | ToJSON TruststoreInfo
instance A.ToJSON TruststoreInfo where
  toJSON TruststoreInfo {..} =
   _omitNulls
      [ "aliases" .= truststoreInfoAliases
      , "exists" .= truststoreInfoExists
      ]


-- | Construct a value of type 'TruststoreInfo' (by applying it's required fields, if any)
mkTruststoreInfo
  :: TruststoreInfo
mkTruststoreInfo =
  TruststoreInfo
  { truststoreInfoAliases = Nothing
  , truststoreInfoExists = Nothing
  }

-- ** TruststoreItems
-- | TruststoreItems
data TruststoreItems = TruststoreItems
  { truststoreItemsAlias :: !(Maybe Text) -- ^ "alias" - Truststore alias name
  , truststoreItemsEntryType :: !(Maybe Text) -- ^ "entryType"
  , truststoreItemsSubject :: !(Maybe Text) -- ^ "subject" - e.g. \&quot;CN&#x3D;localhost\&quot;
  , truststoreItemsIssuer :: !(Maybe Text) -- ^ "issuer" - e.g. \&quot;CN&#x3D;Admin\&quot;
  , truststoreItemsNotBefore :: !(Maybe Text) -- ^ "notBefore" - e.g. \&quot;Sun Jul 01 12:00:00 AEST 2018\&quot;
  , truststoreItemsNotAfter :: !(Maybe Text) -- ^ "notAfter" - e.g. \&quot;Sun Jun 30 23:59:50 AEST 2019\&quot;
  , truststoreItemsSerialNumber :: !(Maybe Int) -- ^ "serialNumber" - 18165099476682912368
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TruststoreItems
instance A.FromJSON TruststoreItems where
  parseJSON = A.withObject "TruststoreItems" $ \o ->
    TruststoreItems
      <$> (o .:? "alias")
      <*> (o .:? "entryType")
      <*> (o .:? "subject")
      <*> (o .:? "issuer")
      <*> (o .:? "notBefore")
      <*> (o .:? "notAfter")
      <*> (o .:? "serialNumber")

-- | ToJSON TruststoreItems
instance A.ToJSON TruststoreItems where
  toJSON TruststoreItems {..} =
   _omitNulls
      [ "alias" .= truststoreItemsAlias
      , "entryType" .= truststoreItemsEntryType
      , "subject" .= truststoreItemsSubject
      , "issuer" .= truststoreItemsIssuer
      , "notBefore" .= truststoreItemsNotBefore
      , "notAfter" .= truststoreItemsNotAfter
      , "serialNumber" .= truststoreItemsSerialNumber
      ]


-- | Construct a value of type 'TruststoreItems' (by applying it's required fields, if any)
mkTruststoreItems
  :: TruststoreItems
mkTruststoreItems =
  TruststoreItems
  { truststoreItemsAlias = Nothing
  , truststoreItemsEntryType = Nothing
  , truststoreItemsSubject = Nothing
  , truststoreItemsIssuer = Nothing
  , truststoreItemsNotBefore = Nothing
  , truststoreItemsNotAfter = Nothing
  , truststoreItemsSerialNumber = Nothing
  }




-- * Auth Methods

-- ** AuthBasicAemAuth
data AuthBasicAemAuth =
  AuthBasicAemAuth B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicAemAuth where
  applyAuthMethod _ a@(AuthBasicAemAuth user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])

