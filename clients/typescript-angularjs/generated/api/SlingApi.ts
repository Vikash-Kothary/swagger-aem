/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * OpenAPI spec version: 3.2.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as models from '../model/models';

/* tslint:disable:no-unused-variable member-ordering */

export class SlingApi {
    protected basePath = 'http://localhost';
    public defaultHeaders : any = {};

    static $inject: string[] = ['$http', '$httpParamSerializer', 'basePath'];

    constructor(protected $http: ng.IHttpService, protected $httpParamSerializer?: (d: any) => any, basePath?: string) {
        if (basePath !== undefined) {
            this.basePath = basePath;
        }
    }

    /**
     * 
     * @param runmode 
     * @param name 
     */
    public deleteAgent (runmode: string, name: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'
            .replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling deleteAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteAgent.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param path 
     * @param name 
     */
    public deleteNode (path: string, name: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/{path}/{name}'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling deleteNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNode.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param runmode 
     * @param name 
     */
    public getAgent (runmode: string, name: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'
            .replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling getAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getAgent.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param runmode 
     */
    public getAgents (runmode: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<string> {
        const localVarPath = this.basePath + '/etc/replication/agents.{runmode}.-1.json'
            .replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling getAgents.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     */
    public getAuthorizableKeystore (intermediatePath: string, authorizableId: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.KeystoreInfo> {
        const localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}.ks.json'
            .replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath)))
            .replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling getAuthorizableKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling getAuthorizableKeystore.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     */
    public getKeystore (intermediatePath: string, authorizableId: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}/keystore/store.p12'
            .replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath)))
            .replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling getKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling getKeystore.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param path 
     * @param name 
     */
    public getNode (path: string, name: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/{path}/{name}'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getNode.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param group 
     * @param name 
     * @param version 
     */
    public getPackage (group: string, name: string, version: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/etc/packages/{group}/{name}-{version}.zip'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getPackage.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getPackage.');
        }

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getPackage.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param group 
     * @param name 
     * @param version 
     */
    public getPackageFilter (group: string, name: string, version: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<string> {
        const localVarPath = this.basePath + '/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getPackageFilter.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getPackageFilter.');
        }

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getPackageFilter.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     */
    public getQuery (path: string, pLimit: number, _1property: string, _1propertyValue: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<string> {
        const localVarPath = this.basePath + '/bin/querybuilder.json';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getQuery.');
        }

        // verify required parameter 'pLimit' is not null or undefined
        if (pLimit === null || pLimit === undefined) {
            throw new Error('Required parameter pLimit was null or undefined when calling getQuery.');
        }

        // verify required parameter '_1property' is not null or undefined
        if (_1property === null || _1property === undefined) {
            throw new Error('Required parameter _1property was null or undefined when calling getQuery.');
        }

        // verify required parameter '_1propertyValue' is not null or undefined
        if (_1propertyValue === null || _1propertyValue === undefined) {
            throw new Error('Required parameter _1propertyValue was null or undefined when calling getQuery.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (pLimit !== undefined) {
            queryParameters['p.limit'] = pLimit;
        }

        if (_1property !== undefined) {
            queryParameters['1_property'] = _1property;
        }

        if (_1propertyValue !== undefined) {
            queryParameters['1_property.value'] = _1propertyValue;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     */
    public getTruststore (extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/etc/truststore/truststore.p12';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     */
    public getTruststoreInfo (extraHttpRequestParams?: any ) : ng.IHttpPromise<models.TruststoreInfo> {
        const localVarPath = this.basePath + '/libs/granite/security/truststore.json';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param runmode 
     * @param name 
     * @param jcr:contentCq:distribute 
     * @param jcr:contentCq:distribute@TypeHint 
     * @param jcr:contentCq:name 
     * @param jcr:contentCq:template 
     * @param jcr:contentEnabled 
     * @param jcr:contentJcr:description 
     * @param jcr:contentJcr:lastModified 
     * @param jcr:contentJcr:lastModifiedBy 
     * @param jcr:contentJcr:mixinTypes 
     * @param jcr:contentJcr:title 
     * @param jcr:contentLogLevel 
     * @param jcr:contentNoStatusUpdate 
     * @param jcr:contentNoVersioning 
     * @param jcr:contentProtocolConnectTimeout 
     * @param jcr:contentProtocolHTTPConnectionClosed 
     * @param jcr:contentProtocolHTTPExpired 
     * @param jcr:contentProtocolHTTPHeaders 
     * @param jcr:contentProtocolHTTPHeaders@TypeHint 
     * @param jcr:contentProtocolHTTPMethod 
     * @param jcr:contentProtocolHTTPSRelaxed 
     * @param jcr:contentProtocolInterface 
     * @param jcr:contentProtocolSocketTimeout 
     * @param jcr:contentProtocolVersion 
     * @param jcr:contentProxyNTLMDomain 
     * @param jcr:contentProxyNTLMHost 
     * @param jcr:contentProxyHost 
     * @param jcr:contentProxyPassword 
     * @param jcr:contentProxyPort 
     * @param jcr:contentProxyUser 
     * @param jcr:contentQueueBatchMaxSize 
     * @param jcr:contentQueueBatchMode 
     * @param jcr:contentQueueBatchWaitTime 
     * @param jcr:contentRetryDelay 
     * @param jcr:contentReverseReplication 
     * @param jcr:contentSerializationType 
     * @param jcr:contentSling:resourceType 
     * @param jcr:contentSsl 
     * @param jcr:contentTransportNTLMDomain 
     * @param jcr:contentTransportNTLMHost 
     * @param jcr:contentTransportPassword 
     * @param jcr:contentTransportUri 
     * @param jcr:contentTransportUser 
     * @param jcr:contentTriggerDistribute 
     * @param jcr:contentTriggerModified 
     * @param jcr:contentTriggerOnOffTime 
     * @param jcr:contentTriggerReceive 
     * @param jcr:contentTriggerSpecific 
     * @param jcr:contentUserId 
     * @param jcr:primaryType 
     * @param :operation 
     */
    public postAgent (runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'
            .replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling postAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postAgent.');
        }

        if (jcr:contentCq:distribute !== undefined) {
            queryParameters['jcr:content/cq:distribute'] = jcr:contentCq:distribute;
        }

        if (jcr:contentCq:distribute@TypeHint !== undefined) {
            queryParameters['jcr:content/cq:distribute@TypeHint'] = jcr:contentCq:distribute@TypeHint;
        }

        if (jcr:contentCq:name !== undefined) {
            queryParameters['jcr:content/cq:name'] = jcr:contentCq:name;
        }

        if (jcr:contentCq:template !== undefined) {
            queryParameters['jcr:content/cq:template'] = jcr:contentCq:template;
        }

        if (jcr:contentEnabled !== undefined) {
            queryParameters['jcr:content/enabled'] = jcr:contentEnabled;
        }

        if (jcr:contentJcr:description !== undefined) {
            queryParameters['jcr:content/jcr:description'] = jcr:contentJcr:description;
        }

        if (jcr:contentJcr:lastModified !== undefined) {
            queryParameters['jcr:content/jcr:lastModified'] = jcr:contentJcr:lastModified;
        }

        if (jcr:contentJcr:lastModifiedBy !== undefined) {
            queryParameters['jcr:content/jcr:lastModifiedBy'] = jcr:contentJcr:lastModifiedBy;
        }

        if (jcr:contentJcr:mixinTypes !== undefined) {
            queryParameters['jcr:content/jcr:mixinTypes'] = jcr:contentJcr:mixinTypes;
        }

        if (jcr:contentJcr:title !== undefined) {
            queryParameters['jcr:content/jcr:title'] = jcr:contentJcr:title;
        }

        if (jcr:contentLogLevel !== undefined) {
            queryParameters['jcr:content/logLevel'] = jcr:contentLogLevel;
        }

        if (jcr:contentNoStatusUpdate !== undefined) {
            queryParameters['jcr:content/noStatusUpdate'] = jcr:contentNoStatusUpdate;
        }

        if (jcr:contentNoVersioning !== undefined) {
            queryParameters['jcr:content/noVersioning'] = jcr:contentNoVersioning;
        }

        if (jcr:contentProtocolConnectTimeout !== undefined) {
            queryParameters['jcr:content/protocolConnectTimeout'] = jcr:contentProtocolConnectTimeout;
        }

        if (jcr:contentProtocolHTTPConnectionClosed !== undefined) {
            queryParameters['jcr:content/protocolHTTPConnectionClosed'] = jcr:contentProtocolHTTPConnectionClosed;
        }

        if (jcr:contentProtocolHTTPExpired !== undefined) {
            queryParameters['jcr:content/protocolHTTPExpired'] = jcr:contentProtocolHTTPExpired;
        }

        if (jcr:contentProtocolHTTPHeaders !== undefined) {
            queryParameters['jcr:content/protocolHTTPHeaders'] = jcr:contentProtocolHTTPHeaders;
        }

        if (jcr:contentProtocolHTTPHeaders@TypeHint !== undefined) {
            queryParameters['jcr:content/protocolHTTPHeaders@TypeHint'] = jcr:contentProtocolHTTPHeaders@TypeHint;
        }

        if (jcr:contentProtocolHTTPMethod !== undefined) {
            queryParameters['jcr:content/protocolHTTPMethod'] = jcr:contentProtocolHTTPMethod;
        }

        if (jcr:contentProtocolHTTPSRelaxed !== undefined) {
            queryParameters['jcr:content/protocolHTTPSRelaxed'] = jcr:contentProtocolHTTPSRelaxed;
        }

        if (jcr:contentProtocolInterface !== undefined) {
            queryParameters['jcr:content/protocolInterface'] = jcr:contentProtocolInterface;
        }

        if (jcr:contentProtocolSocketTimeout !== undefined) {
            queryParameters['jcr:content/protocolSocketTimeout'] = jcr:contentProtocolSocketTimeout;
        }

        if (jcr:contentProtocolVersion !== undefined) {
            queryParameters['jcr:content/protocolVersion'] = jcr:contentProtocolVersion;
        }

        if (jcr:contentProxyNTLMDomain !== undefined) {
            queryParameters['jcr:content/proxyNTLMDomain'] = jcr:contentProxyNTLMDomain;
        }

        if (jcr:contentProxyNTLMHost !== undefined) {
            queryParameters['jcr:content/proxyNTLMHost'] = jcr:contentProxyNTLMHost;
        }

        if (jcr:contentProxyHost !== undefined) {
            queryParameters['jcr:content/proxyHost'] = jcr:contentProxyHost;
        }

        if (jcr:contentProxyPassword !== undefined) {
            queryParameters['jcr:content/proxyPassword'] = jcr:contentProxyPassword;
        }

        if (jcr:contentProxyPort !== undefined) {
            queryParameters['jcr:content/proxyPort'] = jcr:contentProxyPort;
        }

        if (jcr:contentProxyUser !== undefined) {
            queryParameters['jcr:content/proxyUser'] = jcr:contentProxyUser;
        }

        if (jcr:contentQueueBatchMaxSize !== undefined) {
            queryParameters['jcr:content/queueBatchMaxSize'] = jcr:contentQueueBatchMaxSize;
        }

        if (jcr:contentQueueBatchMode !== undefined) {
            queryParameters['jcr:content/queueBatchMode'] = jcr:contentQueueBatchMode;
        }

        if (jcr:contentQueueBatchWaitTime !== undefined) {
            queryParameters['jcr:content/queueBatchWaitTime'] = jcr:contentQueueBatchWaitTime;
        }

        if (jcr:contentRetryDelay !== undefined) {
            queryParameters['jcr:content/retryDelay'] = jcr:contentRetryDelay;
        }

        if (jcr:contentReverseReplication !== undefined) {
            queryParameters['jcr:content/reverseReplication'] = jcr:contentReverseReplication;
        }

        if (jcr:contentSerializationType !== undefined) {
            queryParameters['jcr:content/serializationType'] = jcr:contentSerializationType;
        }

        if (jcr:contentSling:resourceType !== undefined) {
            queryParameters['jcr:content/sling:resourceType'] = jcr:contentSling:resourceType;
        }

        if (jcr:contentSsl !== undefined) {
            queryParameters['jcr:content/ssl'] = jcr:contentSsl;
        }

        if (jcr:contentTransportNTLMDomain !== undefined) {
            queryParameters['jcr:content/transportNTLMDomain'] = jcr:contentTransportNTLMDomain;
        }

        if (jcr:contentTransportNTLMHost !== undefined) {
            queryParameters['jcr:content/transportNTLMHost'] = jcr:contentTransportNTLMHost;
        }

        if (jcr:contentTransportPassword !== undefined) {
            queryParameters['jcr:content/transportPassword'] = jcr:contentTransportPassword;
        }

        if (jcr:contentTransportUri !== undefined) {
            queryParameters['jcr:content/transportUri'] = jcr:contentTransportUri;
        }

        if (jcr:contentTransportUser !== undefined) {
            queryParameters['jcr:content/transportUser'] = jcr:contentTransportUser;
        }

        if (jcr:contentTriggerDistribute !== undefined) {
            queryParameters['jcr:content/triggerDistribute'] = jcr:contentTriggerDistribute;
        }

        if (jcr:contentTriggerModified !== undefined) {
            queryParameters['jcr:content/triggerModified'] = jcr:contentTriggerModified;
        }

        if (jcr:contentTriggerOnOffTime !== undefined) {
            queryParameters['jcr:content/triggerOnOffTime'] = jcr:contentTriggerOnOffTime;
        }

        if (jcr:contentTriggerReceive !== undefined) {
            queryParameters['jcr:content/triggerReceive'] = jcr:contentTriggerReceive;
        }

        if (jcr:contentTriggerSpecific !== undefined) {
            queryParameters['jcr:content/triggerSpecific'] = jcr:contentTriggerSpecific;
        }

        if (jcr:contentUserId !== undefined) {
            queryParameters['jcr:content/userId'] = jcr:contentUserId;
        }

        if (jcr:primaryType !== undefined) {
            queryParameters['jcr:primaryType'] = jcr:primaryType;
        }

        if (:operation !== undefined) {
            queryParameters[':operation'] = :operation;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     * @param :operation 
     * @param currentPassword 
     * @param newPassword 
     * @param rePassword 
     * @param keyPassword 
     * @param keyStorePass 
     * @param alias 
     * @param newAlias 
     * @param removeAlias 
     * @param certChain 
     * @param pk 
     * @param keyStore 
     */
    public postAuthorizableKeystore (intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: any, pk?: any, keyStore?: any, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.KeystoreInfo> {
        const localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}.ks.html'
            .replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath)))
            .replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizableKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizableKeystore.');
        }

        if (:operation !== undefined) {
            queryParameters[':operation'] = :operation;
        }

        if (currentPassword !== undefined) {
            queryParameters['currentPassword'] = currentPassword;
        }

        if (newPassword !== undefined) {
            queryParameters['newPassword'] = newPassword;
        }

        if (rePassword !== undefined) {
            queryParameters['rePassword'] = rePassword;
        }

        if (keyPassword !== undefined) {
            queryParameters['keyPassword'] = keyPassword;
        }

        if (keyStorePass !== undefined) {
            queryParameters['keyStorePass'] = keyStorePass;
        }

        if (alias !== undefined) {
            queryParameters['alias'] = alias;
        }

        if (newAlias !== undefined) {
            queryParameters['newAlias'] = newAlias;
        }

        if (removeAlias !== undefined) {
            queryParameters['removeAlias'] = removeAlias;
        }

        headerParams['Content-Type'] = 'application/x-www-form-urlencoded';

        formParams['cert-chain'] = certChain;

        formParams['pk'] = pk;

        formParams['keyStore'] = keyStore;

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            data: this.$httpParamSerializer(formParams),
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param authorizableId 
     * @param intermediatePath 
     * @param createUser 
     * @param createGroup 
     * @param rep:password 
     * @param profileGivenName 
     */
    public postAuthorizables (authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<string> {
        const localVarPath = this.basePath + '/libs/granite/security/post/authorizables';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizables.');
        }

        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizables.');
        }

        if (authorizableId !== undefined) {
            queryParameters['authorizableId'] = authorizableId;
        }

        if (intermediatePath !== undefined) {
            queryParameters['intermediatePath'] = intermediatePath;
        }

        if (createUser !== undefined) {
            queryParameters['createUser'] = createUser;
        }

        if (createGroup !== undefined) {
            queryParameters['createGroup'] = createGroup;
        }

        if (rep:password !== undefined) {
            queryParameters['rep:password'] = rep:password;
        }

        if (profileGivenName !== undefined) {
            queryParameters['profile/givenName'] = profileGivenName;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param keyStorePassword 
     * @param keyStorePassword@TypeHint 
     * @param serviceRanking 
     * @param serviceRanking@TypeHint 
     * @param idpHttpRedirect 
     * @param idpHttpRedirect@TypeHint 
     * @param createUser 
     * @param createUser@TypeHint 
     * @param defaultRedirectUrl 
     * @param defaultRedirectUrl@TypeHint 
     * @param userIDAttribute 
     * @param userIDAttribute@TypeHint 
     * @param defaultGroups 
     * @param defaultGroups@TypeHint 
     * @param idpCertAlias 
     * @param idpCertAlias@TypeHint 
     * @param addGroupMemberships 
     * @param addGroupMemberships@TypeHint 
     * @param path 
     * @param path@TypeHint 
     * @param synchronizeAttributes 
     * @param synchronizeAttributes@TypeHint 
     * @param clockTolerance 
     * @param clockTolerance@TypeHint 
     * @param groupMembershipAttribute 
     * @param groupMembershipAttribute@TypeHint 
     * @param idpUrl 
     * @param idpUrl@TypeHint 
     * @param logoutUrl 
     * @param logoutUrl@TypeHint 
     * @param serviceProviderEntityId 
     * @param serviceProviderEntityId@TypeHint 
     * @param assertionConsumerServiceURL 
     * @param assertionConsumerServiceURL@TypeHint 
     * @param handleLogout 
     * @param handleLogout@TypeHint 
     * @param spPrivateKeyAlias 
     * @param spPrivateKeyAlias@TypeHint 
     * @param useEncryption 
     * @param useEncryption@TypeHint 
     * @param nameIdFormat 
     * @param nameIdFormat@TypeHint 
     * @param digestMethod 
     * @param digestMethod@TypeHint 
     * @param signatureMethod 
     * @param signatureMethod@TypeHint 
     * @param userIntermediatePath 
     * @param userIntermediatePath@TypeHint 
     */
    public postConfigAdobeGraniteSamlAuthenticationHandler (keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (keyStorePassword !== undefined) {
            queryParameters['keyStorePassword'] = keyStorePassword;
        }

        if (keyStorePassword@TypeHint !== undefined) {
            queryParameters['keyStorePassword@TypeHint'] = keyStorePassword@TypeHint;
        }

        if (serviceRanking !== undefined) {
            queryParameters['service.ranking'] = serviceRanking;
        }

        if (serviceRanking@TypeHint !== undefined) {
            queryParameters['service.ranking@TypeHint'] = serviceRanking@TypeHint;
        }

        if (idpHttpRedirect !== undefined) {
            queryParameters['idpHttpRedirect'] = idpHttpRedirect;
        }

        if (idpHttpRedirect@TypeHint !== undefined) {
            queryParameters['idpHttpRedirect@TypeHint'] = idpHttpRedirect@TypeHint;
        }

        if (createUser !== undefined) {
            queryParameters['createUser'] = createUser;
        }

        if (createUser@TypeHint !== undefined) {
            queryParameters['createUser@TypeHint'] = createUser@TypeHint;
        }

        if (defaultRedirectUrl !== undefined) {
            queryParameters['defaultRedirectUrl'] = defaultRedirectUrl;
        }

        if (defaultRedirectUrl@TypeHint !== undefined) {
            queryParameters['defaultRedirectUrl@TypeHint'] = defaultRedirectUrl@TypeHint;
        }

        if (userIDAttribute !== undefined) {
            queryParameters['userIDAttribute'] = userIDAttribute;
        }

        if (userIDAttribute@TypeHint !== undefined) {
            queryParameters['userIDAttribute@TypeHint'] = userIDAttribute@TypeHint;
        }

        if (defaultGroups !== undefined) {
            queryParameters['defaultGroups'] = defaultGroups;
        }

        if (defaultGroups@TypeHint !== undefined) {
            queryParameters['defaultGroups@TypeHint'] = defaultGroups@TypeHint;
        }

        if (idpCertAlias !== undefined) {
            queryParameters['idpCertAlias'] = idpCertAlias;
        }

        if (idpCertAlias@TypeHint !== undefined) {
            queryParameters['idpCertAlias@TypeHint'] = idpCertAlias@TypeHint;
        }

        if (addGroupMemberships !== undefined) {
            queryParameters['addGroupMemberships'] = addGroupMemberships;
        }

        if (addGroupMemberships@TypeHint !== undefined) {
            queryParameters['addGroupMemberships@TypeHint'] = addGroupMemberships@TypeHint;
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (path@TypeHint !== undefined) {
            queryParameters['path@TypeHint'] = path@TypeHint;
        }

        if (synchronizeAttributes !== undefined) {
            queryParameters['synchronizeAttributes'] = synchronizeAttributes;
        }

        if (synchronizeAttributes@TypeHint !== undefined) {
            queryParameters['synchronizeAttributes@TypeHint'] = synchronizeAttributes@TypeHint;
        }

        if (clockTolerance !== undefined) {
            queryParameters['clockTolerance'] = clockTolerance;
        }

        if (clockTolerance@TypeHint !== undefined) {
            queryParameters['clockTolerance@TypeHint'] = clockTolerance@TypeHint;
        }

        if (groupMembershipAttribute !== undefined) {
            queryParameters['groupMembershipAttribute'] = groupMembershipAttribute;
        }

        if (groupMembershipAttribute@TypeHint !== undefined) {
            queryParameters['groupMembershipAttribute@TypeHint'] = groupMembershipAttribute@TypeHint;
        }

        if (idpUrl !== undefined) {
            queryParameters['idpUrl'] = idpUrl;
        }

        if (idpUrl@TypeHint !== undefined) {
            queryParameters['idpUrl@TypeHint'] = idpUrl@TypeHint;
        }

        if (logoutUrl !== undefined) {
            queryParameters['logoutUrl'] = logoutUrl;
        }

        if (logoutUrl@TypeHint !== undefined) {
            queryParameters['logoutUrl@TypeHint'] = logoutUrl@TypeHint;
        }

        if (serviceProviderEntityId !== undefined) {
            queryParameters['serviceProviderEntityId'] = serviceProviderEntityId;
        }

        if (serviceProviderEntityId@TypeHint !== undefined) {
            queryParameters['serviceProviderEntityId@TypeHint'] = serviceProviderEntityId@TypeHint;
        }

        if (assertionConsumerServiceURL !== undefined) {
            queryParameters['assertionConsumerServiceURL'] = assertionConsumerServiceURL;
        }

        if (assertionConsumerServiceURL@TypeHint !== undefined) {
            queryParameters['assertionConsumerServiceURL@TypeHint'] = assertionConsumerServiceURL@TypeHint;
        }

        if (handleLogout !== undefined) {
            queryParameters['handleLogout'] = handleLogout;
        }

        if (handleLogout@TypeHint !== undefined) {
            queryParameters['handleLogout@TypeHint'] = handleLogout@TypeHint;
        }

        if (spPrivateKeyAlias !== undefined) {
            queryParameters['spPrivateKeyAlias'] = spPrivateKeyAlias;
        }

        if (spPrivateKeyAlias@TypeHint !== undefined) {
            queryParameters['spPrivateKeyAlias@TypeHint'] = spPrivateKeyAlias@TypeHint;
        }

        if (useEncryption !== undefined) {
            queryParameters['useEncryption'] = useEncryption;
        }

        if (useEncryption@TypeHint !== undefined) {
            queryParameters['useEncryption@TypeHint'] = useEncryption@TypeHint;
        }

        if (nameIdFormat !== undefined) {
            queryParameters['nameIdFormat'] = nameIdFormat;
        }

        if (nameIdFormat@TypeHint !== undefined) {
            queryParameters['nameIdFormat@TypeHint'] = nameIdFormat@TypeHint;
        }

        if (digestMethod !== undefined) {
            queryParameters['digestMethod'] = digestMethod;
        }

        if (digestMethod@TypeHint !== undefined) {
            queryParameters['digestMethod@TypeHint'] = digestMethod@TypeHint;
        }

        if (signatureMethod !== undefined) {
            queryParameters['signatureMethod'] = signatureMethod;
        }

        if (signatureMethod@TypeHint !== undefined) {
            queryParameters['signatureMethod@TypeHint'] = signatureMethod@TypeHint;
        }

        if (userIntermediatePath !== undefined) {
            queryParameters['userIntermediatePath'] = userIntermediatePath;
        }

        if (userIntermediatePath@TypeHint !== undefined) {
            queryParameters['userIntermediatePath@TypeHint'] = userIntermediatePath@TypeHint;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param orgApacheFelixHttpsNio 
     * @param orgApacheFelixHttpsNio@TypeHint 
     * @param orgApacheFelixHttpsKeystore 
     * @param orgApacheFelixHttpsKeystore@TypeHint 
     * @param orgApacheFelixHttpsKeystorePassword 
     * @param orgApacheFelixHttpsKeystorePassword@TypeHint 
     * @param orgApacheFelixHttpsKeystoreKey 
     * @param orgApacheFelixHttpsKeystoreKey@TypeHint 
     * @param orgApacheFelixHttpsKeystoreKeyPassword 
     * @param orgApacheFelixHttpsKeystoreKeyPassword@TypeHint 
     * @param orgApacheFelixHttpsTruststore 
     * @param orgApacheFelixHttpsTruststore@TypeHint 
     * @param orgApacheFelixHttpsTruststorePassword 
     * @param orgApacheFelixHttpsTruststorePassword@TypeHint 
     * @param orgApacheFelixHttpsClientcertificate 
     * @param orgApacheFelixHttpsClientcertificate@TypeHint 
     * @param orgApacheFelixHttpsEnable 
     * @param orgApacheFelixHttpsEnable@TypeHint 
     * @param orgOsgiServiceHttpPortSecure 
     * @param orgOsgiServiceHttpPortSecure@TypeHint 
     */
    public postConfigApacheFelixJettyBasedHttpService (orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.felix.http';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (orgApacheFelixHttpsNio !== undefined) {
            queryParameters['org.apache.felix.https.nio'] = orgApacheFelixHttpsNio;
        }

        if (orgApacheFelixHttpsNio@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.nio@TypeHint'] = orgApacheFelixHttpsNio@TypeHint;
        }

        if (orgApacheFelixHttpsKeystore !== undefined) {
            queryParameters['org.apache.felix.https.keystore'] = orgApacheFelixHttpsKeystore;
        }

        if (orgApacheFelixHttpsKeystore@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore@TypeHint'] = orgApacheFelixHttpsKeystore@TypeHint;
        }

        if (orgApacheFelixHttpsKeystorePassword !== undefined) {
            queryParameters['org.apache.felix.https.keystore.password'] = orgApacheFelixHttpsKeystorePassword;
        }

        if (orgApacheFelixHttpsKeystorePassword@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore.password@TypeHint'] = orgApacheFelixHttpsKeystorePassword@TypeHint;
        }

        if (orgApacheFelixHttpsKeystoreKey !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key'] = orgApacheFelixHttpsKeystoreKey;
        }

        if (orgApacheFelixHttpsKeystoreKey@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key@TypeHint'] = orgApacheFelixHttpsKeystoreKey@TypeHint;
        }

        if (orgApacheFelixHttpsKeystoreKeyPassword !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key.password'] = orgApacheFelixHttpsKeystoreKeyPassword;
        }

        if (orgApacheFelixHttpsKeystoreKeyPassword@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key.password@TypeHint'] = orgApacheFelixHttpsKeystoreKeyPassword@TypeHint;
        }

        if (orgApacheFelixHttpsTruststore !== undefined) {
            queryParameters['org.apache.felix.https.truststore'] = orgApacheFelixHttpsTruststore;
        }

        if (orgApacheFelixHttpsTruststore@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.truststore@TypeHint'] = orgApacheFelixHttpsTruststore@TypeHint;
        }

        if (orgApacheFelixHttpsTruststorePassword !== undefined) {
            queryParameters['org.apache.felix.https.truststore.password'] = orgApacheFelixHttpsTruststorePassword;
        }

        if (orgApacheFelixHttpsTruststorePassword@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.truststore.password@TypeHint'] = orgApacheFelixHttpsTruststorePassword@TypeHint;
        }

        if (orgApacheFelixHttpsClientcertificate !== undefined) {
            queryParameters['org.apache.felix.https.clientcertificate'] = orgApacheFelixHttpsClientcertificate;
        }

        if (orgApacheFelixHttpsClientcertificate@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.clientcertificate@TypeHint'] = orgApacheFelixHttpsClientcertificate@TypeHint;
        }

        if (orgApacheFelixHttpsEnable !== undefined) {
            queryParameters['org.apache.felix.https.enable'] = orgApacheFelixHttpsEnable;
        }

        if (orgApacheFelixHttpsEnable@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.enable@TypeHint'] = orgApacheFelixHttpsEnable@TypeHint;
        }

        if (orgOsgiServiceHttpPortSecure !== undefined) {
            queryParameters['org.osgi.service.http.port.secure'] = orgOsgiServiceHttpPortSecure;
        }

        if (orgOsgiServiceHttpPortSecure@TypeHint !== undefined) {
            queryParameters['org.osgi.service.http.port.secure@TypeHint'] = orgOsgiServiceHttpPortSecure@TypeHint;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param proxyHost 
     * @param proxyHost@TypeHint 
     * @param proxyPort 
     * @param proxyPort@TypeHint 
     * @param proxyExceptions 
     * @param proxyExceptions@TypeHint 
     * @param proxyEnabled 
     * @param proxyEnabled@TypeHint 
     * @param proxyUser 
     * @param proxyUser@TypeHint 
     * @param proxyPassword 
     * @param proxyPassword@TypeHint 
     */
    public postConfigApacheHttpComponentsProxyConfiguration (proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.http.proxyconfigurator.config';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (proxyHost !== undefined) {
            queryParameters['proxy.host'] = proxyHost;
        }

        if (proxyHost@TypeHint !== undefined) {
            queryParameters['proxy.host@TypeHint'] = proxyHost@TypeHint;
        }

        if (proxyPort !== undefined) {
            queryParameters['proxy.port'] = proxyPort;
        }

        if (proxyPort@TypeHint !== undefined) {
            queryParameters['proxy.port@TypeHint'] = proxyPort@TypeHint;
        }

        if (proxyExceptions !== undefined) {
            queryParameters['proxy.exceptions'] = proxyExceptions;
        }

        if (proxyExceptions@TypeHint !== undefined) {
            queryParameters['proxy.exceptions@TypeHint'] = proxyExceptions@TypeHint;
        }

        if (proxyEnabled !== undefined) {
            queryParameters['proxy.enabled'] = proxyEnabled;
        }

        if (proxyEnabled@TypeHint !== undefined) {
            queryParameters['proxy.enabled@TypeHint'] = proxyEnabled@TypeHint;
        }

        if (proxyUser !== undefined) {
            queryParameters['proxy.user'] = proxyUser;
        }

        if (proxyUser@TypeHint !== undefined) {
            queryParameters['proxy.user@TypeHint'] = proxyUser@TypeHint;
        }

        if (proxyPassword !== undefined) {
            queryParameters['proxy.password'] = proxyPassword;
        }

        if (proxyPassword@TypeHint !== undefined) {
            queryParameters['proxy.password@TypeHint'] = proxyPassword@TypeHint;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param alias 
     * @param alias@TypeHint 
     * @param davCreateAbsoluteUri 
     * @param davCreateAbsoluteUri@TypeHint 
     */
    public postConfigApacheSlingDavExServlet (alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (alias !== undefined) {
            queryParameters['alias'] = alias;
        }

        if (alias@TypeHint !== undefined) {
            queryParameters['alias@TypeHint'] = alias@TypeHint;
        }

        if (davCreateAbsoluteUri !== undefined) {
            queryParameters['dav.create-absolute-uri'] = davCreateAbsoluteUri;
        }

        if (davCreateAbsoluteUri@TypeHint !== undefined) {
            queryParameters['dav.create-absolute-uri@TypeHint'] = davCreateAbsoluteUri@TypeHint;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param jsonMaximumresults 
     * @param jsonMaximumresults@TypeHint 
     * @param enableHtml 
     * @param enableHtml@TypeHint 
     * @param enableTxt 
     * @param enableTxt@TypeHint 
     * @param enableXml 
     * @param enableXml@TypeHint 
     */
    public postConfigApacheSlingGetServlet (jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (jsonMaximumresults !== undefined) {
            queryParameters['json.maximumresults'] = jsonMaximumresults;
        }

        if (jsonMaximumresults@TypeHint !== undefined) {
            queryParameters['json.maximumresults@TypeHint'] = jsonMaximumresults@TypeHint;
        }

        if (enableHtml !== undefined) {
            queryParameters['enable.html'] = enableHtml;
        }

        if (enableHtml@TypeHint !== undefined) {
            queryParameters['enable.html@TypeHint'] = enableHtml@TypeHint;
        }

        if (enableTxt !== undefined) {
            queryParameters['enable.txt'] = enableTxt;
        }

        if (enableTxt@TypeHint !== undefined) {
            queryParameters['enable.txt@TypeHint'] = enableTxt@TypeHint;
        }

        if (enableXml !== undefined) {
            queryParameters['enable.xml'] = enableXml;
        }

        if (enableXml@TypeHint !== undefined) {
            queryParameters['enable.xml@TypeHint'] = enableXml@TypeHint;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param allowEmpty 
     * @param allowEmpty@TypeHint 
     * @param allowHosts 
     * @param allowHosts@TypeHint 
     * @param allowHostsRegexp 
     * @param allowHostsRegexp@TypeHint 
     * @param filterMethods 
     * @param filterMethods@TypeHint 
     */
    public postConfigApacheSlingReferrerFilter (allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.sling.security.impl.ReferrerFilter';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (allowEmpty !== undefined) {
            queryParameters['allow.empty'] = allowEmpty;
        }

        if (allowEmpty@TypeHint !== undefined) {
            queryParameters['allow.empty@TypeHint'] = allowEmpty@TypeHint;
        }

        if (allowHosts !== undefined) {
            queryParameters['allow.hosts'] = allowHosts;
        }

        if (allowHosts@TypeHint !== undefined) {
            queryParameters['allow.hosts@TypeHint'] = allowHosts@TypeHint;
        }

        if (allowHostsRegexp !== undefined) {
            queryParameters['allow.hosts.regexp'] = allowHostsRegexp;
        }

        if (allowHostsRegexp@TypeHint !== undefined) {
            queryParameters['allow.hosts.regexp@TypeHint'] = allowHostsRegexp@TypeHint;
        }

        if (filterMethods !== undefined) {
            queryParameters['filter.methods'] = filterMethods;
        }

        if (filterMethods@TypeHint !== undefined) {
            queryParameters['filter.methods@TypeHint'] = filterMethods@TypeHint;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param path 
     * @param name 
     * @param :operation 
     * @param deleteAuthorizable 
     * @param file 
     */
    public postNode (path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: any, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/{path}/{name}'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postNode.');
        }

        if (:operation !== undefined) {
            queryParameters[':operation'] = :operation;
        }

        if (deleteAuthorizable !== undefined) {
            queryParameters['deleteAuthorizable'] = deleteAuthorizable;
        }

        headerParams['Content-Type'] = 'application/x-www-form-urlencoded';

        formParams['file'] = file;

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            data: this.$httpParamSerializer(formParams),
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param path 
     * @param name 
     * @param addMembers 
     */
    public postNodeRw (path: string, name: string, addMembers?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/{path}/{name}.rw.html'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postNodeRw.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postNodeRw.');
        }

        if (addMembers !== undefined) {
            queryParameters['addMembers'] = addMembers;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param path 
     * @param jcr:primaryType 
     * @param :name 
     */
    public postPath (path: string, jcr:primaryType: string, :name: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/{path}/'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postPath.');
        }

        // verify required parameter 'jcr:primaryType' is not null or undefined
        if (jcr:primaryType === null || jcr:primaryType === undefined) {
            throw new Error('Required parameter jcr:primaryType was null or undefined when calling postPath.');
        }

        // verify required parameter ':name' is not null or undefined
        if (:name === null || :name === undefined) {
            throw new Error('Required parameter :name was null or undefined when calling postPath.');
        }

        if (jcr:primaryType !== undefined) {
            queryParameters['jcr:primaryType'] = jcr:primaryType;
        }

        if (:name !== undefined) {
            queryParameters[':name'] = :name;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     */
    public postQuery (path: string, pLimit: number, _1property: string, _1propertyValue: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<string> {
        const localVarPath = this.basePath + '/bin/querybuilder.json';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postQuery.');
        }

        // verify required parameter 'pLimit' is not null or undefined
        if (pLimit === null || pLimit === undefined) {
            throw new Error('Required parameter pLimit was null or undefined when calling postQuery.');
        }

        // verify required parameter '_1property' is not null or undefined
        if (_1property === null || _1property === undefined) {
            throw new Error('Required parameter _1property was null or undefined when calling postQuery.');
        }

        // verify required parameter '_1propertyValue' is not null or undefined
        if (_1propertyValue === null || _1propertyValue === undefined) {
            throw new Error('Required parameter _1propertyValue was null or undefined when calling postQuery.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (pLimit !== undefined) {
            queryParameters['p.limit'] = pLimit;
        }

        if (_1property !== undefined) {
            queryParameters['1_property'] = _1property;
        }

        if (_1propertyValue !== undefined) {
            queryParameters['1_property.value'] = _1propertyValue;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param ignoredeactivated 
     * @param onlymodified 
     * @param path 
     */
    public postTreeActivation (ignoredeactivated: boolean, onlymodified: boolean, path: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/etc/replication/treeactivation.html';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'ignoredeactivated' is not null or undefined
        if (ignoredeactivated === null || ignoredeactivated === undefined) {
            throw new Error('Required parameter ignoredeactivated was null or undefined when calling postTreeActivation.');
        }

        // verify required parameter 'onlymodified' is not null or undefined
        if (onlymodified === null || onlymodified === undefined) {
            throw new Error('Required parameter onlymodified was null or undefined when calling postTreeActivation.');
        }

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postTreeActivation.');
        }

        if (ignoredeactivated !== undefined) {
            queryParameters['ignoredeactivated'] = ignoredeactivated;
        }

        if (onlymodified !== undefined) {
            queryParameters['onlymodified'] = onlymodified;
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param :operation 
     * @param newPassword 
     * @param rePassword 
     * @param keyStoreType 
     * @param removeAlias 
     * @param certificate 
     */
    public postTruststore (:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: any, extraHttpRequestParams?: any ) : ng.IHttpPromise<string> {
        const localVarPath = this.basePath + '/libs/granite/security/post/truststore';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        if (:operation !== undefined) {
            queryParameters[':operation'] = :operation;
        }

        if (newPassword !== undefined) {
            queryParameters['newPassword'] = newPassword;
        }

        if (rePassword !== undefined) {
            queryParameters['rePassword'] = rePassword;
        }

        if (keyStoreType !== undefined) {
            queryParameters['keyStoreType'] = keyStoreType;
        }

        if (removeAlias !== undefined) {
            queryParameters['removeAlias'] = removeAlias;
        }

        headerParams['Content-Type'] = 'application/x-www-form-urlencoded';

        formParams['certificate'] = certificate;

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            data: this.$httpParamSerializer(formParams),
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param truststoreP12 
     */
    public postTruststorePKCS12 (truststoreP12?: any, extraHttpRequestParams?: any ) : ng.IHttpPromise<string> {
        const localVarPath = this.basePath + '/etc/truststore';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        headerParams['Content-Type'] = 'application/x-www-form-urlencoded';

        formParams['truststore.p12'] = truststoreP12;

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            data: this.$httpParamSerializer(formParams),
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
}
