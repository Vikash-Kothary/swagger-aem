/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * OpenAPI spec version: 3.2.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api

import java.text.SimpleDateFormat

import java.io.File
import org.openapitools.client.model.KeystoreInfo
import org.openapitools.client.model.Number
import org.openapitools.client.model.TruststoreInfo
import org.openapitools.client.{ApiInvoker, ApiException}

import collection.mutable
import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart
import com.wordnik.swagger.client._
import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import java.net.URI
import java.io.File
import java.util.Date
import java.util.TimeZone
import javax.ws.rs.core.MediaType

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.collection.mutable.HashMap
import scala.util.{Failure, Success, Try}

import org.json4s._

class SlingApi(
  val defBasePath: String = "http://localhost",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new SlingApiAsyncHelper(client, config)

  /**
   * 
   * 
   *
   * @param runmode  
   * @param name  
   * @return void
   */
  def deleteAgent(runmode: String, name: String) = {
    val await = Try(Await.result(deleteAgentAsync(runmode, name), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param runmode  
   * @param name  
   * @return Future(void)
   */
  def deleteAgentAsync(runmode: String, name: String) = {
      helper.deleteAgent(runmode, name)
  }

  /**
   * 
   * 
   *
   * @param `path`  
   * @param name  
   * @return void
   */
  def deleteNode(`path`: String, name: String) = {
    val await = Try(Await.result(deleteNodeAsync(`path`, name), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param `path`  
   * @param name  
   * @return Future(void)
   */
  def deleteNodeAsync(`path`: String, name: String) = {
      helper.deleteNode(`path`, name)
  }

  /**
   * 
   * 
   *
   * @param runmode  
   * @param name  
   * @return void
   */
  def getAgent(runmode: String, name: String) = {
    val await = Try(Await.result(getAgentAsync(runmode, name), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param runmode  
   * @param name  
   * @return Future(void)
   */
  def getAgentAsync(runmode: String, name: String) = {
      helper.getAgent(runmode, name)
  }

  /**
   * 
   * 
   *
   * @param runmode  
   * @return String
   */
  def getAgents(runmode: String): Option[String] = {
    val await = Try(Await.result(getAgentsAsync(runmode), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param runmode  
   * @return Future(String)
   */
  def getAgentsAsync(runmode: String): Future[String] = {
      helper.getAgents(runmode)
  }

  /**
   * 
   * 
   *
   * @param intermediatePath  
   * @param authorizableId  
   * @return KeystoreInfo
   */
  def getAuthorizableKeystore(intermediatePath: String, authorizableId: String): Option[KeystoreInfo] = {
    val await = Try(Await.result(getAuthorizableKeystoreAsync(intermediatePath, authorizableId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param intermediatePath  
   * @param authorizableId  
   * @return Future(KeystoreInfo)
   */
  def getAuthorizableKeystoreAsync(intermediatePath: String, authorizableId: String): Future[KeystoreInfo] = {
      helper.getAuthorizableKeystore(intermediatePath, authorizableId)
  }

  /**
   * 
   * 
   *
   * @param intermediatePath  
   * @param authorizableId  
   * @return File
   */
  def getKeystore(intermediatePath: String, authorizableId: String): Option[File] = {
    val await = Try(Await.result(getKeystoreAsync(intermediatePath, authorizableId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param intermediatePath  
   * @param authorizableId  
   * @return Future(File)
   */
  def getKeystoreAsync(intermediatePath: String, authorizableId: String): Future[File] = {
      helper.getKeystore(intermediatePath, authorizableId)
  }

  /**
   * 
   * 
   *
   * @param `path`  
   * @param name  
   * @return void
   */
  def getNode(`path`: String, name: String) = {
    val await = Try(Await.result(getNodeAsync(`path`, name), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param `path`  
   * @param name  
   * @return Future(void)
   */
  def getNodeAsync(`path`: String, name: String) = {
      helper.getNode(`path`, name)
  }

  /**
   * 
   * 
   *
   * @param group  
   * @param name  
   * @param version  
   * @return File
   */
  def getPackage(group: String, name: String, version: String): Option[File] = {
    val await = Try(Await.result(getPackageAsync(group, name, version), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param group  
   * @param name  
   * @param version  
   * @return Future(File)
   */
  def getPackageAsync(group: String, name: String, version: String): Future[File] = {
      helper.getPackage(group, name, version)
  }

  /**
   * 
   * 
   *
   * @param group  
   * @param name  
   * @param version  
   * @return String
   */
  def getPackageFilter(group: String, name: String, version: String): Option[String] = {
    val await = Try(Await.result(getPackageFilterAsync(group, name, version), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param group  
   * @param name  
   * @param version  
   * @return Future(String)
   */
  def getPackageFilterAsync(group: String, name: String, version: String): Future[String] = {
      helper.getPackageFilter(group, name, version)
  }

  /**
   * 
   * 
   *
   * @param `path`  
   * @param pLimit  
   * @param `1property`  
   * @param `1propertyValue`  
   * @return String
   */
  def getQuery(`path`: String, pLimit: Number, `1property`: String, `1propertyValue`: String): Option[String] = {
    val await = Try(Await.result(getQueryAsync(`path`, pLimit, `1property`, `1propertyValue`), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param `path`  
   * @param pLimit  
   * @param `1property`  
   * @param `1propertyValue`  
   * @return Future(String)
   */
  def getQueryAsync(`path`: String, pLimit: Number, `1property`: String, `1propertyValue`: String): Future[String] = {
      helper.getQuery(`path`, pLimit, `1property`, `1propertyValue`)
  }

  /**
   * 
   * 
   *
   * @return File
   */
  def getTruststore(): Option[File] = {
    val await = Try(Await.result(getTruststoreAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @return Future(File)
   */
  def getTruststoreAsync(): Future[File] = {
      helper.getTruststore()
  }

  /**
   * 
   * 
   *
   * @return TruststoreInfo
   */
  def getTruststoreInfo(): Option[TruststoreInfo] = {
    val await = Try(Await.result(getTruststoreInfoAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @return Future(TruststoreInfo)
   */
  def getTruststoreInfoAsync(): Future[TruststoreInfo] = {
      helper.getTruststoreInfo()
  }

  /**
   * 
   * 
   *
   * @param runmode  
   * @param name  
   * @param jcrcontentcqdistribute  (optional)
   * @param jcrcontentcqdistributeTypeHint  (optional)
   * @param jcrcontentcqname  (optional)
   * @param jcrcontentcqtemplate  (optional)
   * @param jcrcontentenabled  (optional)
   * @param jcrcontentjcrdescription  (optional)
   * @param jcrcontentjcrlastModified  (optional)
   * @param jcrcontentjcrlastModifiedBy  (optional)
   * @param jcrcontentjcrmixinTypes  (optional)
   * @param jcrcontentjcrtitle  (optional)
   * @param jcrcontentlogLevel  (optional)
   * @param jcrcontentnoStatusUpdate  (optional)
   * @param jcrcontentnoVersioning  (optional)
   * @param jcrcontentprotocolConnectTimeout  (optional)
   * @param jcrcontentprotocolHTTPConnectionClosed  (optional)
   * @param jcrcontentprotocolHTTPExpired  (optional)
   * @param jcrcontentprotocolHTTPHeaders  (optional)
   * @param jcrcontentprotocolHTTPHeadersTypeHint  (optional)
   * @param jcrcontentprotocolHTTPMethod  (optional)
   * @param jcrcontentprotocolHTTPSRelaxed  (optional)
   * @param jcrcontentprotocolInterface  (optional)
   * @param jcrcontentprotocolSocketTimeout  (optional)
   * @param jcrcontentprotocolVersion  (optional)
   * @param jcrcontentproxyNTLMDomain  (optional)
   * @param jcrcontentproxyNTLMHost  (optional)
   * @param jcrcontentproxyHost  (optional)
   * @param jcrcontentproxyPassword  (optional)
   * @param jcrcontentproxyPort  (optional)
   * @param jcrcontentproxyUser  (optional)
   * @param jcrcontentqueueBatchMaxSize  (optional)
   * @param jcrcontentqueueBatchMode  (optional)
   * @param jcrcontentqueueBatchWaitTime  (optional)
   * @param jcrcontentretryDelay  (optional)
   * @param jcrcontentreverseReplication  (optional)
   * @param jcrcontentserializationType  (optional)
   * @param jcrcontentslingresourceType  (optional)
   * @param jcrcontentssl  (optional)
   * @param jcrcontenttransportNTLMDomain  (optional)
   * @param jcrcontenttransportNTLMHost  (optional)
   * @param jcrcontenttransportPassword  (optional)
   * @param jcrcontenttransportUri  (optional)
   * @param jcrcontenttransportUser  (optional)
   * @param jcrcontenttriggerDistribute  (optional)
   * @param jcrcontenttriggerModified  (optional)
   * @param jcrcontenttriggerOnOffTime  (optional)
   * @param jcrcontenttriggerReceive  (optional)
   * @param jcrcontenttriggerSpecific  (optional)
   * @param jcrcontentuserId  (optional)
   * @param jcrprimaryType  (optional)
   * @param operation  (optional)
   * @return void
   */
  def postAgent(runmode: String, name: String, jcrcontentcqdistribute: Option[Boolean] = None, jcrcontentcqdistributeTypeHint: Option[String] = None, jcrcontentcqname: Option[String] = None, jcrcontentcqtemplate: Option[String] = None, jcrcontentenabled: Option[Boolean] = None, jcrcontentjcrdescription: Option[String] = None, jcrcontentjcrlastModified: Option[String] = None, jcrcontentjcrlastModifiedBy: Option[String] = None, jcrcontentjcrmixinTypes: Option[String] = None, jcrcontentjcrtitle: Option[String] = None, jcrcontentlogLevel: Option[String] = None, jcrcontentnoStatusUpdate: Option[Boolean] = None, jcrcontentnoVersioning: Option[Boolean] = None, jcrcontentprotocolConnectTimeout: Option[Number] = None, jcrcontentprotocolHTTPConnectionClosed: Option[Boolean] = None, jcrcontentprotocolHTTPExpired: Option[String] = None, jcrcontentprotocolHTTPHeaders: Option[List[String]] = None, jcrcontentprotocolHTTPHeadersTypeHint: Option[String] = None, jcrcontentprotocolHTTPMethod: Option[String] = None, jcrcontentprotocolHTTPSRelaxed: Option[Boolean] = None, jcrcontentprotocolInterface: Option[String] = None, jcrcontentprotocolSocketTimeout: Option[Number] = None, jcrcontentprotocolVersion: Option[String] = None, jcrcontentproxyNTLMDomain: Option[String] = None, jcrcontentproxyNTLMHost: Option[String] = None, jcrcontentproxyHost: Option[String] = None, jcrcontentproxyPassword: Option[String] = None, jcrcontentproxyPort: Option[Number] = None, jcrcontentproxyUser: Option[String] = None, jcrcontentqueueBatchMaxSize: Option[Number] = None, jcrcontentqueueBatchMode: Option[String] = None, jcrcontentqueueBatchWaitTime: Option[Number] = None, jcrcontentretryDelay: Option[String] = None, jcrcontentreverseReplication: Option[Boolean] = None, jcrcontentserializationType: Option[String] = None, jcrcontentslingresourceType: Option[String] = None, jcrcontentssl: Option[String] = None, jcrcontenttransportNTLMDomain: Option[String] = None, jcrcontenttransportNTLMHost: Option[String] = None, jcrcontenttransportPassword: Option[String] = None, jcrcontenttransportUri: Option[String] = None, jcrcontenttransportUser: Option[String] = None, jcrcontenttriggerDistribute: Option[Boolean] = None, jcrcontenttriggerModified: Option[Boolean] = None, jcrcontenttriggerOnOffTime: Option[Boolean] = None, jcrcontenttriggerReceive: Option[Boolean] = None, jcrcontenttriggerSpecific: Option[Boolean] = None, jcrcontentuserId: Option[String] = None, jcrprimaryType: Option[String] = None, operation: Option[String] = None) = {
    val await = Try(Await.result(postAgentAsync(runmode, name, jcrcontentcqdistribute, jcrcontentcqdistributeTypeHint, jcrcontentcqname, jcrcontentcqtemplate, jcrcontentenabled, jcrcontentjcrdescription, jcrcontentjcrlastModified, jcrcontentjcrlastModifiedBy, jcrcontentjcrmixinTypes, jcrcontentjcrtitle, jcrcontentlogLevel, jcrcontentnoStatusUpdate, jcrcontentnoVersioning, jcrcontentprotocolConnectTimeout, jcrcontentprotocolHTTPConnectionClosed, jcrcontentprotocolHTTPExpired, jcrcontentprotocolHTTPHeaders, jcrcontentprotocolHTTPHeadersTypeHint, jcrcontentprotocolHTTPMethod, jcrcontentprotocolHTTPSRelaxed, jcrcontentprotocolInterface, jcrcontentprotocolSocketTimeout, jcrcontentprotocolVersion, jcrcontentproxyNTLMDomain, jcrcontentproxyNTLMHost, jcrcontentproxyHost, jcrcontentproxyPassword, jcrcontentproxyPort, jcrcontentproxyUser, jcrcontentqueueBatchMaxSize, jcrcontentqueueBatchMode, jcrcontentqueueBatchWaitTime, jcrcontentretryDelay, jcrcontentreverseReplication, jcrcontentserializationType, jcrcontentslingresourceType, jcrcontentssl, jcrcontenttransportNTLMDomain, jcrcontenttransportNTLMHost, jcrcontenttransportPassword, jcrcontenttransportUri, jcrcontenttransportUser, jcrcontenttriggerDistribute, jcrcontenttriggerModified, jcrcontenttriggerOnOffTime, jcrcontenttriggerReceive, jcrcontenttriggerSpecific, jcrcontentuserId, jcrprimaryType, operation), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param runmode  
   * @param name  
   * @param jcrcontentcqdistribute  (optional)
   * @param jcrcontentcqdistributeTypeHint  (optional)
   * @param jcrcontentcqname  (optional)
   * @param jcrcontentcqtemplate  (optional)
   * @param jcrcontentenabled  (optional)
   * @param jcrcontentjcrdescription  (optional)
   * @param jcrcontentjcrlastModified  (optional)
   * @param jcrcontentjcrlastModifiedBy  (optional)
   * @param jcrcontentjcrmixinTypes  (optional)
   * @param jcrcontentjcrtitle  (optional)
   * @param jcrcontentlogLevel  (optional)
   * @param jcrcontentnoStatusUpdate  (optional)
   * @param jcrcontentnoVersioning  (optional)
   * @param jcrcontentprotocolConnectTimeout  (optional)
   * @param jcrcontentprotocolHTTPConnectionClosed  (optional)
   * @param jcrcontentprotocolHTTPExpired  (optional)
   * @param jcrcontentprotocolHTTPHeaders  (optional)
   * @param jcrcontentprotocolHTTPHeadersTypeHint  (optional)
   * @param jcrcontentprotocolHTTPMethod  (optional)
   * @param jcrcontentprotocolHTTPSRelaxed  (optional)
   * @param jcrcontentprotocolInterface  (optional)
   * @param jcrcontentprotocolSocketTimeout  (optional)
   * @param jcrcontentprotocolVersion  (optional)
   * @param jcrcontentproxyNTLMDomain  (optional)
   * @param jcrcontentproxyNTLMHost  (optional)
   * @param jcrcontentproxyHost  (optional)
   * @param jcrcontentproxyPassword  (optional)
   * @param jcrcontentproxyPort  (optional)
   * @param jcrcontentproxyUser  (optional)
   * @param jcrcontentqueueBatchMaxSize  (optional)
   * @param jcrcontentqueueBatchMode  (optional)
   * @param jcrcontentqueueBatchWaitTime  (optional)
   * @param jcrcontentretryDelay  (optional)
   * @param jcrcontentreverseReplication  (optional)
   * @param jcrcontentserializationType  (optional)
   * @param jcrcontentslingresourceType  (optional)
   * @param jcrcontentssl  (optional)
   * @param jcrcontenttransportNTLMDomain  (optional)
   * @param jcrcontenttransportNTLMHost  (optional)
   * @param jcrcontenttransportPassword  (optional)
   * @param jcrcontenttransportUri  (optional)
   * @param jcrcontenttransportUser  (optional)
   * @param jcrcontenttriggerDistribute  (optional)
   * @param jcrcontenttriggerModified  (optional)
   * @param jcrcontenttriggerOnOffTime  (optional)
   * @param jcrcontenttriggerReceive  (optional)
   * @param jcrcontenttriggerSpecific  (optional)
   * @param jcrcontentuserId  (optional)
   * @param jcrprimaryType  (optional)
   * @param operation  (optional)
   * @return Future(void)
   */
  def postAgentAsync(runmode: String, name: String, jcrcontentcqdistribute: Option[Boolean] = None, jcrcontentcqdistributeTypeHint: Option[String] = None, jcrcontentcqname: Option[String] = None, jcrcontentcqtemplate: Option[String] = None, jcrcontentenabled: Option[Boolean] = None, jcrcontentjcrdescription: Option[String] = None, jcrcontentjcrlastModified: Option[String] = None, jcrcontentjcrlastModifiedBy: Option[String] = None, jcrcontentjcrmixinTypes: Option[String] = None, jcrcontentjcrtitle: Option[String] = None, jcrcontentlogLevel: Option[String] = None, jcrcontentnoStatusUpdate: Option[Boolean] = None, jcrcontentnoVersioning: Option[Boolean] = None, jcrcontentprotocolConnectTimeout: Option[Number] = None, jcrcontentprotocolHTTPConnectionClosed: Option[Boolean] = None, jcrcontentprotocolHTTPExpired: Option[String] = None, jcrcontentprotocolHTTPHeaders: Option[List[String]] = None, jcrcontentprotocolHTTPHeadersTypeHint: Option[String] = None, jcrcontentprotocolHTTPMethod: Option[String] = None, jcrcontentprotocolHTTPSRelaxed: Option[Boolean] = None, jcrcontentprotocolInterface: Option[String] = None, jcrcontentprotocolSocketTimeout: Option[Number] = None, jcrcontentprotocolVersion: Option[String] = None, jcrcontentproxyNTLMDomain: Option[String] = None, jcrcontentproxyNTLMHost: Option[String] = None, jcrcontentproxyHost: Option[String] = None, jcrcontentproxyPassword: Option[String] = None, jcrcontentproxyPort: Option[Number] = None, jcrcontentproxyUser: Option[String] = None, jcrcontentqueueBatchMaxSize: Option[Number] = None, jcrcontentqueueBatchMode: Option[String] = None, jcrcontentqueueBatchWaitTime: Option[Number] = None, jcrcontentretryDelay: Option[String] = None, jcrcontentreverseReplication: Option[Boolean] = None, jcrcontentserializationType: Option[String] = None, jcrcontentslingresourceType: Option[String] = None, jcrcontentssl: Option[String] = None, jcrcontenttransportNTLMDomain: Option[String] = None, jcrcontenttransportNTLMHost: Option[String] = None, jcrcontenttransportPassword: Option[String] = None, jcrcontenttransportUri: Option[String] = None, jcrcontenttransportUser: Option[String] = None, jcrcontenttriggerDistribute: Option[Boolean] = None, jcrcontenttriggerModified: Option[Boolean] = None, jcrcontenttriggerOnOffTime: Option[Boolean] = None, jcrcontenttriggerReceive: Option[Boolean] = None, jcrcontenttriggerSpecific: Option[Boolean] = None, jcrcontentuserId: Option[String] = None, jcrprimaryType: Option[String] = None, operation: Option[String] = None) = {
      helper.postAgent(runmode, name, jcrcontentcqdistribute, jcrcontentcqdistributeTypeHint, jcrcontentcqname, jcrcontentcqtemplate, jcrcontentenabled, jcrcontentjcrdescription, jcrcontentjcrlastModified, jcrcontentjcrlastModifiedBy, jcrcontentjcrmixinTypes, jcrcontentjcrtitle, jcrcontentlogLevel, jcrcontentnoStatusUpdate, jcrcontentnoVersioning, jcrcontentprotocolConnectTimeout, jcrcontentprotocolHTTPConnectionClosed, jcrcontentprotocolHTTPExpired, jcrcontentprotocolHTTPHeaders, jcrcontentprotocolHTTPHeadersTypeHint, jcrcontentprotocolHTTPMethod, jcrcontentprotocolHTTPSRelaxed, jcrcontentprotocolInterface, jcrcontentprotocolSocketTimeout, jcrcontentprotocolVersion, jcrcontentproxyNTLMDomain, jcrcontentproxyNTLMHost, jcrcontentproxyHost, jcrcontentproxyPassword, jcrcontentproxyPort, jcrcontentproxyUser, jcrcontentqueueBatchMaxSize, jcrcontentqueueBatchMode, jcrcontentqueueBatchWaitTime, jcrcontentretryDelay, jcrcontentreverseReplication, jcrcontentserializationType, jcrcontentslingresourceType, jcrcontentssl, jcrcontenttransportNTLMDomain, jcrcontenttransportNTLMHost, jcrcontenttransportPassword, jcrcontenttransportUri, jcrcontenttransportUser, jcrcontenttriggerDistribute, jcrcontenttriggerModified, jcrcontenttriggerOnOffTime, jcrcontenttriggerReceive, jcrcontenttriggerSpecific, jcrcontentuserId, jcrprimaryType, operation)
  }

  /**
   * 
   * 
   *
   * @param intermediatePath  
   * @param authorizableId  
   * @param operation  (optional)
   * @param currentPassword  (optional)
   * @param newPassword  (optional)
   * @param rePassword  (optional)
   * @param keyPassword  (optional)
   * @param keyStorePass  (optional)
   * @param alias  (optional)
   * @param newAlias  (optional)
   * @param removeAlias  (optional)
   * @param certChain  (optional)
   * @param pk  (optional)
   * @param keyStore  (optional)
   * @return KeystoreInfo
   */
  def postAuthorizableKeystore(intermediatePath: String, authorizableId: String, operation: Option[String] = None, currentPassword: Option[String] = None, newPassword: Option[String] = None, rePassword: Option[String] = None, keyPassword: Option[String] = None, keyStorePass: Option[String] = None, alias: Option[String] = None, newAlias: Option[String] = None, removeAlias: Option[String] = None, certChain: Option[File] = None, pk: Option[File] = None, keyStore: Option[File] = None): Option[KeystoreInfo] = {
    val await = Try(Await.result(postAuthorizableKeystoreAsync(intermediatePath, authorizableId, operation, currentPassword, newPassword, rePassword, keyPassword, keyStorePass, alias, newAlias, removeAlias, certChain, pk, keyStore), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param intermediatePath  
   * @param authorizableId  
   * @param operation  (optional)
   * @param currentPassword  (optional)
   * @param newPassword  (optional)
   * @param rePassword  (optional)
   * @param keyPassword  (optional)
   * @param keyStorePass  (optional)
   * @param alias  (optional)
   * @param newAlias  (optional)
   * @param removeAlias  (optional)
   * @param certChain  (optional)
   * @param pk  (optional)
   * @param keyStore  (optional)
   * @return Future(KeystoreInfo)
   */
  def postAuthorizableKeystoreAsync(intermediatePath: String, authorizableId: String, operation: Option[String] = None, currentPassword: Option[String] = None, newPassword: Option[String] = None, rePassword: Option[String] = None, keyPassword: Option[String] = None, keyStorePass: Option[String] = None, alias: Option[String] = None, newAlias: Option[String] = None, removeAlias: Option[String] = None, certChain: Option[File] = None, pk: Option[File] = None, keyStore: Option[File] = None): Future[KeystoreInfo] = {
      helper.postAuthorizableKeystore(intermediatePath, authorizableId, operation, currentPassword, newPassword, rePassword, keyPassword, keyStorePass, alias, newAlias, removeAlias, certChain, pk, keyStore)
  }

  /**
   * 
   * 
   *
   * @param authorizableId  
   * @param intermediatePath  
   * @param createUser  (optional)
   * @param createGroup  (optional)
   * @param reppassword  (optional)
   * @param profilegivenName  (optional)
   * @return String
   */
  def postAuthorizables(authorizableId: String, intermediatePath: String, createUser: Option[String] = None, createGroup: Option[String] = None, reppassword: Option[String] = None, profilegivenName: Option[String] = None): Option[String] = {
    val await = Try(Await.result(postAuthorizablesAsync(authorizableId, intermediatePath, createUser, createGroup, reppassword, profilegivenName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param authorizableId  
   * @param intermediatePath  
   * @param createUser  (optional)
   * @param createGroup  (optional)
   * @param reppassword  (optional)
   * @param profilegivenName  (optional)
   * @return Future(String)
   */
  def postAuthorizablesAsync(authorizableId: String, intermediatePath: String, createUser: Option[String] = None, createGroup: Option[String] = None, reppassword: Option[String] = None, profilegivenName: Option[String] = None): Future[String] = {
      helper.postAuthorizables(authorizableId, intermediatePath, createUser, createGroup, reppassword, profilegivenName)
  }

  /**
   * 
   * 
   *
   * @param keyStorePassword  (optional)
   * @param keyStorePasswordTypeHint  (optional)
   * @param serviceRanking  (optional)
   * @param serviceRankingTypeHint  (optional)
   * @param idpHttpRedirect  (optional)
   * @param idpHttpRedirectTypeHint  (optional)
   * @param createUser  (optional)
   * @param createUserTypeHint  (optional)
   * @param defaultRedirectUrl  (optional)
   * @param defaultRedirectUrlTypeHint  (optional)
   * @param userIDAttribute  (optional)
   * @param userIDAttributeTypeHint  (optional)
   * @param defaultGroups  (optional)
   * @param defaultGroupsTypeHint  (optional)
   * @param idpCertAlias  (optional)
   * @param idpCertAliasTypeHint  (optional)
   * @param addGroupMemberships  (optional)
   * @param addGroupMembershipsTypeHint  (optional)
   * @param `path`  (optional)
   * @param pathTypeHint  (optional)
   * @param synchronizeAttributes  (optional)
   * @param synchronizeAttributesTypeHint  (optional)
   * @param clockTolerance  (optional)
   * @param clockToleranceTypeHint  (optional)
   * @param groupMembershipAttribute  (optional)
   * @param groupMembershipAttributeTypeHint  (optional)
   * @param idpUrl  (optional)
   * @param idpUrlTypeHint  (optional)
   * @param logoutUrl  (optional)
   * @param logoutUrlTypeHint  (optional)
   * @param serviceProviderEntityId  (optional)
   * @param serviceProviderEntityIdTypeHint  (optional)
   * @param assertionConsumerServiceURL  (optional)
   * @param assertionConsumerServiceURLTypeHint  (optional)
   * @param handleLogout  (optional)
   * @param handleLogoutTypeHint  (optional)
   * @param spPrivateKeyAlias  (optional)
   * @param spPrivateKeyAliasTypeHint  (optional)
   * @param useEncryption  (optional)
   * @param useEncryptionTypeHint  (optional)
   * @param nameIdFormat  (optional)
   * @param nameIdFormatTypeHint  (optional)
   * @param digestMethod  (optional)
   * @param digestMethodTypeHint  (optional)
   * @param signatureMethod  (optional)
   * @param signatureMethodTypeHint  (optional)
   * @param userIntermediatePath  (optional)
   * @param userIntermediatePathTypeHint  (optional)
   * @return void
   */
  def postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword: Option[String] = None, keyStorePasswordTypeHint: Option[String] = None, serviceRanking: Option[Integer] = None, serviceRankingTypeHint: Option[String] = None, idpHttpRedirect: Option[Boolean] = None, idpHttpRedirectTypeHint: Option[String] = None, createUser: Option[Boolean] = None, createUserTypeHint: Option[String] = None, defaultRedirectUrl: Option[String] = None, defaultRedirectUrlTypeHint: Option[String] = None, userIDAttribute: Option[String] = None, userIDAttributeTypeHint: Option[String] = None, defaultGroups: Option[List[String]] = None, defaultGroupsTypeHint: Option[String] = None, idpCertAlias: Option[String] = None, idpCertAliasTypeHint: Option[String] = None, addGroupMemberships: Option[Boolean] = None, addGroupMembershipsTypeHint: Option[String] = None, `path`: Option[List[String]] = None, pathTypeHint: Option[String] = None, synchronizeAttributes: Option[List[String]] = None, synchronizeAttributesTypeHint: Option[String] = None, clockTolerance: Option[Integer] = None, clockToleranceTypeHint: Option[String] = None, groupMembershipAttribute: Option[String] = None, groupMembershipAttributeTypeHint: Option[String] = None, idpUrl: Option[String] = None, idpUrlTypeHint: Option[String] = None, logoutUrl: Option[String] = None, logoutUrlTypeHint: Option[String] = None, serviceProviderEntityId: Option[String] = None, serviceProviderEntityIdTypeHint: Option[String] = None, assertionConsumerServiceURL: Option[String] = None, assertionConsumerServiceURLTypeHint: Option[String] = None, handleLogout: Option[Boolean] = None, handleLogoutTypeHint: Option[String] = None, spPrivateKeyAlias: Option[String] = None, spPrivateKeyAliasTypeHint: Option[String] = None, useEncryption: Option[Boolean] = None, useEncryptionTypeHint: Option[String] = None, nameIdFormat: Option[String] = None, nameIdFormatTypeHint: Option[String] = None, digestMethod: Option[String] = None, digestMethodTypeHint: Option[String] = None, signatureMethod: Option[String] = None, signatureMethodTypeHint: Option[String] = None, userIntermediatePath: Option[String] = None, userIntermediatePathTypeHint: Option[String] = None) = {
    val await = Try(Await.result(postConfigAdobeGraniteSamlAuthenticationHandlerAsync(keyStorePassword, keyStorePasswordTypeHint, serviceRanking, serviceRankingTypeHint, idpHttpRedirect, idpHttpRedirectTypeHint, createUser, createUserTypeHint, defaultRedirectUrl, defaultRedirectUrlTypeHint, userIDAttribute, userIDAttributeTypeHint, defaultGroups, defaultGroupsTypeHint, idpCertAlias, idpCertAliasTypeHint, addGroupMemberships, addGroupMembershipsTypeHint, `path`, pathTypeHint, synchronizeAttributes, synchronizeAttributesTypeHint, clockTolerance, clockToleranceTypeHint, groupMembershipAttribute, groupMembershipAttributeTypeHint, idpUrl, idpUrlTypeHint, logoutUrl, logoutUrlTypeHint, serviceProviderEntityId, serviceProviderEntityIdTypeHint, assertionConsumerServiceURL, assertionConsumerServiceURLTypeHint, handleLogout, handleLogoutTypeHint, spPrivateKeyAlias, spPrivateKeyAliasTypeHint, useEncryption, useEncryptionTypeHint, nameIdFormat, nameIdFormatTypeHint, digestMethod, digestMethodTypeHint, signatureMethod, signatureMethodTypeHint, userIntermediatePath, userIntermediatePathTypeHint), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param keyStorePassword  (optional)
   * @param keyStorePasswordTypeHint  (optional)
   * @param serviceRanking  (optional)
   * @param serviceRankingTypeHint  (optional)
   * @param idpHttpRedirect  (optional)
   * @param idpHttpRedirectTypeHint  (optional)
   * @param createUser  (optional)
   * @param createUserTypeHint  (optional)
   * @param defaultRedirectUrl  (optional)
   * @param defaultRedirectUrlTypeHint  (optional)
   * @param userIDAttribute  (optional)
   * @param userIDAttributeTypeHint  (optional)
   * @param defaultGroups  (optional)
   * @param defaultGroupsTypeHint  (optional)
   * @param idpCertAlias  (optional)
   * @param idpCertAliasTypeHint  (optional)
   * @param addGroupMemberships  (optional)
   * @param addGroupMembershipsTypeHint  (optional)
   * @param `path`  (optional)
   * @param pathTypeHint  (optional)
   * @param synchronizeAttributes  (optional)
   * @param synchronizeAttributesTypeHint  (optional)
   * @param clockTolerance  (optional)
   * @param clockToleranceTypeHint  (optional)
   * @param groupMembershipAttribute  (optional)
   * @param groupMembershipAttributeTypeHint  (optional)
   * @param idpUrl  (optional)
   * @param idpUrlTypeHint  (optional)
   * @param logoutUrl  (optional)
   * @param logoutUrlTypeHint  (optional)
   * @param serviceProviderEntityId  (optional)
   * @param serviceProviderEntityIdTypeHint  (optional)
   * @param assertionConsumerServiceURL  (optional)
   * @param assertionConsumerServiceURLTypeHint  (optional)
   * @param handleLogout  (optional)
   * @param handleLogoutTypeHint  (optional)
   * @param spPrivateKeyAlias  (optional)
   * @param spPrivateKeyAliasTypeHint  (optional)
   * @param useEncryption  (optional)
   * @param useEncryptionTypeHint  (optional)
   * @param nameIdFormat  (optional)
   * @param nameIdFormatTypeHint  (optional)
   * @param digestMethod  (optional)
   * @param digestMethodTypeHint  (optional)
   * @param signatureMethod  (optional)
   * @param signatureMethodTypeHint  (optional)
   * @param userIntermediatePath  (optional)
   * @param userIntermediatePathTypeHint  (optional)
   * @return Future(void)
   */
  def postConfigAdobeGraniteSamlAuthenticationHandlerAsync(keyStorePassword: Option[String] = None, keyStorePasswordTypeHint: Option[String] = None, serviceRanking: Option[Integer] = None, serviceRankingTypeHint: Option[String] = None, idpHttpRedirect: Option[Boolean] = None, idpHttpRedirectTypeHint: Option[String] = None, createUser: Option[Boolean] = None, createUserTypeHint: Option[String] = None, defaultRedirectUrl: Option[String] = None, defaultRedirectUrlTypeHint: Option[String] = None, userIDAttribute: Option[String] = None, userIDAttributeTypeHint: Option[String] = None, defaultGroups: Option[List[String]] = None, defaultGroupsTypeHint: Option[String] = None, idpCertAlias: Option[String] = None, idpCertAliasTypeHint: Option[String] = None, addGroupMemberships: Option[Boolean] = None, addGroupMembershipsTypeHint: Option[String] = None, `path`: Option[List[String]] = None, pathTypeHint: Option[String] = None, synchronizeAttributes: Option[List[String]] = None, synchronizeAttributesTypeHint: Option[String] = None, clockTolerance: Option[Integer] = None, clockToleranceTypeHint: Option[String] = None, groupMembershipAttribute: Option[String] = None, groupMembershipAttributeTypeHint: Option[String] = None, idpUrl: Option[String] = None, idpUrlTypeHint: Option[String] = None, logoutUrl: Option[String] = None, logoutUrlTypeHint: Option[String] = None, serviceProviderEntityId: Option[String] = None, serviceProviderEntityIdTypeHint: Option[String] = None, assertionConsumerServiceURL: Option[String] = None, assertionConsumerServiceURLTypeHint: Option[String] = None, handleLogout: Option[Boolean] = None, handleLogoutTypeHint: Option[String] = None, spPrivateKeyAlias: Option[String] = None, spPrivateKeyAliasTypeHint: Option[String] = None, useEncryption: Option[Boolean] = None, useEncryptionTypeHint: Option[String] = None, nameIdFormat: Option[String] = None, nameIdFormatTypeHint: Option[String] = None, digestMethod: Option[String] = None, digestMethodTypeHint: Option[String] = None, signatureMethod: Option[String] = None, signatureMethodTypeHint: Option[String] = None, userIntermediatePath: Option[String] = None, userIntermediatePathTypeHint: Option[String] = None) = {
      helper.postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword, keyStorePasswordTypeHint, serviceRanking, serviceRankingTypeHint, idpHttpRedirect, idpHttpRedirectTypeHint, createUser, createUserTypeHint, defaultRedirectUrl, defaultRedirectUrlTypeHint, userIDAttribute, userIDAttributeTypeHint, defaultGroups, defaultGroupsTypeHint, idpCertAlias, idpCertAliasTypeHint, addGroupMemberships, addGroupMembershipsTypeHint, `path`, pathTypeHint, synchronizeAttributes, synchronizeAttributesTypeHint, clockTolerance, clockToleranceTypeHint, groupMembershipAttribute, groupMembershipAttributeTypeHint, idpUrl, idpUrlTypeHint, logoutUrl, logoutUrlTypeHint, serviceProviderEntityId, serviceProviderEntityIdTypeHint, assertionConsumerServiceURL, assertionConsumerServiceURLTypeHint, handleLogout, handleLogoutTypeHint, spPrivateKeyAlias, spPrivateKeyAliasTypeHint, useEncryption, useEncryptionTypeHint, nameIdFormat, nameIdFormatTypeHint, digestMethod, digestMethodTypeHint, signatureMethod, signatureMethodTypeHint, userIntermediatePath, userIntermediatePathTypeHint)
  }

  /**
   * 
   * 
   *
   * @param orgApacheFelixHttpsNio  (optional)
   * @param orgApacheFelixHttpsNioTypeHint  (optional)
   * @param orgApacheFelixHttpsKeystore  (optional)
   * @param orgApacheFelixHttpsKeystoreTypeHint  (optional)
   * @param orgApacheFelixHttpsKeystorePassword  (optional)
   * @param orgApacheFelixHttpsKeystorePasswordTypeHint  (optional)
   * @param orgApacheFelixHttpsKeystoreKey  (optional)
   * @param orgApacheFelixHttpsKeystoreKeyTypeHint  (optional)
   * @param orgApacheFelixHttpsKeystoreKeyPassword  (optional)
   * @param orgApacheFelixHttpsKeystoreKeyPasswordTypeHint  (optional)
   * @param orgApacheFelixHttpsTruststore  (optional)
   * @param orgApacheFelixHttpsTruststoreTypeHint  (optional)
   * @param orgApacheFelixHttpsTruststorePassword  (optional)
   * @param orgApacheFelixHttpsTruststorePasswordTypeHint  (optional)
   * @param orgApacheFelixHttpsClientcertificate  (optional)
   * @param orgApacheFelixHttpsClientcertificateTypeHint  (optional)
   * @param orgApacheFelixHttpsEnable  (optional)
   * @param orgApacheFelixHttpsEnableTypeHint  (optional)
   * @param orgOsgiServiceHttpPortSecure  (optional)
   * @param orgOsgiServiceHttpPortSecureTypeHint  (optional)
   * @return void
   */
  def postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio: Option[Boolean] = None, orgApacheFelixHttpsNioTypeHint: Option[String] = None, orgApacheFelixHttpsKeystore: Option[String] = None, orgApacheFelixHttpsKeystoreTypeHint: Option[String] = None, orgApacheFelixHttpsKeystorePassword: Option[String] = None, orgApacheFelixHttpsKeystorePasswordTypeHint: Option[String] = None, orgApacheFelixHttpsKeystoreKey: Option[String] = None, orgApacheFelixHttpsKeystoreKeyTypeHint: Option[String] = None, orgApacheFelixHttpsKeystoreKeyPassword: Option[String] = None, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint: Option[String] = None, orgApacheFelixHttpsTruststore: Option[String] = None, orgApacheFelixHttpsTruststoreTypeHint: Option[String] = None, orgApacheFelixHttpsTruststorePassword: Option[String] = None, orgApacheFelixHttpsTruststorePasswordTypeHint: Option[String] = None, orgApacheFelixHttpsClientcertificate: Option[String] = None, orgApacheFelixHttpsClientcertificateTypeHint: Option[String] = None, orgApacheFelixHttpsEnable: Option[Boolean] = None, orgApacheFelixHttpsEnableTypeHint: Option[String] = None, orgOsgiServiceHttpPortSecure: Option[String] = None, orgOsgiServiceHttpPortSecureTypeHint: Option[String] = None) = {
    val await = Try(Await.result(postConfigApacheFelixJettyBasedHttpServiceAsync(orgApacheFelixHttpsNio, orgApacheFelixHttpsNioTypeHint, orgApacheFelixHttpsKeystore, orgApacheFelixHttpsKeystoreTypeHint, orgApacheFelixHttpsKeystorePassword, orgApacheFelixHttpsKeystorePasswordTypeHint, orgApacheFelixHttpsKeystoreKey, orgApacheFelixHttpsKeystoreKeyTypeHint, orgApacheFelixHttpsKeystoreKeyPassword, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint, orgApacheFelixHttpsTruststore, orgApacheFelixHttpsTruststoreTypeHint, orgApacheFelixHttpsTruststorePassword, orgApacheFelixHttpsTruststorePasswordTypeHint, orgApacheFelixHttpsClientcertificate, orgApacheFelixHttpsClientcertificateTypeHint, orgApacheFelixHttpsEnable, orgApacheFelixHttpsEnableTypeHint, orgOsgiServiceHttpPortSecure, orgOsgiServiceHttpPortSecureTypeHint), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param orgApacheFelixHttpsNio  (optional)
   * @param orgApacheFelixHttpsNioTypeHint  (optional)
   * @param orgApacheFelixHttpsKeystore  (optional)
   * @param orgApacheFelixHttpsKeystoreTypeHint  (optional)
   * @param orgApacheFelixHttpsKeystorePassword  (optional)
   * @param orgApacheFelixHttpsKeystorePasswordTypeHint  (optional)
   * @param orgApacheFelixHttpsKeystoreKey  (optional)
   * @param orgApacheFelixHttpsKeystoreKeyTypeHint  (optional)
   * @param orgApacheFelixHttpsKeystoreKeyPassword  (optional)
   * @param orgApacheFelixHttpsKeystoreKeyPasswordTypeHint  (optional)
   * @param orgApacheFelixHttpsTruststore  (optional)
   * @param orgApacheFelixHttpsTruststoreTypeHint  (optional)
   * @param orgApacheFelixHttpsTruststorePassword  (optional)
   * @param orgApacheFelixHttpsTruststorePasswordTypeHint  (optional)
   * @param orgApacheFelixHttpsClientcertificate  (optional)
   * @param orgApacheFelixHttpsClientcertificateTypeHint  (optional)
   * @param orgApacheFelixHttpsEnable  (optional)
   * @param orgApacheFelixHttpsEnableTypeHint  (optional)
   * @param orgOsgiServiceHttpPortSecure  (optional)
   * @param orgOsgiServiceHttpPortSecureTypeHint  (optional)
   * @return Future(void)
   */
  def postConfigApacheFelixJettyBasedHttpServiceAsync(orgApacheFelixHttpsNio: Option[Boolean] = None, orgApacheFelixHttpsNioTypeHint: Option[String] = None, orgApacheFelixHttpsKeystore: Option[String] = None, orgApacheFelixHttpsKeystoreTypeHint: Option[String] = None, orgApacheFelixHttpsKeystorePassword: Option[String] = None, orgApacheFelixHttpsKeystorePasswordTypeHint: Option[String] = None, orgApacheFelixHttpsKeystoreKey: Option[String] = None, orgApacheFelixHttpsKeystoreKeyTypeHint: Option[String] = None, orgApacheFelixHttpsKeystoreKeyPassword: Option[String] = None, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint: Option[String] = None, orgApacheFelixHttpsTruststore: Option[String] = None, orgApacheFelixHttpsTruststoreTypeHint: Option[String] = None, orgApacheFelixHttpsTruststorePassword: Option[String] = None, orgApacheFelixHttpsTruststorePasswordTypeHint: Option[String] = None, orgApacheFelixHttpsClientcertificate: Option[String] = None, orgApacheFelixHttpsClientcertificateTypeHint: Option[String] = None, orgApacheFelixHttpsEnable: Option[Boolean] = None, orgApacheFelixHttpsEnableTypeHint: Option[String] = None, orgOsgiServiceHttpPortSecure: Option[String] = None, orgOsgiServiceHttpPortSecureTypeHint: Option[String] = None) = {
      helper.postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio, orgApacheFelixHttpsNioTypeHint, orgApacheFelixHttpsKeystore, orgApacheFelixHttpsKeystoreTypeHint, orgApacheFelixHttpsKeystorePassword, orgApacheFelixHttpsKeystorePasswordTypeHint, orgApacheFelixHttpsKeystoreKey, orgApacheFelixHttpsKeystoreKeyTypeHint, orgApacheFelixHttpsKeystoreKeyPassword, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint, orgApacheFelixHttpsTruststore, orgApacheFelixHttpsTruststoreTypeHint, orgApacheFelixHttpsTruststorePassword, orgApacheFelixHttpsTruststorePasswordTypeHint, orgApacheFelixHttpsClientcertificate, orgApacheFelixHttpsClientcertificateTypeHint, orgApacheFelixHttpsEnable, orgApacheFelixHttpsEnableTypeHint, orgOsgiServiceHttpPortSecure, orgOsgiServiceHttpPortSecureTypeHint)
  }

  /**
   * 
   * 
   *
   * @param proxyHost  (optional)
   * @param proxyHostTypeHint  (optional)
   * @param proxyPort  (optional)
   * @param proxyPortTypeHint  (optional)
   * @param proxyExceptions  (optional)
   * @param proxyExceptionsTypeHint  (optional)
   * @param proxyEnabled  (optional)
   * @param proxyEnabledTypeHint  (optional)
   * @param proxyUser  (optional)
   * @param proxyUserTypeHint  (optional)
   * @param proxyPassword  (optional)
   * @param proxyPasswordTypeHint  (optional)
   * @return void
   */
  def postConfigApacheHttpComponentsProxyConfiguration(proxyHost: Option[String] = None, proxyHostTypeHint: Option[String] = None, proxyPort: Option[Integer] = None, proxyPortTypeHint: Option[String] = None, proxyExceptions: Option[List[String]] = None, proxyExceptionsTypeHint: Option[String] = None, proxyEnabled: Option[Boolean] = None, proxyEnabledTypeHint: Option[String] = None, proxyUser: Option[String] = None, proxyUserTypeHint: Option[String] = None, proxyPassword: Option[String] = None, proxyPasswordTypeHint: Option[String] = None) = {
    val await = Try(Await.result(postConfigApacheHttpComponentsProxyConfigurationAsync(proxyHost, proxyHostTypeHint, proxyPort, proxyPortTypeHint, proxyExceptions, proxyExceptionsTypeHint, proxyEnabled, proxyEnabledTypeHint, proxyUser, proxyUserTypeHint, proxyPassword, proxyPasswordTypeHint), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param proxyHost  (optional)
   * @param proxyHostTypeHint  (optional)
   * @param proxyPort  (optional)
   * @param proxyPortTypeHint  (optional)
   * @param proxyExceptions  (optional)
   * @param proxyExceptionsTypeHint  (optional)
   * @param proxyEnabled  (optional)
   * @param proxyEnabledTypeHint  (optional)
   * @param proxyUser  (optional)
   * @param proxyUserTypeHint  (optional)
   * @param proxyPassword  (optional)
   * @param proxyPasswordTypeHint  (optional)
   * @return Future(void)
   */
  def postConfigApacheHttpComponentsProxyConfigurationAsync(proxyHost: Option[String] = None, proxyHostTypeHint: Option[String] = None, proxyPort: Option[Integer] = None, proxyPortTypeHint: Option[String] = None, proxyExceptions: Option[List[String]] = None, proxyExceptionsTypeHint: Option[String] = None, proxyEnabled: Option[Boolean] = None, proxyEnabledTypeHint: Option[String] = None, proxyUser: Option[String] = None, proxyUserTypeHint: Option[String] = None, proxyPassword: Option[String] = None, proxyPasswordTypeHint: Option[String] = None) = {
      helper.postConfigApacheHttpComponentsProxyConfiguration(proxyHost, proxyHostTypeHint, proxyPort, proxyPortTypeHint, proxyExceptions, proxyExceptionsTypeHint, proxyEnabled, proxyEnabledTypeHint, proxyUser, proxyUserTypeHint, proxyPassword, proxyPasswordTypeHint)
  }

  /**
   * 
   * 
   *
   * @param alias  (optional)
   * @param aliasTypeHint  (optional)
   * @param davCreateAbsoluteUri  (optional)
   * @param davCreateAbsoluteUriTypeHint  (optional)
   * @return void
   */
  def postConfigApacheSlingDavExServlet(alias: Option[String] = None, aliasTypeHint: Option[String] = None, davCreateAbsoluteUri: Option[Boolean] = None, davCreateAbsoluteUriTypeHint: Option[String] = None) = {
    val await = Try(Await.result(postConfigApacheSlingDavExServletAsync(alias, aliasTypeHint, davCreateAbsoluteUri, davCreateAbsoluteUriTypeHint), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param alias  (optional)
   * @param aliasTypeHint  (optional)
   * @param davCreateAbsoluteUri  (optional)
   * @param davCreateAbsoluteUriTypeHint  (optional)
   * @return Future(void)
   */
  def postConfigApacheSlingDavExServletAsync(alias: Option[String] = None, aliasTypeHint: Option[String] = None, davCreateAbsoluteUri: Option[Boolean] = None, davCreateAbsoluteUriTypeHint: Option[String] = None) = {
      helper.postConfigApacheSlingDavExServlet(alias, aliasTypeHint, davCreateAbsoluteUri, davCreateAbsoluteUriTypeHint)
  }

  /**
   * 
   * 
   *
   * @param jsonMaximumresults  (optional)
   * @param jsonMaximumresultsTypeHint  (optional)
   * @param enableHtml  (optional)
   * @param enableHtmlTypeHint  (optional)
   * @param enableTxt  (optional)
   * @param enableTxtTypeHint  (optional)
   * @param enableXml  (optional)
   * @param enableXmlTypeHint  (optional)
   * @return void
   */
  def postConfigApacheSlingGetServlet(jsonMaximumresults: Option[String] = None, jsonMaximumresultsTypeHint: Option[String] = None, enableHtml: Option[Boolean] = None, enableHtmlTypeHint: Option[String] = None, enableTxt: Option[Boolean] = None, enableTxtTypeHint: Option[String] = None, enableXml: Option[Boolean] = None, enableXmlTypeHint: Option[String] = None) = {
    val await = Try(Await.result(postConfigApacheSlingGetServletAsync(jsonMaximumresults, jsonMaximumresultsTypeHint, enableHtml, enableHtmlTypeHint, enableTxt, enableTxtTypeHint, enableXml, enableXmlTypeHint), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param jsonMaximumresults  (optional)
   * @param jsonMaximumresultsTypeHint  (optional)
   * @param enableHtml  (optional)
   * @param enableHtmlTypeHint  (optional)
   * @param enableTxt  (optional)
   * @param enableTxtTypeHint  (optional)
   * @param enableXml  (optional)
   * @param enableXmlTypeHint  (optional)
   * @return Future(void)
   */
  def postConfigApacheSlingGetServletAsync(jsonMaximumresults: Option[String] = None, jsonMaximumresultsTypeHint: Option[String] = None, enableHtml: Option[Boolean] = None, enableHtmlTypeHint: Option[String] = None, enableTxt: Option[Boolean] = None, enableTxtTypeHint: Option[String] = None, enableXml: Option[Boolean] = None, enableXmlTypeHint: Option[String] = None) = {
      helper.postConfigApacheSlingGetServlet(jsonMaximumresults, jsonMaximumresultsTypeHint, enableHtml, enableHtmlTypeHint, enableTxt, enableTxtTypeHint, enableXml, enableXmlTypeHint)
  }

  /**
   * 
   * 
   *
   * @param allowEmpty  (optional)
   * @param allowEmptyTypeHint  (optional)
   * @param allowHosts  (optional)
   * @param allowHostsTypeHint  (optional)
   * @param allowHostsRegexp  (optional)
   * @param allowHostsRegexpTypeHint  (optional)
   * @param filterMethods  (optional)
   * @param filterMethodsTypeHint  (optional)
   * @return void
   */
  def postConfigApacheSlingReferrerFilter(allowEmpty: Option[Boolean] = None, allowEmptyTypeHint: Option[String] = None, allowHosts: Option[String] = None, allowHostsTypeHint: Option[String] = None, allowHostsRegexp: Option[String] = None, allowHostsRegexpTypeHint: Option[String] = None, filterMethods: Option[String] = None, filterMethodsTypeHint: Option[String] = None) = {
    val await = Try(Await.result(postConfigApacheSlingReferrerFilterAsync(allowEmpty, allowEmptyTypeHint, allowHosts, allowHostsTypeHint, allowHostsRegexp, allowHostsRegexpTypeHint, filterMethods, filterMethodsTypeHint), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param allowEmpty  (optional)
   * @param allowEmptyTypeHint  (optional)
   * @param allowHosts  (optional)
   * @param allowHostsTypeHint  (optional)
   * @param allowHostsRegexp  (optional)
   * @param allowHostsRegexpTypeHint  (optional)
   * @param filterMethods  (optional)
   * @param filterMethodsTypeHint  (optional)
   * @return Future(void)
   */
  def postConfigApacheSlingReferrerFilterAsync(allowEmpty: Option[Boolean] = None, allowEmptyTypeHint: Option[String] = None, allowHosts: Option[String] = None, allowHostsTypeHint: Option[String] = None, allowHostsRegexp: Option[String] = None, allowHostsRegexpTypeHint: Option[String] = None, filterMethods: Option[String] = None, filterMethodsTypeHint: Option[String] = None) = {
      helper.postConfigApacheSlingReferrerFilter(allowEmpty, allowEmptyTypeHint, allowHosts, allowHostsTypeHint, allowHostsRegexp, allowHostsRegexpTypeHint, filterMethods, filterMethodsTypeHint)
  }

  /**
   * 
   * 
   *
   * @param `path`  
   * @param name  
   * @param operation  (optional)
   * @param deleteAuthorizable  (optional)
   * @param file  (optional)
   * @return void
   */
  def postNode(`path`: String, name: String, operation: Option[String] = None, deleteAuthorizable: Option[String] = None, file: Option[File] = None) = {
    val await = Try(Await.result(postNodeAsync(`path`, name, operation, deleteAuthorizable, file), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param `path`  
   * @param name  
   * @param operation  (optional)
   * @param deleteAuthorizable  (optional)
   * @param file  (optional)
   * @return Future(void)
   */
  def postNodeAsync(`path`: String, name: String, operation: Option[String] = None, deleteAuthorizable: Option[String] = None, file: Option[File] = None) = {
      helper.postNode(`path`, name, operation, deleteAuthorizable, file)
  }

  /**
   * 
   * 
   *
   * @param `path`  
   * @param name  
   * @param addMembers  (optional)
   * @return void
   */
  def postNodeRw(`path`: String, name: String, addMembers: Option[String] = None) = {
    val await = Try(Await.result(postNodeRwAsync(`path`, name, addMembers), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param `path`  
   * @param name  
   * @param addMembers  (optional)
   * @return Future(void)
   */
  def postNodeRwAsync(`path`: String, name: String, addMembers: Option[String] = None) = {
      helper.postNodeRw(`path`, name, addMembers)
  }

  /**
   * 
   * 
   *
   * @param `path`  
   * @param jcrprimaryType  
   * @param name  
   * @return void
   */
  def postPath(`path`: String, jcrprimaryType: String, name: String) = {
    val await = Try(Await.result(postPathAsync(`path`, jcrprimaryType, name), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param `path`  
   * @param jcrprimaryType  
   * @param name  
   * @return Future(void)
   */
  def postPathAsync(`path`: String, jcrprimaryType: String, name: String) = {
      helper.postPath(`path`, jcrprimaryType, name)
  }

  /**
   * 
   * 
   *
   * @param `path`  
   * @param pLimit  
   * @param `1property`  
   * @param `1propertyValue`  
   * @return String
   */
  def postQuery(`path`: String, pLimit: Number, `1property`: String, `1propertyValue`: String): Option[String] = {
    val await = Try(Await.result(postQueryAsync(`path`, pLimit, `1property`, `1propertyValue`), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param `path`  
   * @param pLimit  
   * @param `1property`  
   * @param `1propertyValue`  
   * @return Future(String)
   */
  def postQueryAsync(`path`: String, pLimit: Number, `1property`: String, `1propertyValue`: String): Future[String] = {
      helper.postQuery(`path`, pLimit, `1property`, `1propertyValue`)
  }

  /**
   * 
   * 
   *
   * @param ignoredeactivated  
   * @param onlymodified  
   * @param `path`  
   * @return void
   */
  def postTreeActivation(ignoredeactivated: Boolean, onlymodified: Boolean, `path`: String) = {
    val await = Try(Await.result(postTreeActivationAsync(ignoredeactivated, onlymodified, `path`), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param ignoredeactivated  
   * @param onlymodified  
   * @param `path`  
   * @return Future(void)
   */
  def postTreeActivationAsync(ignoredeactivated: Boolean, onlymodified: Boolean, `path`: String) = {
      helper.postTreeActivation(ignoredeactivated, onlymodified, `path`)
  }

  /**
   * 
   * 
   *
   * @param operation  (optional)
   * @param newPassword  (optional)
   * @param rePassword  (optional)
   * @param keyStoreType  (optional)
   * @param removeAlias  (optional)
   * @param certificate  (optional)
   * @return String
   */
  def postTruststore(operation: Option[String] = None, newPassword: Option[String] = None, rePassword: Option[String] = None, keyStoreType: Option[String] = None, removeAlias: Option[String] = None, certificate: Option[File] = None): Option[String] = {
    val await = Try(Await.result(postTruststoreAsync(operation, newPassword, rePassword, keyStoreType, removeAlias, certificate), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param operation  (optional)
   * @param newPassword  (optional)
   * @param rePassword  (optional)
   * @param keyStoreType  (optional)
   * @param removeAlias  (optional)
   * @param certificate  (optional)
   * @return Future(String)
   */
  def postTruststoreAsync(operation: Option[String] = None, newPassword: Option[String] = None, rePassword: Option[String] = None, keyStoreType: Option[String] = None, removeAlias: Option[String] = None, certificate: Option[File] = None): Future[String] = {
      helper.postTruststore(operation, newPassword, rePassword, keyStoreType, removeAlias, certificate)
  }

  /**
   * 
   * 
   *
   * @param truststoreP12  (optional)
   * @return String
   */
  def postTruststorePKCS12(truststoreP12: Option[File] = None): Option[String] = {
    val await = Try(Await.result(postTruststorePKCS12Async(truststoreP12), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param truststoreP12  (optional)
   * @return Future(String)
   */
  def postTruststorePKCS12Async(truststoreP12: Option[File] = None): Future[String] = {
      helper.postTruststorePKCS12(truststoreP12)
  }

}

class SlingApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def deleteAgent(runmode: String,
    name: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/etc/replication/agents.{runmode}/{name}")
      replaceAll("\\{" + "runmode" + "\\}", runmode.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (runmode == null) throw new Exception("Missing required parameter 'runmode' when calling SlingApi->deleteAgent")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling SlingApi->deleteAgent")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteNode(`path`: String,
    name: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/{path}/{name}")
      replaceAll("\\{" + "path" + "\\}", `path`.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`path` == null) throw new Exception("Missing required parameter '`path`' when calling SlingApi->deleteNode")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling SlingApi->deleteNode")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getAgent(runmode: String,
    name: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/etc/replication/agents.{runmode}/{name}")
      replaceAll("\\{" + "runmode" + "\\}", runmode.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (runmode == null) throw new Exception("Missing required parameter 'runmode' when calling SlingApi->getAgent")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling SlingApi->getAgent")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getAgents(runmode: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/etc/replication/agents.{runmode}.-1.json")
      replaceAll("\\{" + "runmode" + "\\}", runmode.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (runmode == null) throw new Exception("Missing required parameter 'runmode' when calling SlingApi->getAgents")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getAuthorizableKeystore(intermediatePath: String,
    authorizableId: String)(implicit reader: ClientResponseReader[KeystoreInfo]): Future[KeystoreInfo] = {
    // create path and map variables
    val path = (addFmt("/{intermediatePath}/{authorizableId}.ks.json")
      replaceAll("\\{" + "intermediatePath" + "\\}", intermediatePath.toString)
      replaceAll("\\{" + "authorizableId" + "\\}", authorizableId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (intermediatePath == null) throw new Exception("Missing required parameter 'intermediatePath' when calling SlingApi->getAuthorizableKeystore")

    if (authorizableId == null) throw new Exception("Missing required parameter 'authorizableId' when calling SlingApi->getAuthorizableKeystore")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getKeystore(intermediatePath: String,
    authorizableId: String)(implicit reader: ClientResponseReader[File]): Future[File] = {
    // create path and map variables
    val path = (addFmt("/{intermediatePath}/{authorizableId}/keystore/store.p12")
      replaceAll("\\{" + "intermediatePath" + "\\}", intermediatePath.toString)
      replaceAll("\\{" + "authorizableId" + "\\}", authorizableId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (intermediatePath == null) throw new Exception("Missing required parameter 'intermediatePath' when calling SlingApi->getKeystore")

    if (authorizableId == null) throw new Exception("Missing required parameter 'authorizableId' when calling SlingApi->getKeystore")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getNode(`path`: String,
    name: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/{path}/{name}")
      replaceAll("\\{" + "path" + "\\}", `path`.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`path` == null) throw new Exception("Missing required parameter '`path`' when calling SlingApi->getNode")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling SlingApi->getNode")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getPackage(group: String,
    name: String,
    version: String)(implicit reader: ClientResponseReader[File]): Future[File] = {
    // create path and map variables
    val path = (addFmt("/etc/packages/{group}/{name}-{version}.zip")
      replaceAll("\\{" + "group" + "\\}", group.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString)
      replaceAll("\\{" + "version" + "\\}", version.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (group == null) throw new Exception("Missing required parameter 'group' when calling SlingApi->getPackage")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling SlingApi->getPackage")

    if (version == null) throw new Exception("Missing required parameter 'version' when calling SlingApi->getPackage")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getPackageFilter(group: String,
    name: String,
    version: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json")
      replaceAll("\\{" + "group" + "\\}", group.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString)
      replaceAll("\\{" + "version" + "\\}", version.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (group == null) throw new Exception("Missing required parameter 'group' when calling SlingApi->getPackageFilter")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling SlingApi->getPackageFilter")

    if (version == null) throw new Exception("Missing required parameter 'version' when calling SlingApi->getPackageFilter")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getQuery(`path`: String,
    pLimit: Number,
    `1property`: String,
    `1propertyValue`: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/bin/querybuilder.json"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`path` == null) throw new Exception("Missing required parameter '`path`' when calling SlingApi->getQuery")

    if (`1property` == null) throw new Exception("Missing required parameter '`1property`' when calling SlingApi->getQuery")

    if (`1propertyValue` == null) throw new Exception("Missing required parameter '`1propertyValue`' when calling SlingApi->getQuery")

    queryParams += "path" -> `path`.toString
    queryParams += "p.limit" -> pLimit.toString
    queryParams += "1_property" -> `1property`.toString
    queryParams += "1_property.value" -> `1propertyValue`.toString

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getTruststore()(implicit reader: ClientResponseReader[File]): Future[File] = {
    // create path and map variables
    val path = (addFmt("/etc/truststore/truststore.p12"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getTruststoreInfo()(implicit reader: ClientResponseReader[TruststoreInfo]): Future[TruststoreInfo] = {
    // create path and map variables
    val path = (addFmt("/libs/granite/security/truststore.json"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postAgent(runmode: String,
    name: String,
    jcrcontentcqdistribute: Option[Boolean] = None,
    jcrcontentcqdistributeTypeHint: Option[String] = None,
    jcrcontentcqname: Option[String] = None,
    jcrcontentcqtemplate: Option[String] = None,
    jcrcontentenabled: Option[Boolean] = None,
    jcrcontentjcrdescription: Option[String] = None,
    jcrcontentjcrlastModified: Option[String] = None,
    jcrcontentjcrlastModifiedBy: Option[String] = None,
    jcrcontentjcrmixinTypes: Option[String] = None,
    jcrcontentjcrtitle: Option[String] = None,
    jcrcontentlogLevel: Option[String] = None,
    jcrcontentnoStatusUpdate: Option[Boolean] = None,
    jcrcontentnoVersioning: Option[Boolean] = None,
    jcrcontentprotocolConnectTimeout: Option[Number] = None,
    jcrcontentprotocolHTTPConnectionClosed: Option[Boolean] = None,
    jcrcontentprotocolHTTPExpired: Option[String] = None,
    jcrcontentprotocolHTTPHeaders: Option[List[String]] = None,
    jcrcontentprotocolHTTPHeadersTypeHint: Option[String] = None,
    jcrcontentprotocolHTTPMethod: Option[String] = None,
    jcrcontentprotocolHTTPSRelaxed: Option[Boolean] = None,
    jcrcontentprotocolInterface: Option[String] = None,
    jcrcontentprotocolSocketTimeout: Option[Number] = None,
    jcrcontentprotocolVersion: Option[String] = None,
    jcrcontentproxyNTLMDomain: Option[String] = None,
    jcrcontentproxyNTLMHost: Option[String] = None,
    jcrcontentproxyHost: Option[String] = None,
    jcrcontentproxyPassword: Option[String] = None,
    jcrcontentproxyPort: Option[Number] = None,
    jcrcontentproxyUser: Option[String] = None,
    jcrcontentqueueBatchMaxSize: Option[Number] = None,
    jcrcontentqueueBatchMode: Option[String] = None,
    jcrcontentqueueBatchWaitTime: Option[Number] = None,
    jcrcontentretryDelay: Option[String] = None,
    jcrcontentreverseReplication: Option[Boolean] = None,
    jcrcontentserializationType: Option[String] = None,
    jcrcontentslingresourceType: Option[String] = None,
    jcrcontentssl: Option[String] = None,
    jcrcontenttransportNTLMDomain: Option[String] = None,
    jcrcontenttransportNTLMHost: Option[String] = None,
    jcrcontenttransportPassword: Option[String] = None,
    jcrcontenttransportUri: Option[String] = None,
    jcrcontenttransportUser: Option[String] = None,
    jcrcontenttriggerDistribute: Option[Boolean] = None,
    jcrcontenttriggerModified: Option[Boolean] = None,
    jcrcontenttriggerOnOffTime: Option[Boolean] = None,
    jcrcontenttriggerReceive: Option[Boolean] = None,
    jcrcontenttriggerSpecific: Option[Boolean] = None,
    jcrcontentuserId: Option[String] = None,
    jcrprimaryType: Option[String] = None,
    operation: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/etc/replication/agents.{runmode}/{name}")
      replaceAll("\\{" + "runmode" + "\\}", runmode.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (runmode == null) throw new Exception("Missing required parameter 'runmode' when calling SlingApi->postAgent")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling SlingApi->postAgent")

    jcrcontentcqdistribute match {
      case Some(param) => queryParams += "jcr:content/cq:distribute" -> param.toString
      case _ => queryParams
    }
    jcrcontentcqdistributeTypeHint match {
      case Some(param) => queryParams += "jcr:content/cq:distribute@TypeHint" -> param.toString
      case _ => queryParams
    }
    jcrcontentcqname match {
      case Some(param) => queryParams += "jcr:content/cq:name" -> param.toString
      case _ => queryParams
    }
    jcrcontentcqtemplate match {
      case Some(param) => queryParams += "jcr:content/cq:template" -> param.toString
      case _ => queryParams
    }
    jcrcontentenabled match {
      case Some(param) => queryParams += "jcr:content/enabled" -> param.toString
      case _ => queryParams
    }
    jcrcontentjcrdescription match {
      case Some(param) => queryParams += "jcr:content/jcr:description" -> param.toString
      case _ => queryParams
    }
    jcrcontentjcrlastModified match {
      case Some(param) => queryParams += "jcr:content/jcr:lastModified" -> param.toString
      case _ => queryParams
    }
    jcrcontentjcrlastModifiedBy match {
      case Some(param) => queryParams += "jcr:content/jcr:lastModifiedBy" -> param.toString
      case _ => queryParams
    }
    jcrcontentjcrmixinTypes match {
      case Some(param) => queryParams += "jcr:content/jcr:mixinTypes" -> param.toString
      case _ => queryParams
    }
    jcrcontentjcrtitle match {
      case Some(param) => queryParams += "jcr:content/jcr:title" -> param.toString
      case _ => queryParams
    }
    jcrcontentlogLevel match {
      case Some(param) => queryParams += "jcr:content/logLevel" -> param.toString
      case _ => queryParams
    }
    jcrcontentnoStatusUpdate match {
      case Some(param) => queryParams += "jcr:content/noStatusUpdate" -> param.toString
      case _ => queryParams
    }
    jcrcontentnoVersioning match {
      case Some(param) => queryParams += "jcr:content/noVersioning" -> param.toString
      case _ => queryParams
    }
    jcrcontentprotocolConnectTimeout match {
      case Some(param) => queryParams += "jcr:content/protocolConnectTimeout" -> param.toString
      case _ => queryParams
    }
    jcrcontentprotocolHTTPConnectionClosed match {
      case Some(param) => queryParams += "jcr:content/protocolHTTPConnectionClosed" -> param.toString
      case _ => queryParams
    }
    jcrcontentprotocolHTTPExpired match {
      case Some(param) => queryParams += "jcr:content/protocolHTTPExpired" -> param.toString
      case _ => queryParams
    }
    jcrcontentprotocolHTTPHeaders match {
      case Some(param) => queryParams += "jcr:content/protocolHTTPHeaders" -> param.toString
      case _ => queryParams
    }
    jcrcontentprotocolHTTPHeadersTypeHint match {
      case Some(param) => queryParams += "jcr:content/protocolHTTPHeaders@TypeHint" -> param.toString
      case _ => queryParams
    }
    jcrcontentprotocolHTTPMethod match {
      case Some(param) => queryParams += "jcr:content/protocolHTTPMethod" -> param.toString
      case _ => queryParams
    }
    jcrcontentprotocolHTTPSRelaxed match {
      case Some(param) => queryParams += "jcr:content/protocolHTTPSRelaxed" -> param.toString
      case _ => queryParams
    }
    jcrcontentprotocolInterface match {
      case Some(param) => queryParams += "jcr:content/protocolInterface" -> param.toString
      case _ => queryParams
    }
    jcrcontentprotocolSocketTimeout match {
      case Some(param) => queryParams += "jcr:content/protocolSocketTimeout" -> param.toString
      case _ => queryParams
    }
    jcrcontentprotocolVersion match {
      case Some(param) => queryParams += "jcr:content/protocolVersion" -> param.toString
      case _ => queryParams
    }
    jcrcontentproxyNTLMDomain match {
      case Some(param) => queryParams += "jcr:content/proxyNTLMDomain" -> param.toString
      case _ => queryParams
    }
    jcrcontentproxyNTLMHost match {
      case Some(param) => queryParams += "jcr:content/proxyNTLMHost" -> param.toString
      case _ => queryParams
    }
    jcrcontentproxyHost match {
      case Some(param) => queryParams += "jcr:content/proxyHost" -> param.toString
      case _ => queryParams
    }
    jcrcontentproxyPassword match {
      case Some(param) => queryParams += "jcr:content/proxyPassword" -> param.toString
      case _ => queryParams
    }
    jcrcontentproxyPort match {
      case Some(param) => queryParams += "jcr:content/proxyPort" -> param.toString
      case _ => queryParams
    }
    jcrcontentproxyUser match {
      case Some(param) => queryParams += "jcr:content/proxyUser" -> param.toString
      case _ => queryParams
    }
    jcrcontentqueueBatchMaxSize match {
      case Some(param) => queryParams += "jcr:content/queueBatchMaxSize" -> param.toString
      case _ => queryParams
    }
    jcrcontentqueueBatchMode match {
      case Some(param) => queryParams += "jcr:content/queueBatchMode" -> param.toString
      case _ => queryParams
    }
    jcrcontentqueueBatchWaitTime match {
      case Some(param) => queryParams += "jcr:content/queueBatchWaitTime" -> param.toString
      case _ => queryParams
    }
    jcrcontentretryDelay match {
      case Some(param) => queryParams += "jcr:content/retryDelay" -> param.toString
      case _ => queryParams
    }
    jcrcontentreverseReplication match {
      case Some(param) => queryParams += "jcr:content/reverseReplication" -> param.toString
      case _ => queryParams
    }
    jcrcontentserializationType match {
      case Some(param) => queryParams += "jcr:content/serializationType" -> param.toString
      case _ => queryParams
    }
    jcrcontentslingresourceType match {
      case Some(param) => queryParams += "jcr:content/sling:resourceType" -> param.toString
      case _ => queryParams
    }
    jcrcontentssl match {
      case Some(param) => queryParams += "jcr:content/ssl" -> param.toString
      case _ => queryParams
    }
    jcrcontenttransportNTLMDomain match {
      case Some(param) => queryParams += "jcr:content/transportNTLMDomain" -> param.toString
      case _ => queryParams
    }
    jcrcontenttransportNTLMHost match {
      case Some(param) => queryParams += "jcr:content/transportNTLMHost" -> param.toString
      case _ => queryParams
    }
    jcrcontenttransportPassword match {
      case Some(param) => queryParams += "jcr:content/transportPassword" -> param.toString
      case _ => queryParams
    }
    jcrcontenttransportUri match {
      case Some(param) => queryParams += "jcr:content/transportUri" -> param.toString
      case _ => queryParams
    }
    jcrcontenttransportUser match {
      case Some(param) => queryParams += "jcr:content/transportUser" -> param.toString
      case _ => queryParams
    }
    jcrcontenttriggerDistribute match {
      case Some(param) => queryParams += "jcr:content/triggerDistribute" -> param.toString
      case _ => queryParams
    }
    jcrcontenttriggerModified match {
      case Some(param) => queryParams += "jcr:content/triggerModified" -> param.toString
      case _ => queryParams
    }
    jcrcontenttriggerOnOffTime match {
      case Some(param) => queryParams += "jcr:content/triggerOnOffTime" -> param.toString
      case _ => queryParams
    }
    jcrcontenttriggerReceive match {
      case Some(param) => queryParams += "jcr:content/triggerReceive" -> param.toString
      case _ => queryParams
    }
    jcrcontenttriggerSpecific match {
      case Some(param) => queryParams += "jcr:content/triggerSpecific" -> param.toString
      case _ => queryParams
    }
    jcrcontentuserId match {
      case Some(param) => queryParams += "jcr:content/userId" -> param.toString
      case _ => queryParams
    }
    jcrprimaryType match {
      case Some(param) => queryParams += "jcr:primaryType" -> param.toString
      case _ => queryParams
    }
    operation match {
      case Some(param) => queryParams += ":operation" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postAuthorizableKeystore(intermediatePath: String,
    authorizableId: String,
    operation: Option[String] = None,
    currentPassword: Option[String] = None,
    newPassword: Option[String] = None,
    rePassword: Option[String] = None,
    keyPassword: Option[String] = None,
    keyStorePass: Option[String] = None,
    alias: Option[String] = None,
    newAlias: Option[String] = None,
    removeAlias: Option[String] = None,
    certChain: Option[File] = None,
    pk: Option[File] = None,
    keyStore: Option[File] = None
    )(implicit reader: ClientResponseReader[KeystoreInfo]): Future[KeystoreInfo] = {
    // create path and map variables
    val path = (addFmt("/{intermediatePath}/{authorizableId}.ks.html")
      replaceAll("\\{" + "intermediatePath" + "\\}", intermediatePath.toString)
      replaceAll("\\{" + "authorizableId" + "\\}", authorizableId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (intermediatePath == null) throw new Exception("Missing required parameter 'intermediatePath' when calling SlingApi->postAuthorizableKeystore")

    if (authorizableId == null) throw new Exception("Missing required parameter 'authorizableId' when calling SlingApi->postAuthorizableKeystore")

    operation match {
      case Some(param) => queryParams += ":operation" -> param.toString
      case _ => queryParams
    }
    currentPassword match {
      case Some(param) => queryParams += "currentPassword" -> param.toString
      case _ => queryParams
    }
    newPassword match {
      case Some(param) => queryParams += "newPassword" -> param.toString
      case _ => queryParams
    }
    rePassword match {
      case Some(param) => queryParams += "rePassword" -> param.toString
      case _ => queryParams
    }
    keyPassword match {
      case Some(param) => queryParams += "keyPassword" -> param.toString
      case _ => queryParams
    }
    keyStorePass match {
      case Some(param) => queryParams += "keyStorePass" -> param.toString
      case _ => queryParams
    }
    alias match {
      case Some(param) => queryParams += "alias" -> param.toString
      case _ => queryParams
    }
    newAlias match {
      case Some(param) => queryParams += "newAlias" -> param.toString
      case _ => queryParams
    }
    removeAlias match {
      case Some(param) => queryParams += "removeAlias" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postAuthorizables(authorizableId: String,
    intermediatePath: String,
    createUser: Option[String] = None,
    createGroup: Option[String] = None,
    reppassword: Option[String] = None,
    profilegivenName: Option[String] = None
    )(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/libs/granite/security/post/authorizables"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (authorizableId == null) throw new Exception("Missing required parameter 'authorizableId' when calling SlingApi->postAuthorizables")

    if (intermediatePath == null) throw new Exception("Missing required parameter 'intermediatePath' when calling SlingApi->postAuthorizables")

    queryParams += "authorizableId" -> authorizableId.toString
    queryParams += "intermediatePath" -> intermediatePath.toString
    createUser match {
      case Some(param) => queryParams += "createUser" -> param.toString
      case _ => queryParams
    }
    createGroup match {
      case Some(param) => queryParams += "createGroup" -> param.toString
      case _ => queryParams
    }
    reppassword match {
      case Some(param) => queryParams += "rep:password" -> param.toString
      case _ => queryParams
    }
    profilegivenName match {
      case Some(param) => queryParams += "profile/givenName" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword: Option[String] = None,
    keyStorePasswordTypeHint: Option[String] = None,
    serviceRanking: Option[Integer] = None,
    serviceRankingTypeHint: Option[String] = None,
    idpHttpRedirect: Option[Boolean] = None,
    idpHttpRedirectTypeHint: Option[String] = None,
    createUser: Option[Boolean] = None,
    createUserTypeHint: Option[String] = None,
    defaultRedirectUrl: Option[String] = None,
    defaultRedirectUrlTypeHint: Option[String] = None,
    userIDAttribute: Option[String] = None,
    userIDAttributeTypeHint: Option[String] = None,
    defaultGroups: Option[List[String]] = None,
    defaultGroupsTypeHint: Option[String] = None,
    idpCertAlias: Option[String] = None,
    idpCertAliasTypeHint: Option[String] = None,
    addGroupMemberships: Option[Boolean] = None,
    addGroupMembershipsTypeHint: Option[String] = None,
    `path`: Option[List[String]] = None,
    pathTypeHint: Option[String] = None,
    synchronizeAttributes: Option[List[String]] = None,
    synchronizeAttributesTypeHint: Option[String] = None,
    clockTolerance: Option[Integer] = None,
    clockToleranceTypeHint: Option[String] = None,
    groupMembershipAttribute: Option[String] = None,
    groupMembershipAttributeTypeHint: Option[String] = None,
    idpUrl: Option[String] = None,
    idpUrlTypeHint: Option[String] = None,
    logoutUrl: Option[String] = None,
    logoutUrlTypeHint: Option[String] = None,
    serviceProviderEntityId: Option[String] = None,
    serviceProviderEntityIdTypeHint: Option[String] = None,
    assertionConsumerServiceURL: Option[String] = None,
    assertionConsumerServiceURLTypeHint: Option[String] = None,
    handleLogout: Option[Boolean] = None,
    handleLogoutTypeHint: Option[String] = None,
    spPrivateKeyAlias: Option[String] = None,
    spPrivateKeyAliasTypeHint: Option[String] = None,
    useEncryption: Option[Boolean] = None,
    useEncryptionTypeHint: Option[String] = None,
    nameIdFormat: Option[String] = None,
    nameIdFormatTypeHint: Option[String] = None,
    digestMethod: Option[String] = None,
    digestMethodTypeHint: Option[String] = None,
    signatureMethod: Option[String] = None,
    signatureMethodTypeHint: Option[String] = None,
    userIntermediatePath: Option[String] = None,
    userIntermediatePathTypeHint: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    keyStorePassword match {
      case Some(param) => queryParams += "keyStorePassword" -> param.toString
      case _ => queryParams
    }
    keyStorePasswordTypeHint match {
      case Some(param) => queryParams += "keyStorePassword@TypeHint" -> param.toString
      case _ => queryParams
    }
    serviceRanking match {
      case Some(param) => queryParams += "service.ranking" -> param.toString
      case _ => queryParams
    }
    serviceRankingTypeHint match {
      case Some(param) => queryParams += "service.ranking@TypeHint" -> param.toString
      case _ => queryParams
    }
    idpHttpRedirect match {
      case Some(param) => queryParams += "idpHttpRedirect" -> param.toString
      case _ => queryParams
    }
    idpHttpRedirectTypeHint match {
      case Some(param) => queryParams += "idpHttpRedirect@TypeHint" -> param.toString
      case _ => queryParams
    }
    createUser match {
      case Some(param) => queryParams += "createUser" -> param.toString
      case _ => queryParams
    }
    createUserTypeHint match {
      case Some(param) => queryParams += "createUser@TypeHint" -> param.toString
      case _ => queryParams
    }
    defaultRedirectUrl match {
      case Some(param) => queryParams += "defaultRedirectUrl" -> param.toString
      case _ => queryParams
    }
    defaultRedirectUrlTypeHint match {
      case Some(param) => queryParams += "defaultRedirectUrl@TypeHint" -> param.toString
      case _ => queryParams
    }
    userIDAttribute match {
      case Some(param) => queryParams += "userIDAttribute" -> param.toString
      case _ => queryParams
    }
    userIDAttributeTypeHint match {
      case Some(param) => queryParams += "userIDAttribute@TypeHint" -> param.toString
      case _ => queryParams
    }
    defaultGroups match {
      case Some(param) => queryParams += "defaultGroups" -> param.toString
      case _ => queryParams
    }
    defaultGroupsTypeHint match {
      case Some(param) => queryParams += "defaultGroups@TypeHint" -> param.toString
      case _ => queryParams
    }
    idpCertAlias match {
      case Some(param) => queryParams += "idpCertAlias" -> param.toString
      case _ => queryParams
    }
    idpCertAliasTypeHint match {
      case Some(param) => queryParams += "idpCertAlias@TypeHint" -> param.toString
      case _ => queryParams
    }
    addGroupMemberships match {
      case Some(param) => queryParams += "addGroupMemberships" -> param.toString
      case _ => queryParams
    }
    addGroupMembershipsTypeHint match {
      case Some(param) => queryParams += "addGroupMemberships@TypeHint" -> param.toString
      case _ => queryParams
    }
    `path` match {
      case Some(param) => queryParams += "path" -> param.toString
      case _ => queryParams
    }
    pathTypeHint match {
      case Some(param) => queryParams += "path@TypeHint" -> param.toString
      case _ => queryParams
    }
    synchronizeAttributes match {
      case Some(param) => queryParams += "synchronizeAttributes" -> param.toString
      case _ => queryParams
    }
    synchronizeAttributesTypeHint match {
      case Some(param) => queryParams += "synchronizeAttributes@TypeHint" -> param.toString
      case _ => queryParams
    }
    clockTolerance match {
      case Some(param) => queryParams += "clockTolerance" -> param.toString
      case _ => queryParams
    }
    clockToleranceTypeHint match {
      case Some(param) => queryParams += "clockTolerance@TypeHint" -> param.toString
      case _ => queryParams
    }
    groupMembershipAttribute match {
      case Some(param) => queryParams += "groupMembershipAttribute" -> param.toString
      case _ => queryParams
    }
    groupMembershipAttributeTypeHint match {
      case Some(param) => queryParams += "groupMembershipAttribute@TypeHint" -> param.toString
      case _ => queryParams
    }
    idpUrl match {
      case Some(param) => queryParams += "idpUrl" -> param.toString
      case _ => queryParams
    }
    idpUrlTypeHint match {
      case Some(param) => queryParams += "idpUrl@TypeHint" -> param.toString
      case _ => queryParams
    }
    logoutUrl match {
      case Some(param) => queryParams += "logoutUrl" -> param.toString
      case _ => queryParams
    }
    logoutUrlTypeHint match {
      case Some(param) => queryParams += "logoutUrl@TypeHint" -> param.toString
      case _ => queryParams
    }
    serviceProviderEntityId match {
      case Some(param) => queryParams += "serviceProviderEntityId" -> param.toString
      case _ => queryParams
    }
    serviceProviderEntityIdTypeHint match {
      case Some(param) => queryParams += "serviceProviderEntityId@TypeHint" -> param.toString
      case _ => queryParams
    }
    assertionConsumerServiceURL match {
      case Some(param) => queryParams += "assertionConsumerServiceURL" -> param.toString
      case _ => queryParams
    }
    assertionConsumerServiceURLTypeHint match {
      case Some(param) => queryParams += "assertionConsumerServiceURL@TypeHint" -> param.toString
      case _ => queryParams
    }
    handleLogout match {
      case Some(param) => queryParams += "handleLogout" -> param.toString
      case _ => queryParams
    }
    handleLogoutTypeHint match {
      case Some(param) => queryParams += "handleLogout@TypeHint" -> param.toString
      case _ => queryParams
    }
    spPrivateKeyAlias match {
      case Some(param) => queryParams += "spPrivateKeyAlias" -> param.toString
      case _ => queryParams
    }
    spPrivateKeyAliasTypeHint match {
      case Some(param) => queryParams += "spPrivateKeyAlias@TypeHint" -> param.toString
      case _ => queryParams
    }
    useEncryption match {
      case Some(param) => queryParams += "useEncryption" -> param.toString
      case _ => queryParams
    }
    useEncryptionTypeHint match {
      case Some(param) => queryParams += "useEncryption@TypeHint" -> param.toString
      case _ => queryParams
    }
    nameIdFormat match {
      case Some(param) => queryParams += "nameIdFormat" -> param.toString
      case _ => queryParams
    }
    nameIdFormatTypeHint match {
      case Some(param) => queryParams += "nameIdFormat@TypeHint" -> param.toString
      case _ => queryParams
    }
    digestMethod match {
      case Some(param) => queryParams += "digestMethod" -> param.toString
      case _ => queryParams
    }
    digestMethodTypeHint match {
      case Some(param) => queryParams += "digestMethod@TypeHint" -> param.toString
      case _ => queryParams
    }
    signatureMethod match {
      case Some(param) => queryParams += "signatureMethod" -> param.toString
      case _ => queryParams
    }
    signatureMethodTypeHint match {
      case Some(param) => queryParams += "signatureMethod@TypeHint" -> param.toString
      case _ => queryParams
    }
    userIntermediatePath match {
      case Some(param) => queryParams += "userIntermediatePath" -> param.toString
      case _ => queryParams
    }
    userIntermediatePathTypeHint match {
      case Some(param) => queryParams += "userIntermediatePath@TypeHint" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio: Option[Boolean] = None,
    orgApacheFelixHttpsNioTypeHint: Option[String] = None,
    orgApacheFelixHttpsKeystore: Option[String] = None,
    orgApacheFelixHttpsKeystoreTypeHint: Option[String] = None,
    orgApacheFelixHttpsKeystorePassword: Option[String] = None,
    orgApacheFelixHttpsKeystorePasswordTypeHint: Option[String] = None,
    orgApacheFelixHttpsKeystoreKey: Option[String] = None,
    orgApacheFelixHttpsKeystoreKeyTypeHint: Option[String] = None,
    orgApacheFelixHttpsKeystoreKeyPassword: Option[String] = None,
    orgApacheFelixHttpsKeystoreKeyPasswordTypeHint: Option[String] = None,
    orgApacheFelixHttpsTruststore: Option[String] = None,
    orgApacheFelixHttpsTruststoreTypeHint: Option[String] = None,
    orgApacheFelixHttpsTruststorePassword: Option[String] = None,
    orgApacheFelixHttpsTruststorePasswordTypeHint: Option[String] = None,
    orgApacheFelixHttpsClientcertificate: Option[String] = None,
    orgApacheFelixHttpsClientcertificateTypeHint: Option[String] = None,
    orgApacheFelixHttpsEnable: Option[Boolean] = None,
    orgApacheFelixHttpsEnableTypeHint: Option[String] = None,
    orgOsgiServiceHttpPortSecure: Option[String] = None,
    orgOsgiServiceHttpPortSecureTypeHint: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/apps/system/config/org.apache.felix.http"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    orgApacheFelixHttpsNio match {
      case Some(param) => queryParams += "org.apache.felix.https.nio" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsNioTypeHint match {
      case Some(param) => queryParams += "org.apache.felix.https.nio@TypeHint" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsKeystore match {
      case Some(param) => queryParams += "org.apache.felix.https.keystore" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsKeystoreTypeHint match {
      case Some(param) => queryParams += "org.apache.felix.https.keystore@TypeHint" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsKeystorePassword match {
      case Some(param) => queryParams += "org.apache.felix.https.keystore.password" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsKeystorePasswordTypeHint match {
      case Some(param) => queryParams += "org.apache.felix.https.keystore.password@TypeHint" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsKeystoreKey match {
      case Some(param) => queryParams += "org.apache.felix.https.keystore.key" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsKeystoreKeyTypeHint match {
      case Some(param) => queryParams += "org.apache.felix.https.keystore.key@TypeHint" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsKeystoreKeyPassword match {
      case Some(param) => queryParams += "org.apache.felix.https.keystore.key.password" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsKeystoreKeyPasswordTypeHint match {
      case Some(param) => queryParams += "org.apache.felix.https.keystore.key.password@TypeHint" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsTruststore match {
      case Some(param) => queryParams += "org.apache.felix.https.truststore" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsTruststoreTypeHint match {
      case Some(param) => queryParams += "org.apache.felix.https.truststore@TypeHint" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsTruststorePassword match {
      case Some(param) => queryParams += "org.apache.felix.https.truststore.password" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsTruststorePasswordTypeHint match {
      case Some(param) => queryParams += "org.apache.felix.https.truststore.password@TypeHint" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsClientcertificate match {
      case Some(param) => queryParams += "org.apache.felix.https.clientcertificate" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsClientcertificateTypeHint match {
      case Some(param) => queryParams += "org.apache.felix.https.clientcertificate@TypeHint" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsEnable match {
      case Some(param) => queryParams += "org.apache.felix.https.enable" -> param.toString
      case _ => queryParams
    }
    orgApacheFelixHttpsEnableTypeHint match {
      case Some(param) => queryParams += "org.apache.felix.https.enable@TypeHint" -> param.toString
      case _ => queryParams
    }
    orgOsgiServiceHttpPortSecure match {
      case Some(param) => queryParams += "org.osgi.service.http.port.secure" -> param.toString
      case _ => queryParams
    }
    orgOsgiServiceHttpPortSecureTypeHint match {
      case Some(param) => queryParams += "org.osgi.service.http.port.secure@TypeHint" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postConfigApacheHttpComponentsProxyConfiguration(proxyHost: Option[String] = None,
    proxyHostTypeHint: Option[String] = None,
    proxyPort: Option[Integer] = None,
    proxyPortTypeHint: Option[String] = None,
    proxyExceptions: Option[List[String]] = None,
    proxyExceptionsTypeHint: Option[String] = None,
    proxyEnabled: Option[Boolean] = None,
    proxyEnabledTypeHint: Option[String] = None,
    proxyUser: Option[String] = None,
    proxyUserTypeHint: Option[String] = None,
    proxyPassword: Option[String] = None,
    proxyPasswordTypeHint: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/apps/system/config/org.apache.http.proxyconfigurator.config"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    proxyHost match {
      case Some(param) => queryParams += "proxy.host" -> param.toString
      case _ => queryParams
    }
    proxyHostTypeHint match {
      case Some(param) => queryParams += "proxy.host@TypeHint" -> param.toString
      case _ => queryParams
    }
    proxyPort match {
      case Some(param) => queryParams += "proxy.port" -> param.toString
      case _ => queryParams
    }
    proxyPortTypeHint match {
      case Some(param) => queryParams += "proxy.port@TypeHint" -> param.toString
      case _ => queryParams
    }
    proxyExceptions match {
      case Some(param) => queryParams += "proxy.exceptions" -> param.toString
      case _ => queryParams
    }
    proxyExceptionsTypeHint match {
      case Some(param) => queryParams += "proxy.exceptions@TypeHint" -> param.toString
      case _ => queryParams
    }
    proxyEnabled match {
      case Some(param) => queryParams += "proxy.enabled" -> param.toString
      case _ => queryParams
    }
    proxyEnabledTypeHint match {
      case Some(param) => queryParams += "proxy.enabled@TypeHint" -> param.toString
      case _ => queryParams
    }
    proxyUser match {
      case Some(param) => queryParams += "proxy.user" -> param.toString
      case _ => queryParams
    }
    proxyUserTypeHint match {
      case Some(param) => queryParams += "proxy.user@TypeHint" -> param.toString
      case _ => queryParams
    }
    proxyPassword match {
      case Some(param) => queryParams += "proxy.password" -> param.toString
      case _ => queryParams
    }
    proxyPasswordTypeHint match {
      case Some(param) => queryParams += "proxy.password@TypeHint" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postConfigApacheSlingDavExServlet(alias: Option[String] = None,
    aliasTypeHint: Option[String] = None,
    davCreateAbsoluteUri: Option[Boolean] = None,
    davCreateAbsoluteUriTypeHint: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    alias match {
      case Some(param) => queryParams += "alias" -> param.toString
      case _ => queryParams
    }
    aliasTypeHint match {
      case Some(param) => queryParams += "alias@TypeHint" -> param.toString
      case _ => queryParams
    }
    davCreateAbsoluteUri match {
      case Some(param) => queryParams += "dav.create-absolute-uri" -> param.toString
      case _ => queryParams
    }
    davCreateAbsoluteUriTypeHint match {
      case Some(param) => queryParams += "dav.create-absolute-uri@TypeHint" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postConfigApacheSlingGetServlet(jsonMaximumresults: Option[String] = None,
    jsonMaximumresultsTypeHint: Option[String] = None,
    enableHtml: Option[Boolean] = None,
    enableHtmlTypeHint: Option[String] = None,
    enableTxt: Option[Boolean] = None,
    enableTxtTypeHint: Option[String] = None,
    enableXml: Option[Boolean] = None,
    enableXmlTypeHint: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    jsonMaximumresults match {
      case Some(param) => queryParams += "json.maximumresults" -> param.toString
      case _ => queryParams
    }
    jsonMaximumresultsTypeHint match {
      case Some(param) => queryParams += "json.maximumresults@TypeHint" -> param.toString
      case _ => queryParams
    }
    enableHtml match {
      case Some(param) => queryParams += "enable.html" -> param.toString
      case _ => queryParams
    }
    enableHtmlTypeHint match {
      case Some(param) => queryParams += "enable.html@TypeHint" -> param.toString
      case _ => queryParams
    }
    enableTxt match {
      case Some(param) => queryParams += "enable.txt" -> param.toString
      case _ => queryParams
    }
    enableTxtTypeHint match {
      case Some(param) => queryParams += "enable.txt@TypeHint" -> param.toString
      case _ => queryParams
    }
    enableXml match {
      case Some(param) => queryParams += "enable.xml" -> param.toString
      case _ => queryParams
    }
    enableXmlTypeHint match {
      case Some(param) => queryParams += "enable.xml@TypeHint" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postConfigApacheSlingReferrerFilter(allowEmpty: Option[Boolean] = None,
    allowEmptyTypeHint: Option[String] = None,
    allowHosts: Option[String] = None,
    allowHostsTypeHint: Option[String] = None,
    allowHostsRegexp: Option[String] = None,
    allowHostsRegexpTypeHint: Option[String] = None,
    filterMethods: Option[String] = None,
    filterMethodsTypeHint: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/apps/system/config/org.apache.sling.security.impl.ReferrerFilter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    allowEmpty match {
      case Some(param) => queryParams += "allow.empty" -> param.toString
      case _ => queryParams
    }
    allowEmptyTypeHint match {
      case Some(param) => queryParams += "allow.empty@TypeHint" -> param.toString
      case _ => queryParams
    }
    allowHosts match {
      case Some(param) => queryParams += "allow.hosts" -> param.toString
      case _ => queryParams
    }
    allowHostsTypeHint match {
      case Some(param) => queryParams += "allow.hosts@TypeHint" -> param.toString
      case _ => queryParams
    }
    allowHostsRegexp match {
      case Some(param) => queryParams += "allow.hosts.regexp" -> param.toString
      case _ => queryParams
    }
    allowHostsRegexpTypeHint match {
      case Some(param) => queryParams += "allow.hosts.regexp@TypeHint" -> param.toString
      case _ => queryParams
    }
    filterMethods match {
      case Some(param) => queryParams += "filter.methods" -> param.toString
      case _ => queryParams
    }
    filterMethodsTypeHint match {
      case Some(param) => queryParams += "filter.methods@TypeHint" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postNode(`path`: String,
    name: String,
    operation: Option[String] = None,
    deleteAuthorizable: Option[String] = None,
    file: Option[File] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/{path}/{name}")
      replaceAll("\\{" + "path" + "\\}", `path`.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`path` == null) throw new Exception("Missing required parameter '`path`' when calling SlingApi->postNode")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling SlingApi->postNode")

    operation match {
      case Some(param) => queryParams += ":operation" -> param.toString
      case _ => queryParams
    }
    deleteAuthorizable match {
      case Some(param) => queryParams += "deleteAuthorizable" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postNodeRw(`path`: String,
    name: String,
    addMembers: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/{path}/{name}.rw.html")
      replaceAll("\\{" + "path" + "\\}", `path`.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`path` == null) throw new Exception("Missing required parameter '`path`' when calling SlingApi->postNodeRw")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling SlingApi->postNodeRw")

    addMembers match {
      case Some(param) => queryParams += "addMembers" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postPath(`path`: String,
    jcrprimaryType: String,
    name: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/{path}/")
      replaceAll("\\{" + "path" + "\\}", `path`.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`path` == null) throw new Exception("Missing required parameter '`path`' when calling SlingApi->postPath")

    if (jcrprimaryType == null) throw new Exception("Missing required parameter 'jcrprimaryType' when calling SlingApi->postPath")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling SlingApi->postPath")

    queryParams += "jcr:primaryType" -> jcrprimaryType.toString
    queryParams += ":name" -> name.toString

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postQuery(`path`: String,
    pLimit: Number,
    `1property`: String,
    `1propertyValue`: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/bin/querybuilder.json"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`path` == null) throw new Exception("Missing required parameter '`path`' when calling SlingApi->postQuery")

    if (`1property` == null) throw new Exception("Missing required parameter '`1property`' when calling SlingApi->postQuery")

    if (`1propertyValue` == null) throw new Exception("Missing required parameter '`1propertyValue`' when calling SlingApi->postQuery")

    queryParams += "path" -> `path`.toString
    queryParams += "p.limit" -> pLimit.toString
    queryParams += "1_property" -> `1property`.toString
    queryParams += "1_property.value" -> `1propertyValue`.toString

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postTreeActivation(ignoredeactivated: Boolean,
    onlymodified: Boolean,
    `path`: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/etc/replication/treeactivation.html"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`path` == null) throw new Exception("Missing required parameter '`path`' when calling SlingApi->postTreeActivation")

    queryParams += "ignoredeactivated" -> ignoredeactivated.toString
    queryParams += "onlymodified" -> onlymodified.toString
    queryParams += "path" -> `path`.toString

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postTruststore(operation: Option[String] = None,
    newPassword: Option[String] = None,
    rePassword: Option[String] = None,
    keyStoreType: Option[String] = None,
    removeAlias: Option[String] = None,
    certificate: Option[File] = None
    )(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/libs/granite/security/post/truststore"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    operation match {
      case Some(param) => queryParams += ":operation" -> param.toString
      case _ => queryParams
    }
    newPassword match {
      case Some(param) => queryParams += "newPassword" -> param.toString
      case _ => queryParams
    }
    rePassword match {
      case Some(param) => queryParams += "rePassword" -> param.toString
      case _ => queryParams
    }
    keyStoreType match {
      case Some(param) => queryParams += "keyStoreType" -> param.toString
      case _ => queryParams
    }
    removeAlias match {
      case Some(param) => queryParams += "removeAlias" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postTruststorePKCS12(truststoreP12: Option[File] = None
    )(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/etc/truststore"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
