/**
* Adobe Experience Manager (AEM) API
* Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
*
* OpenAPI spec version: 3.2.0-pre.0
* Contact: opensource@shinesolutions.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package org.openapitools.client.apis

import org.openapitools.client.models.SamlConfigurationInfo

import org.openapitools.client.infrastructure.*

class ConsoleApi(basePath: kotlin.String = "http://localhost") : ApiClient(basePath) {

    /**
    * 
    * 
    * @return kotlin.Array<kotlin.String>
    */
    @Suppress("UNCHECKED_CAST")
    fun getAemProductInfo() : kotlin.Array<kotlin.String> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/system/console/status-productinfo.json",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<kotlin.String>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.String>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @return kotlin.String
    */
    @Suppress("UNCHECKED_CAST")
    fun getConfigMgr() : kotlin.String {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/system/console/configMgr",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.String>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param name  
    * @param action  
    * @return void
    */
    fun postBundle(name: kotlin.String, action: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("action" to listOf("$action"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/system/console/bundles/{name}".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param action  
    * @return void
    */
    fun postJmxRepository(action: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/system/console/jmx/com.adobe.granite:type&#x3D;Repository/op/{action}".replace("{"+"action"+"}", "$action"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param post  (optional)
    * @param apply  (optional)
    * @param delete  (optional)
    * @param action  (optional)
    * @param Dollarlocation  (optional)
    * @param path  (optional)
    * @param servicePeriodranking  (optional)
    * @param idpUrl  (optional)
    * @param idpCertAlias  (optional)
    * @param idpHttpRedirect  (optional)
    * @param serviceProviderEntityId  (optional)
    * @param assertionConsumerServiceURL  (optional)
    * @param spPrivateKeyAlias  (optional)
    * @param keyStorePassword  (optional)
    * @param defaultRedirectUrl  (optional)
    * @param userIDAttribute  (optional)
    * @param useEncryption  (optional)
    * @param createUser  (optional)
    * @param addGroupMemberships  (optional)
    * @param groupMembershipAttribute  (optional)
    * @param defaultGroups  (optional)
    * @param nameIdFormat  (optional)
    * @param synchronizeAttributes  (optional)
    * @param handleLogout  (optional)
    * @param logoutUrl  (optional)
    * @param clockTolerance  (optional)
    * @param digestMethod  (optional)
    * @param signatureMethod  (optional)
    * @param userIntermediatePath  (optional)
    * @param propertylist  (optional)
    * @return SamlConfigurationInfo
    */
    @Suppress("UNCHECKED_CAST")
    fun postSamlConfiguration(post: kotlin.Boolean, apply: kotlin.Boolean, delete: kotlin.Boolean, action: kotlin.String, Dollarlocation: kotlin.String, path: kotlin.Array<kotlin.String>, servicePeriodranking: kotlin.Int, idpUrl: kotlin.String, idpCertAlias: kotlin.String, idpHttpRedirect: kotlin.Boolean, serviceProviderEntityId: kotlin.String, assertionConsumerServiceURL: kotlin.String, spPrivateKeyAlias: kotlin.String, keyStorePassword: kotlin.String, defaultRedirectUrl: kotlin.String, userIDAttribute: kotlin.String, useEncryption: kotlin.Boolean, createUser: kotlin.Boolean, addGroupMemberships: kotlin.Boolean, groupMembershipAttribute: kotlin.String, defaultGroups: kotlin.Array<kotlin.String>, nameIdFormat: kotlin.String, synchronizeAttributes: kotlin.Array<kotlin.String>, handleLogout: kotlin.Boolean, logoutUrl: kotlin.String, clockTolerance: kotlin.Int, digestMethod: kotlin.String, signatureMethod: kotlin.String, userIntermediatePath: kotlin.String, propertylist: kotlin.Array<kotlin.String>) : SamlConfigurationInfo {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("post" to listOf("$post"), "apply" to listOf("$apply"), "delete" to listOf("$delete"), "action" to listOf("$action"), "$location" to listOf("$Dollarlocation"), "path" to toMultiValue(path.toList(), "multi"), "service.ranking" to listOf("$servicePeriodranking"), "idpUrl" to listOf("$idpUrl"), "idpCertAlias" to listOf("$idpCertAlias"), "idpHttpRedirect" to listOf("$idpHttpRedirect"), "serviceProviderEntityId" to listOf("$serviceProviderEntityId"), "assertionConsumerServiceURL" to listOf("$assertionConsumerServiceURL"), "spPrivateKeyAlias" to listOf("$spPrivateKeyAlias"), "keyStorePassword" to listOf("$keyStorePassword"), "defaultRedirectUrl" to listOf("$defaultRedirectUrl"), "userIDAttribute" to listOf("$userIDAttribute"), "useEncryption" to listOf("$useEncryption"), "createUser" to listOf("$createUser"), "addGroupMemberships" to listOf("$addGroupMemberships"), "groupMembershipAttribute" to listOf("$groupMembershipAttribute"), "defaultGroups" to toMultiValue(defaultGroups.toList(), "multi"), "nameIdFormat" to listOf("$nameIdFormat"), "synchronizeAttributes" to toMultiValue(synchronizeAttributes.toList(), "multi"), "handleLogout" to listOf("$handleLogout"), "logoutUrl" to listOf("$logoutUrl"), "clockTolerance" to listOf("$clockTolerance"), "digestMethod" to listOf("$digestMethod"), "signatureMethod" to listOf("$signatureMethod"), "userIntermediatePath" to listOf("$userIntermediatePath"), "propertylist" to toMultiValue(propertylist.toList(), "csv"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<SamlConfigurationInfo>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as SamlConfigurationInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
