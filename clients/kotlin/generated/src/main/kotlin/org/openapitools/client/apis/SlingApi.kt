/**
* Adobe Experience Manager (AEM) API
* Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
*
* OpenAPI spec version: 3.2.0-pre.0
* Contact: opensource@shinesolutions.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package org.openapitools.client.apis

import org.openapitools.client.models.KeystoreInfo
import org.openapitools.client.models.TruststoreInfo

import org.openapitools.client.infrastructure.*

class SlingApi(basePath: kotlin.String = "http://localhost") : ApiClient(basePath) {

    /**
    * 
    * 
    * @param runmode  
    * @param name  
    * @return void
    */
    fun deleteAgent(runmode: kotlin.String, name: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/etc/replication/agents.{runmode}/{name}".replace("{"+"runmode"+"}", "$runmode").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param path  
    * @param name  
    * @return void
    */
    fun deleteNode(path: kotlin.String, name: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/{path}/{name}".replace("{"+"path"+"}", "$path").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param runmode  
    * @param name  
    * @return void
    */
    fun getAgent(runmode: kotlin.String, name: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/etc/replication/agents.{runmode}/{name}".replace("{"+"runmode"+"}", "$runmode").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param runmode  
    * @return kotlin.String
    */
    @Suppress("UNCHECKED_CAST")
    fun getAgents(runmode: kotlin.String) : kotlin.String {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/etc/replication/agents.{runmode}.-1.json".replace("{"+"runmode"+"}", "$runmode"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.String>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param intermediatePath  
    * @param authorizableId  
    * @return KeystoreInfo
    */
    @Suppress("UNCHECKED_CAST")
    fun getAuthorizableKeystore(intermediatePath: kotlin.String, authorizableId: kotlin.String) : KeystoreInfo {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/{intermediatePath}/{authorizableId}.ks.json".replace("{"+"intermediatePath"+"}", "$intermediatePath").replace("{"+"authorizableId"+"}", "$authorizableId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<KeystoreInfo>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as KeystoreInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param intermediatePath  
    * @param authorizableId  
    * @return java.io.File
    */
    @Suppress("UNCHECKED_CAST")
    fun getKeystore(intermediatePath: kotlin.String, authorizableId: kotlin.String) : java.io.File {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/{intermediatePath}/{authorizableId}/keystore/store.p12".replace("{"+"intermediatePath"+"}", "$intermediatePath").replace("{"+"authorizableId"+"}", "$authorizableId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<java.io.File>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as java.io.File
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param path  
    * @param name  
    * @return void
    */
    fun getNode(path: kotlin.String, name: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/{path}/{name}".replace("{"+"path"+"}", "$path").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param group  
    * @param name  
    * @param version  
    * @return java.io.File
    */
    @Suppress("UNCHECKED_CAST")
    fun getPackage(group: kotlin.String, name: kotlin.String, version: kotlin.String) : java.io.File {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/etc/packages/{group}/{name}-{version}.zip".replace("{"+"group"+"}", "$group").replace("{"+"name"+"}", "$name").replace("{"+"version"+"}", "$version"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<java.io.File>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as java.io.File
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param group  
    * @param name  
    * @param version  
    * @return kotlin.String
    */
    @Suppress("UNCHECKED_CAST")
    fun getPackageFilter(group: kotlin.String, name: kotlin.String, version: kotlin.String) : kotlin.String {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json".replace("{"+"group"+"}", "$group").replace("{"+"name"+"}", "$name").replace("{"+"version"+"}", "$version"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.String>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param path  
    * @param pPeriodlimit  
    * @param 1Property  
    * @param 1PropertyPeriodvalue  
    * @return kotlin.String
    */
    @Suppress("UNCHECKED_CAST")
    fun getQuery(path: kotlin.String, pPeriodlimit: java.math.BigDecimal, 1Property: kotlin.String, 1PropertyPeriodvalue: kotlin.String) : kotlin.String {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("path" to listOf("$path"), "p.limit" to listOf("$pPeriodlimit"), "1_property" to listOf("$1Property"), "1_property.value" to listOf("$1PropertyPeriodvalue"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/bin/querybuilder.json",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.String>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @return java.io.File
    */
    @Suppress("UNCHECKED_CAST")
    fun getTruststore() : java.io.File {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/etc/truststore/truststore.p12",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<java.io.File>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as java.io.File
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @return TruststoreInfo
    */
    @Suppress("UNCHECKED_CAST")
    fun getTruststoreInfo() : TruststoreInfo {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/libs/granite/security/truststore.json",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<TruststoreInfo>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TruststoreInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param runmode  
    * @param name  
    * @param jcrContentSlashcqDistribute  (optional)
    * @param jcrContentSlashcqDistributeAtTypeHint  (optional)
    * @param jcrContentSlashcqName  (optional)
    * @param jcrContentSlashcqTemplate  (optional)
    * @param jcrContentSlashenabled  (optional)
    * @param jcrContentSlashjcrDescription  (optional)
    * @param jcrContentSlashjcrLastModified  (optional)
    * @param jcrContentSlashjcrLastModifiedBy  (optional)
    * @param jcrContentSlashjcrMixinTypes  (optional)
    * @param jcrContentSlashjcrTitle  (optional)
    * @param jcrContentSlashlogLevel  (optional)
    * @param jcrContentSlashnoStatusUpdate  (optional)
    * @param jcrContentSlashnoVersioning  (optional)
    * @param jcrContentSlashprotocolConnectTimeout  (optional)
    * @param jcrContentSlashprotocolHTTPConnectionClosed  (optional)
    * @param jcrContentSlashprotocolHTTPExpired  (optional)
    * @param jcrContentSlashprotocolHTTPHeaders  (optional)
    * @param jcrContentSlashprotocolHTTPHeadersAtTypeHint  (optional)
    * @param jcrContentSlashprotocolHTTPMethod  (optional)
    * @param jcrContentSlashprotocolHTTPSRelaxed  (optional)
    * @param jcrContentSlashprotocolInterface  (optional)
    * @param jcrContentSlashprotocolSocketTimeout  (optional)
    * @param jcrContentSlashprotocolVersion  (optional)
    * @param jcrContentSlashproxyNTLMDomain  (optional)
    * @param jcrContentSlashproxyNTLMHost  (optional)
    * @param jcrContentSlashproxyHost  (optional)
    * @param jcrContentSlashproxyPassword  (optional)
    * @param jcrContentSlashproxyPort  (optional)
    * @param jcrContentSlashproxyUser  (optional)
    * @param jcrContentSlashqueueBatchMaxSize  (optional)
    * @param jcrContentSlashqueueBatchMode  (optional)
    * @param jcrContentSlashqueueBatchWaitTime  (optional)
    * @param jcrContentSlashretryDelay  (optional)
    * @param jcrContentSlashreverseReplication  (optional)
    * @param jcrContentSlashserializationType  (optional)
    * @param jcrContentSlashslingResourceType  (optional)
    * @param jcrContentSlashssl  (optional)
    * @param jcrContentSlashtransportNTLMDomain  (optional)
    * @param jcrContentSlashtransportNTLMHost  (optional)
    * @param jcrContentSlashtransportPassword  (optional)
    * @param jcrContentSlashtransportUri  (optional)
    * @param jcrContentSlashtransportUser  (optional)
    * @param jcrContentSlashtriggerDistribute  (optional)
    * @param jcrContentSlashtriggerModified  (optional)
    * @param jcrContentSlashtriggerOnOffTime  (optional)
    * @param jcrContentSlashtriggerReceive  (optional)
    * @param jcrContentSlashtriggerSpecific  (optional)
    * @param jcrContentSlashuserId  (optional)
    * @param jcrPrimaryType  (optional)
    * @param operation  (optional)
    * @return void
    */
    fun postAgent(runmode: kotlin.String, name: kotlin.String, jcrContentSlashcqDistribute: kotlin.Boolean, jcrContentSlashcqDistributeAtTypeHint: kotlin.String, jcrContentSlashcqName: kotlin.String, jcrContentSlashcqTemplate: kotlin.String, jcrContentSlashenabled: kotlin.Boolean, jcrContentSlashjcrDescription: kotlin.String, jcrContentSlashjcrLastModified: kotlin.String, jcrContentSlashjcrLastModifiedBy: kotlin.String, jcrContentSlashjcrMixinTypes: kotlin.String, jcrContentSlashjcrTitle: kotlin.String, jcrContentSlashlogLevel: kotlin.String, jcrContentSlashnoStatusUpdate: kotlin.Boolean, jcrContentSlashnoVersioning: kotlin.Boolean, jcrContentSlashprotocolConnectTimeout: java.math.BigDecimal, jcrContentSlashprotocolHTTPConnectionClosed: kotlin.Boolean, jcrContentSlashprotocolHTTPExpired: kotlin.String, jcrContentSlashprotocolHTTPHeaders: kotlin.Array<kotlin.String>, jcrContentSlashprotocolHTTPHeadersAtTypeHint: kotlin.String, jcrContentSlashprotocolHTTPMethod: kotlin.String, jcrContentSlashprotocolHTTPSRelaxed: kotlin.Boolean, jcrContentSlashprotocolInterface: kotlin.String, jcrContentSlashprotocolSocketTimeout: java.math.BigDecimal, jcrContentSlashprotocolVersion: kotlin.String, jcrContentSlashproxyNTLMDomain: kotlin.String, jcrContentSlashproxyNTLMHost: kotlin.String, jcrContentSlashproxyHost: kotlin.String, jcrContentSlashproxyPassword: kotlin.String, jcrContentSlashproxyPort: java.math.BigDecimal, jcrContentSlashproxyUser: kotlin.String, jcrContentSlashqueueBatchMaxSize: java.math.BigDecimal, jcrContentSlashqueueBatchMode: kotlin.String, jcrContentSlashqueueBatchWaitTime: java.math.BigDecimal, jcrContentSlashretryDelay: kotlin.String, jcrContentSlashreverseReplication: kotlin.Boolean, jcrContentSlashserializationType: kotlin.String, jcrContentSlashslingResourceType: kotlin.String, jcrContentSlashssl: kotlin.String, jcrContentSlashtransportNTLMDomain: kotlin.String, jcrContentSlashtransportNTLMHost: kotlin.String, jcrContentSlashtransportPassword: kotlin.String, jcrContentSlashtransportUri: kotlin.String, jcrContentSlashtransportUser: kotlin.String, jcrContentSlashtriggerDistribute: kotlin.Boolean, jcrContentSlashtriggerModified: kotlin.Boolean, jcrContentSlashtriggerOnOffTime: kotlin.Boolean, jcrContentSlashtriggerReceive: kotlin.Boolean, jcrContentSlashtriggerSpecific: kotlin.Boolean, jcrContentSlashuserId: kotlin.String, jcrPrimaryType: kotlin.String, operation: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("jcr:content/cq:distribute" to listOf("$jcrContentSlashcqDistribute"), "jcr:content/cq:distribute@TypeHint" to listOf("$jcrContentSlashcqDistributeAtTypeHint"), "jcr:content/cq:name" to listOf("$jcrContentSlashcqName"), "jcr:content/cq:template" to listOf("$jcrContentSlashcqTemplate"), "jcr:content/enabled" to listOf("$jcrContentSlashenabled"), "jcr:content/jcr:description" to listOf("$jcrContentSlashjcrDescription"), "jcr:content/jcr:lastModified" to listOf("$jcrContentSlashjcrLastModified"), "jcr:content/jcr:lastModifiedBy" to listOf("$jcrContentSlashjcrLastModifiedBy"), "jcr:content/jcr:mixinTypes" to listOf("$jcrContentSlashjcrMixinTypes"), "jcr:content/jcr:title" to listOf("$jcrContentSlashjcrTitle"), "jcr:content/logLevel" to listOf("$jcrContentSlashlogLevel"), "jcr:content/noStatusUpdate" to listOf("$jcrContentSlashnoStatusUpdate"), "jcr:content/noVersioning" to listOf("$jcrContentSlashnoVersioning"), "jcr:content/protocolConnectTimeout" to listOf("$jcrContentSlashprotocolConnectTimeout"), "jcr:content/protocolHTTPConnectionClosed" to listOf("$jcrContentSlashprotocolHTTPConnectionClosed"), "jcr:content/protocolHTTPExpired" to listOf("$jcrContentSlashprotocolHTTPExpired"), "jcr:content/protocolHTTPHeaders" to toMultiValue(jcrContentSlashprotocolHTTPHeaders.toList(), "multi"), "jcr:content/protocolHTTPHeaders@TypeHint" to listOf("$jcrContentSlashprotocolHTTPHeadersAtTypeHint"), "jcr:content/protocolHTTPMethod" to listOf("$jcrContentSlashprotocolHTTPMethod"), "jcr:content/protocolHTTPSRelaxed" to listOf("$jcrContentSlashprotocolHTTPSRelaxed"), "jcr:content/protocolInterface" to listOf("$jcrContentSlashprotocolInterface"), "jcr:content/protocolSocketTimeout" to listOf("$jcrContentSlashprotocolSocketTimeout"), "jcr:content/protocolVersion" to listOf("$jcrContentSlashprotocolVersion"), "jcr:content/proxyNTLMDomain" to listOf("$jcrContentSlashproxyNTLMDomain"), "jcr:content/proxyNTLMHost" to listOf("$jcrContentSlashproxyNTLMHost"), "jcr:content/proxyHost" to listOf("$jcrContentSlashproxyHost"), "jcr:content/proxyPassword" to listOf("$jcrContentSlashproxyPassword"), "jcr:content/proxyPort" to listOf("$jcrContentSlashproxyPort"), "jcr:content/proxyUser" to listOf("$jcrContentSlashproxyUser"), "jcr:content/queueBatchMaxSize" to listOf("$jcrContentSlashqueueBatchMaxSize"), "jcr:content/queueBatchMode" to listOf("$jcrContentSlashqueueBatchMode"), "jcr:content/queueBatchWaitTime" to listOf("$jcrContentSlashqueueBatchWaitTime"), "jcr:content/retryDelay" to listOf("$jcrContentSlashretryDelay"), "jcr:content/reverseReplication" to listOf("$jcrContentSlashreverseReplication"), "jcr:content/serializationType" to listOf("$jcrContentSlashserializationType"), "jcr:content/sling:resourceType" to listOf("$jcrContentSlashslingResourceType"), "jcr:content/ssl" to listOf("$jcrContentSlashssl"), "jcr:content/transportNTLMDomain" to listOf("$jcrContentSlashtransportNTLMDomain"), "jcr:content/transportNTLMHost" to listOf("$jcrContentSlashtransportNTLMHost"), "jcr:content/transportPassword" to listOf("$jcrContentSlashtransportPassword"), "jcr:content/transportUri" to listOf("$jcrContentSlashtransportUri"), "jcr:content/transportUser" to listOf("$jcrContentSlashtransportUser"), "jcr:content/triggerDistribute" to listOf("$jcrContentSlashtriggerDistribute"), "jcr:content/triggerModified" to listOf("$jcrContentSlashtriggerModified"), "jcr:content/triggerOnOffTime" to listOf("$jcrContentSlashtriggerOnOffTime"), "jcr:content/triggerReceive" to listOf("$jcrContentSlashtriggerReceive"), "jcr:content/triggerSpecific" to listOf("$jcrContentSlashtriggerSpecific"), "jcr:content/userId" to listOf("$jcrContentSlashuserId"), "jcr:primaryType" to listOf("$jcrPrimaryType"), ":operation" to listOf("$operation"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/etc/replication/agents.{runmode}/{name}".replace("{"+"runmode"+"}", "$runmode").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param intermediatePath  
    * @param authorizableId  
    * @param operation  (optional)
    * @param currentPassword  (optional)
    * @param newPassword  (optional)
    * @param rePassword  (optional)
    * @param keyPassword  (optional)
    * @param keyStorePass  (optional)
    * @param alias  (optional)
    * @param newAlias  (optional)
    * @param removeAlias  (optional)
    * @param certChain  (optional, default to null)
    * @param pk  (optional, default to null)
    * @param keyStore  (optional, default to null)
    * @return KeystoreInfo
    */
    @Suppress("UNCHECKED_CAST")
    fun postAuthorizableKeystore(intermediatePath: kotlin.String, authorizableId: kotlin.String, operation: kotlin.String, currentPassword: kotlin.String, newPassword: kotlin.String, rePassword: kotlin.String, keyPassword: kotlin.String, keyStorePass: kotlin.String, alias: kotlin.String, newAlias: kotlin.String, removeAlias: kotlin.String, certChain: java.io.File, pk: java.io.File, keyStore: java.io.File) : KeystoreInfo {
        val localVariableBody: kotlin.Any? = mapOf("cert-chain" to "$certChain", "pk" to "$pk", "keyStore" to "$keyStore")
        val localVariableQuery: MultiValueMap = mapOf(":operation" to listOf("$operation"), "currentPassword" to listOf("$currentPassword"), "newPassword" to listOf("$newPassword"), "rePassword" to listOf("$rePassword"), "keyPassword" to listOf("$keyPassword"), "keyStorePass" to listOf("$keyStorePass"), "alias" to listOf("$alias"), "newAlias" to listOf("$newAlias"), "removeAlias" to listOf("$removeAlias"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/{intermediatePath}/{authorizableId}.ks.html".replace("{"+"intermediatePath"+"}", "$intermediatePath").replace("{"+"authorizableId"+"}", "$authorizableId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<KeystoreInfo>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as KeystoreInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param authorizableId  
    * @param intermediatePath  
    * @param createUser  (optional)
    * @param createGroup  (optional)
    * @param repPassword  (optional)
    * @param profileSlashgivenName  (optional)
    * @return kotlin.String
    */
    @Suppress("UNCHECKED_CAST")
    fun postAuthorizables(authorizableId: kotlin.String, intermediatePath: kotlin.String, createUser: kotlin.String, createGroup: kotlin.String, repPassword: kotlin.String, profileSlashgivenName: kotlin.String) : kotlin.String {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("authorizableId" to listOf("$authorizableId"), "intermediatePath" to listOf("$intermediatePath"), "createUser" to listOf("$createUser"), "createGroup" to listOf("$createGroup"), "rep:password" to listOf("$repPassword"), "profile/givenName" to listOf("$profileSlashgivenName"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/libs/granite/security/post/authorizables",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.String>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param keyStorePassword  (optional)
    * @param keyStorePasswordAtTypeHint  (optional)
    * @param servicePeriodranking  (optional)
    * @param servicePeriodrankingAtTypeHint  (optional)
    * @param idpHttpRedirect  (optional)
    * @param idpHttpRedirectAtTypeHint  (optional)
    * @param createUser  (optional)
    * @param createUserAtTypeHint  (optional)
    * @param defaultRedirectUrl  (optional)
    * @param defaultRedirectUrlAtTypeHint  (optional)
    * @param userIDAttribute  (optional)
    * @param userIDAttributeAtTypeHint  (optional)
    * @param defaultGroups  (optional)
    * @param defaultGroupsAtTypeHint  (optional)
    * @param idpCertAlias  (optional)
    * @param idpCertAliasAtTypeHint  (optional)
    * @param addGroupMemberships  (optional)
    * @param addGroupMembershipsAtTypeHint  (optional)
    * @param path  (optional)
    * @param pathAtTypeHint  (optional)
    * @param synchronizeAttributes  (optional)
    * @param synchronizeAttributesAtTypeHint  (optional)
    * @param clockTolerance  (optional)
    * @param clockToleranceAtTypeHint  (optional)
    * @param groupMembershipAttribute  (optional)
    * @param groupMembershipAttributeAtTypeHint  (optional)
    * @param idpUrl  (optional)
    * @param idpUrlAtTypeHint  (optional)
    * @param logoutUrl  (optional)
    * @param logoutUrlAtTypeHint  (optional)
    * @param serviceProviderEntityId  (optional)
    * @param serviceProviderEntityIdAtTypeHint  (optional)
    * @param assertionConsumerServiceURL  (optional)
    * @param assertionConsumerServiceURLAtTypeHint  (optional)
    * @param handleLogout  (optional)
    * @param handleLogoutAtTypeHint  (optional)
    * @param spPrivateKeyAlias  (optional)
    * @param spPrivateKeyAliasAtTypeHint  (optional)
    * @param useEncryption  (optional)
    * @param useEncryptionAtTypeHint  (optional)
    * @param nameIdFormat  (optional)
    * @param nameIdFormatAtTypeHint  (optional)
    * @param digestMethod  (optional)
    * @param digestMethodAtTypeHint  (optional)
    * @param signatureMethod  (optional)
    * @param signatureMethodAtTypeHint  (optional)
    * @param userIntermediatePath  (optional)
    * @param userIntermediatePathAtTypeHint  (optional)
    * @return void
    */
    fun postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword: kotlin.String, keyStorePasswordAtTypeHint: kotlin.String, servicePeriodranking: kotlin.Int, servicePeriodrankingAtTypeHint: kotlin.String, idpHttpRedirect: kotlin.Boolean, idpHttpRedirectAtTypeHint: kotlin.String, createUser: kotlin.Boolean, createUserAtTypeHint: kotlin.String, defaultRedirectUrl: kotlin.String, defaultRedirectUrlAtTypeHint: kotlin.String, userIDAttribute: kotlin.String, userIDAttributeAtTypeHint: kotlin.String, defaultGroups: kotlin.Array<kotlin.String>, defaultGroupsAtTypeHint: kotlin.String, idpCertAlias: kotlin.String, idpCertAliasAtTypeHint: kotlin.String, addGroupMemberships: kotlin.Boolean, addGroupMembershipsAtTypeHint: kotlin.String, path: kotlin.Array<kotlin.String>, pathAtTypeHint: kotlin.String, synchronizeAttributes: kotlin.Array<kotlin.String>, synchronizeAttributesAtTypeHint: kotlin.String, clockTolerance: kotlin.Int, clockToleranceAtTypeHint: kotlin.String, groupMembershipAttribute: kotlin.String, groupMembershipAttributeAtTypeHint: kotlin.String, idpUrl: kotlin.String, idpUrlAtTypeHint: kotlin.String, logoutUrl: kotlin.String, logoutUrlAtTypeHint: kotlin.String, serviceProviderEntityId: kotlin.String, serviceProviderEntityIdAtTypeHint: kotlin.String, assertionConsumerServiceURL: kotlin.String, assertionConsumerServiceURLAtTypeHint: kotlin.String, handleLogout: kotlin.Boolean, handleLogoutAtTypeHint: kotlin.String, spPrivateKeyAlias: kotlin.String, spPrivateKeyAliasAtTypeHint: kotlin.String, useEncryption: kotlin.Boolean, useEncryptionAtTypeHint: kotlin.String, nameIdFormat: kotlin.String, nameIdFormatAtTypeHint: kotlin.String, digestMethod: kotlin.String, digestMethodAtTypeHint: kotlin.String, signatureMethod: kotlin.String, signatureMethodAtTypeHint: kotlin.String, userIntermediatePath: kotlin.String, userIntermediatePathAtTypeHint: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("keyStorePassword" to listOf("$keyStorePassword"), "keyStorePassword@TypeHint" to listOf("$keyStorePasswordAtTypeHint"), "service.ranking" to listOf("$servicePeriodranking"), "service.ranking@TypeHint" to listOf("$servicePeriodrankingAtTypeHint"), "idpHttpRedirect" to listOf("$idpHttpRedirect"), "idpHttpRedirect@TypeHint" to listOf("$idpHttpRedirectAtTypeHint"), "createUser" to listOf("$createUser"), "createUser@TypeHint" to listOf("$createUserAtTypeHint"), "defaultRedirectUrl" to listOf("$defaultRedirectUrl"), "defaultRedirectUrl@TypeHint" to listOf("$defaultRedirectUrlAtTypeHint"), "userIDAttribute" to listOf("$userIDAttribute"), "userIDAttribute@TypeHint" to listOf("$userIDAttributeAtTypeHint"), "defaultGroups" to toMultiValue(defaultGroups.toList(), "multi"), "defaultGroups@TypeHint" to listOf("$defaultGroupsAtTypeHint"), "idpCertAlias" to listOf("$idpCertAlias"), "idpCertAlias@TypeHint" to listOf("$idpCertAliasAtTypeHint"), "addGroupMemberships" to listOf("$addGroupMemberships"), "addGroupMemberships@TypeHint" to listOf("$addGroupMembershipsAtTypeHint"), "path" to toMultiValue(path.toList(), "multi"), "path@TypeHint" to listOf("$pathAtTypeHint"), "synchronizeAttributes" to toMultiValue(synchronizeAttributes.toList(), "multi"), "synchronizeAttributes@TypeHint" to listOf("$synchronizeAttributesAtTypeHint"), "clockTolerance" to listOf("$clockTolerance"), "clockTolerance@TypeHint" to listOf("$clockToleranceAtTypeHint"), "groupMembershipAttribute" to listOf("$groupMembershipAttribute"), "groupMembershipAttribute@TypeHint" to listOf("$groupMembershipAttributeAtTypeHint"), "idpUrl" to listOf("$idpUrl"), "idpUrl@TypeHint" to listOf("$idpUrlAtTypeHint"), "logoutUrl" to listOf("$logoutUrl"), "logoutUrl@TypeHint" to listOf("$logoutUrlAtTypeHint"), "serviceProviderEntityId" to listOf("$serviceProviderEntityId"), "serviceProviderEntityId@TypeHint" to listOf("$serviceProviderEntityIdAtTypeHint"), "assertionConsumerServiceURL" to listOf("$assertionConsumerServiceURL"), "assertionConsumerServiceURL@TypeHint" to listOf("$assertionConsumerServiceURLAtTypeHint"), "handleLogout" to listOf("$handleLogout"), "handleLogout@TypeHint" to listOf("$handleLogoutAtTypeHint"), "spPrivateKeyAlias" to listOf("$spPrivateKeyAlias"), "spPrivateKeyAlias@TypeHint" to listOf("$spPrivateKeyAliasAtTypeHint"), "useEncryption" to listOf("$useEncryption"), "useEncryption@TypeHint" to listOf("$useEncryptionAtTypeHint"), "nameIdFormat" to listOf("$nameIdFormat"), "nameIdFormat@TypeHint" to listOf("$nameIdFormatAtTypeHint"), "digestMethod" to listOf("$digestMethod"), "digestMethod@TypeHint" to listOf("$digestMethodAtTypeHint"), "signatureMethod" to listOf("$signatureMethod"), "signatureMethod@TypeHint" to listOf("$signatureMethodAtTypeHint"), "userIntermediatePath" to listOf("$userIntermediatePath"), "userIntermediatePath@TypeHint" to listOf("$userIntermediatePathAtTypeHint"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodnio  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodnioAtTypeHint  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystore  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreAtTypeHint  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpassword  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordAtTypeHint  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkey  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyAtTypeHint  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpassword  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordAtTypeHint  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststore  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreAtTypeHint  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpassword  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordAtTypeHint  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificate  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateAtTypeHint  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodenable  (optional)
    * @param orgPeriodapachePeriodfelixPeriodhttpsPeriodenableAtTypeHint  (optional)
    * @param orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecure  (optional)
    * @param orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureAtTypeHint  (optional)
    * @return void
    */
    fun postConfigApacheFelixJettyBasedHttpService(orgPeriodapachePeriodfelixPeriodhttpsPeriodnio: kotlin.Boolean, orgPeriodapachePeriodfelixPeriodhttpsPeriodnioAtTypeHint: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystore: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreAtTypeHint: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpassword: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordAtTypeHint: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkey: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyAtTypeHint: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpassword: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordAtTypeHint: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststore: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreAtTypeHint: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpassword: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordAtTypeHint: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificate: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateAtTypeHint: kotlin.String, orgPeriodapachePeriodfelixPeriodhttpsPeriodenable: kotlin.Boolean, orgPeriodapachePeriodfelixPeriodhttpsPeriodenableAtTypeHint: kotlin.String, orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecure: kotlin.String, orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureAtTypeHint: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("org.apache.felix.https.nio" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodnio"), "org.apache.felix.https.nio@TypeHint" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodnioAtTypeHint"), "org.apache.felix.https.keystore" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystore"), "org.apache.felix.https.keystore@TypeHint" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreAtTypeHint"), "org.apache.felix.https.keystore.password" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpassword"), "org.apache.felix.https.keystore.password@TypeHint" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordAtTypeHint"), "org.apache.felix.https.keystore.key" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkey"), "org.apache.felix.https.keystore.key@TypeHint" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyAtTypeHint"), "org.apache.felix.https.keystore.key.password" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpassword"), "org.apache.felix.https.keystore.key.password@TypeHint" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordAtTypeHint"), "org.apache.felix.https.truststore" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststore"), "org.apache.felix.https.truststore@TypeHint" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreAtTypeHint"), "org.apache.felix.https.truststore.password" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpassword"), "org.apache.felix.https.truststore.password@TypeHint" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordAtTypeHint"), "org.apache.felix.https.clientcertificate" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificate"), "org.apache.felix.https.clientcertificate@TypeHint" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateAtTypeHint"), "org.apache.felix.https.enable" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodenable"), "org.apache.felix.https.enable@TypeHint" to listOf("$orgPeriodapachePeriodfelixPeriodhttpsPeriodenableAtTypeHint"), "org.osgi.service.http.port.secure" to listOf("$orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecure"), "org.osgi.service.http.port.secure@TypeHint" to listOf("$orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureAtTypeHint"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/apps/system/config/org.apache.felix.http",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param proxyPeriodhost  (optional)
    * @param proxyPeriodhostAtTypeHint  (optional)
    * @param proxyPeriodport  (optional)
    * @param proxyPeriodportAtTypeHint  (optional)
    * @param proxyPeriodexceptions  (optional)
    * @param proxyPeriodexceptionsAtTypeHint  (optional)
    * @param proxyPeriodenabled  (optional)
    * @param proxyPeriodenabledAtTypeHint  (optional)
    * @param proxyPerioduser  (optional)
    * @param proxyPerioduserAtTypeHint  (optional)
    * @param proxyPeriodpassword  (optional)
    * @param proxyPeriodpasswordAtTypeHint  (optional)
    * @return void
    */
    fun postConfigApacheHttpComponentsProxyConfiguration(proxyPeriodhost: kotlin.String, proxyPeriodhostAtTypeHint: kotlin.String, proxyPeriodport: kotlin.Int, proxyPeriodportAtTypeHint: kotlin.String, proxyPeriodexceptions: kotlin.Array<kotlin.String>, proxyPeriodexceptionsAtTypeHint: kotlin.String, proxyPeriodenabled: kotlin.Boolean, proxyPeriodenabledAtTypeHint: kotlin.String, proxyPerioduser: kotlin.String, proxyPerioduserAtTypeHint: kotlin.String, proxyPeriodpassword: kotlin.String, proxyPeriodpasswordAtTypeHint: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("proxy.host" to listOf("$proxyPeriodhost"), "proxy.host@TypeHint" to listOf("$proxyPeriodhostAtTypeHint"), "proxy.port" to listOf("$proxyPeriodport"), "proxy.port@TypeHint" to listOf("$proxyPeriodportAtTypeHint"), "proxy.exceptions" to toMultiValue(proxyPeriodexceptions.toList(), "multi"), "proxy.exceptions@TypeHint" to listOf("$proxyPeriodexceptionsAtTypeHint"), "proxy.enabled" to listOf("$proxyPeriodenabled"), "proxy.enabled@TypeHint" to listOf("$proxyPeriodenabledAtTypeHint"), "proxy.user" to listOf("$proxyPerioduser"), "proxy.user@TypeHint" to listOf("$proxyPerioduserAtTypeHint"), "proxy.password" to listOf("$proxyPeriodpassword"), "proxy.password@TypeHint" to listOf("$proxyPeriodpasswordAtTypeHint"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/apps/system/config/org.apache.http.proxyconfigurator.config",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param alias  (optional)
    * @param aliasAtTypeHint  (optional)
    * @param davPeriodcreateAbsoluteUri  (optional)
    * @param davPeriodcreateAbsoluteUriAtTypeHint  (optional)
    * @return void
    */
    fun postConfigApacheSlingDavExServlet(alias: kotlin.String, aliasAtTypeHint: kotlin.String, davPeriodcreateAbsoluteUri: kotlin.Boolean, davPeriodcreateAbsoluteUriAtTypeHint: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("alias" to listOf("$alias"), "alias@TypeHint" to listOf("$aliasAtTypeHint"), "dav.create-absolute-uri" to listOf("$davPeriodcreateAbsoluteUri"), "dav.create-absolute-uri@TypeHint" to listOf("$davPeriodcreateAbsoluteUriAtTypeHint"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param jsonPeriodmaximumresults  (optional)
    * @param jsonPeriodmaximumresultsAtTypeHint  (optional)
    * @param enablePeriodhtml  (optional)
    * @param enablePeriodhtmlAtTypeHint  (optional)
    * @param enablePeriodtxt  (optional)
    * @param enablePeriodtxtAtTypeHint  (optional)
    * @param enablePeriodxml  (optional)
    * @param enablePeriodxmlAtTypeHint  (optional)
    * @return void
    */
    fun postConfigApacheSlingGetServlet(jsonPeriodmaximumresults: kotlin.String, jsonPeriodmaximumresultsAtTypeHint: kotlin.String, enablePeriodhtml: kotlin.Boolean, enablePeriodhtmlAtTypeHint: kotlin.String, enablePeriodtxt: kotlin.Boolean, enablePeriodtxtAtTypeHint: kotlin.String, enablePeriodxml: kotlin.Boolean, enablePeriodxmlAtTypeHint: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("json.maximumresults" to listOf("$jsonPeriodmaximumresults"), "json.maximumresults@TypeHint" to listOf("$jsonPeriodmaximumresultsAtTypeHint"), "enable.html" to listOf("$enablePeriodhtml"), "enable.html@TypeHint" to listOf("$enablePeriodhtmlAtTypeHint"), "enable.txt" to listOf("$enablePeriodtxt"), "enable.txt@TypeHint" to listOf("$enablePeriodtxtAtTypeHint"), "enable.xml" to listOf("$enablePeriodxml"), "enable.xml@TypeHint" to listOf("$enablePeriodxmlAtTypeHint"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param allowPeriodempty  (optional)
    * @param allowPeriodemptyAtTypeHint  (optional)
    * @param allowPeriodhosts  (optional)
    * @param allowPeriodhostsAtTypeHint  (optional)
    * @param allowPeriodhostsPeriodregexp  (optional)
    * @param allowPeriodhostsPeriodregexpAtTypeHint  (optional)
    * @param filterPeriodmethods  (optional)
    * @param filterPeriodmethodsAtTypeHint  (optional)
    * @return void
    */
    fun postConfigApacheSlingReferrerFilter(allowPeriodempty: kotlin.Boolean, allowPeriodemptyAtTypeHint: kotlin.String, allowPeriodhosts: kotlin.String, allowPeriodhostsAtTypeHint: kotlin.String, allowPeriodhostsPeriodregexp: kotlin.String, allowPeriodhostsPeriodregexpAtTypeHint: kotlin.String, filterPeriodmethods: kotlin.String, filterPeriodmethodsAtTypeHint: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("allow.empty" to listOf("$allowPeriodempty"), "allow.empty@TypeHint" to listOf("$allowPeriodemptyAtTypeHint"), "allow.hosts" to listOf("$allowPeriodhosts"), "allow.hosts@TypeHint" to listOf("$allowPeriodhostsAtTypeHint"), "allow.hosts.regexp" to listOf("$allowPeriodhostsPeriodregexp"), "allow.hosts.regexp@TypeHint" to listOf("$allowPeriodhostsPeriodregexpAtTypeHint"), "filter.methods" to listOf("$filterPeriodmethods"), "filter.methods@TypeHint" to listOf("$filterPeriodmethodsAtTypeHint"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/apps/system/config/org.apache.sling.security.impl.ReferrerFilter",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param path  
    * @param name  
    * @param operation  (optional)
    * @param deleteAuthorizable  (optional)
    * @param file  (optional, default to null)
    * @return void
    */
    fun postNode(path: kotlin.String, name: kotlin.String, operation: kotlin.String, deleteAuthorizable: kotlin.String, file: java.io.File) : Unit {
        val localVariableBody: kotlin.Any? = mapOf("file" to "$file")
        val localVariableQuery: MultiValueMap = mapOf(":operation" to listOf("$operation"), "deleteAuthorizable" to listOf("$deleteAuthorizable"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/{path}/{name}".replace("{"+"path"+"}", "$path").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param path  
    * @param name  
    * @param addMembers  (optional)
    * @return void
    */
    fun postNodeRw(path: kotlin.String, name: kotlin.String, addMembers: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("addMembers" to listOf("$addMembers"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/{path}/{name}.rw.html".replace("{"+"path"+"}", "$path").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param path  
    * @param jcrPrimaryType  
    * @param name  
    * @return void
    */
    fun postPath(path: kotlin.String, jcrPrimaryType: kotlin.String, name: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("jcr:primaryType" to listOf("$jcrPrimaryType"), ":name" to listOf("$name"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/{path}/".replace("{"+"path"+"}", "$path"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param path  
    * @param pPeriodlimit  
    * @param 1Property  
    * @param 1PropertyPeriodvalue  
    * @return kotlin.String
    */
    @Suppress("UNCHECKED_CAST")
    fun postQuery(path: kotlin.String, pPeriodlimit: java.math.BigDecimal, 1Property: kotlin.String, 1PropertyPeriodvalue: kotlin.String) : kotlin.String {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("path" to listOf("$path"), "p.limit" to listOf("$pPeriodlimit"), "1_property" to listOf("$1Property"), "1_property.value" to listOf("$1PropertyPeriodvalue"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/bin/querybuilder.json",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.String>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param ignoredeactivated  
    * @param onlymodified  
    * @param path  
    * @return void
    */
    fun postTreeActivation(ignoredeactivated: kotlin.Boolean, onlymodified: kotlin.Boolean, path: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("ignoredeactivated" to listOf("$ignoredeactivated"), "onlymodified" to listOf("$onlymodified"), "path" to listOf("$path"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/etc/replication/treeactivation.html",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param operation  (optional)
    * @param newPassword  (optional)
    * @param rePassword  (optional)
    * @param keyStoreType  (optional)
    * @param removeAlias  (optional)
    * @param certificate  (optional, default to null)
    * @return kotlin.String
    */
    @Suppress("UNCHECKED_CAST")
    fun postTruststore(operation: kotlin.String, newPassword: kotlin.String, rePassword: kotlin.String, keyStoreType: kotlin.String, removeAlias: kotlin.String, certificate: java.io.File) : kotlin.String {
        val localVariableBody: kotlin.Any? = mapOf("certificate" to "$certificate")
        val localVariableQuery: MultiValueMap = mapOf(":operation" to listOf("$operation"), "newPassword" to listOf("$newPassword"), "rePassword" to listOf("$rePassword"), "keyStoreType" to listOf("$keyStoreType"), "removeAlias" to listOf("$removeAlias"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/libs/granite/security/post/truststore",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.String>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param truststorePeriodp12  (optional, default to null)
    * @return kotlin.String
    */
    @Suppress("UNCHECKED_CAST")
    fun postTruststorePKCS12(truststorePeriodp12: java.io.File) : kotlin.String {
        val localVariableBody: kotlin.Any? = mapOf("truststore.p12" to "$truststorePeriodp12")
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/etc/truststore",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.String>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
