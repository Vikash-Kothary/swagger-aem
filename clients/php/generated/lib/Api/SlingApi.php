<?php
/**
 * SlingApi
 * PHP version 5
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Adobe Experience Manager (AEM) API
 *
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * OpenAPI spec version: 3.2.0-pre.0
 * Contact: opensource@shinesolutions.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 3.2.1-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * SlingApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SlingApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteAgent
     *
     * @param  string $runmode runmode (required)
     * @param  string $name name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAgent($runmode, $name)
    {
        $this->deleteAgentWithHttpInfo($runmode, $name);
    }

    /**
     * Operation deleteAgentWithHttpInfo
     *
     * @param  string $runmode (required)
     * @param  string $name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAgentWithHttpInfo($runmode, $name)
    {
        $request = $this->deleteAgentRequest($runmode, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAgentAsync
     *
     * 
     *
     * @param  string $runmode (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAgentAsync($runmode, $name)
    {
        return $this->deleteAgentAsyncWithHttpInfo($runmode, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAgentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $runmode (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAgentAsyncWithHttpInfo($runmode, $name)
    {
        $returnType = '';
        $request = $this->deleteAgentRequest($runmode, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAgent'
     *
     * @param  string $runmode (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteAgentRequest($runmode, $name)
    {
        // verify the required parameter 'runmode' is set
        if ($runmode === null || (is_array($runmode) && count($runmode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runmode when calling deleteAgent'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteAgent'
            );
        }

        $resourcePath = '/etc/replication/agents.{runmode}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($runmode !== null) {
            $resourcePath = str_replace(
                '{' . 'runmode' . '}',
                ObjectSerializer::toPathValue($runmode),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNode
     *
     * @param  string $path path (required)
     * @param  string $name name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNode($path, $name)
    {
        $this->deleteNodeWithHttpInfo($path, $name);
    }

    /**
     * Operation deleteNodeWithHttpInfo
     *
     * @param  string $path (required)
     * @param  string $name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNodeWithHttpInfo($path, $name)
    {
        $request = $this->deleteNodeRequest($path, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNodeAsync
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNodeAsync($path, $name)
    {
        return $this->deleteNodeAsyncWithHttpInfo($path, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNodeAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNodeAsyncWithHttpInfo($path, $name)
    {
        $returnType = '';
        $request = $this->deleteNodeRequest($path, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNode'
     *
     * @param  string $path (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNodeRequest($path, $name)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling deleteNode'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteNode'
            );
        }

        $resourcePath = '/{path}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAgent
     *
     * @param  string $runmode runmode (required)
     * @param  string $name name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getAgent($runmode, $name)
    {
        $this->getAgentWithHttpInfo($runmode, $name);
    }

    /**
     * Operation getAgentWithHttpInfo
     *
     * @param  string $runmode (required)
     * @param  string $name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAgentWithHttpInfo($runmode, $name)
    {
        $request = $this->getAgentRequest($runmode, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getAgentAsync
     *
     * 
     *
     * @param  string $runmode (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentAsync($runmode, $name)
    {
        return $this->getAgentAsyncWithHttpInfo($runmode, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAgentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $runmode (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentAsyncWithHttpInfo($runmode, $name)
    {
        $returnType = '';
        $request = $this->getAgentRequest($runmode, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAgent'
     *
     * @param  string $runmode (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAgentRequest($runmode, $name)
    {
        // verify the required parameter 'runmode' is set
        if ($runmode === null || (is_array($runmode) && count($runmode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runmode when calling getAgent'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getAgent'
            );
        }

        $resourcePath = '/etc/replication/agents.{runmode}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($runmode !== null) {
            $resourcePath = str_replace(
                '{' . 'runmode' . '}',
                ObjectSerializer::toPathValue($runmode),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAgents
     *
     * @param  string $runmode runmode (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getAgents($runmode)
    {
        list($response) = $this->getAgentsWithHttpInfo($runmode);
        return $response;
    }

    /**
     * Operation getAgentsWithHttpInfo
     *
     * @param  string $runmode (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAgentsWithHttpInfo($runmode)
    {
        $request = $this->getAgentsRequest($runmode);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                default:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAgentsAsync
     *
     * 
     *
     * @param  string $runmode (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentsAsync($runmode)
    {
        return $this->getAgentsAsyncWithHttpInfo($runmode)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAgentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $runmode (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentsAsyncWithHttpInfo($runmode)
    {
        $returnType = 'string';
        $request = $this->getAgentsRequest($runmode);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAgents'
     *
     * @param  string $runmode (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAgentsRequest($runmode)
    {
        // verify the required parameter 'runmode' is set
        if ($runmode === null || (is_array($runmode) && count($runmode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runmode when calling getAgents'
            );
        }

        $resourcePath = '/etc/replication/agents.{runmode}.-1.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($runmode !== null) {
            $resourcePath = str_replace(
                '{' . 'runmode' . '}',
                ObjectSerializer::toPathValue($runmode),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAuthorizableKeystore
     *
     * @param  string $intermediate_path intermediate_path (required)
     * @param  string $authorizable_id authorizable_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\KeystoreInfo|string
     */
    public function getAuthorizableKeystore($intermediate_path, $authorizable_id)
    {
        list($response) = $this->getAuthorizableKeystoreWithHttpInfo($intermediate_path, $authorizable_id);
        return $response;
    }

    /**
     * Operation getAuthorizableKeystoreWithHttpInfo
     *
     * @param  string $intermediate_path (required)
     * @param  string $authorizable_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\KeystoreInfo|string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAuthorizableKeystoreWithHttpInfo($intermediate_path, $authorizable_id)
    {
        $request = $this->getAuthorizableKeystoreRequest($intermediate_path, $authorizable_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\KeystoreInfo' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\OpenAPI\Client\Model\KeystoreInfo' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\KeystoreInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\KeystoreInfo';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\KeystoreInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAuthorizableKeystoreAsync
     *
     * 
     *
     * @param  string $intermediate_path (required)
     * @param  string $authorizable_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAuthorizableKeystoreAsync($intermediate_path, $authorizable_id)
    {
        return $this->getAuthorizableKeystoreAsyncWithHttpInfo($intermediate_path, $authorizable_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAuthorizableKeystoreAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $intermediate_path (required)
     * @param  string $authorizable_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAuthorizableKeystoreAsyncWithHttpInfo($intermediate_path, $authorizable_id)
    {
        $returnType = '\OpenAPI\Client\Model\KeystoreInfo';
        $request = $this->getAuthorizableKeystoreRequest($intermediate_path, $authorizable_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAuthorizableKeystore'
     *
     * @param  string $intermediate_path (required)
     * @param  string $authorizable_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAuthorizableKeystoreRequest($intermediate_path, $authorizable_id)
    {
        // verify the required parameter 'intermediate_path' is set
        if ($intermediate_path === null || (is_array($intermediate_path) && count($intermediate_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $intermediate_path when calling getAuthorizableKeystore'
            );
        }
        // verify the required parameter 'authorizable_id' is set
        if ($authorizable_id === null || (is_array($authorizable_id) && count($authorizable_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorizable_id when calling getAuthorizableKeystore'
            );
        }

        $resourcePath = '/{intermediatePath}/{authorizableId}.ks.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($intermediate_path !== null) {
            $resourcePath = str_replace(
                '{' . 'intermediatePath' . '}',
                ObjectSerializer::toPathValue($intermediate_path),
                $resourcePath
            );
        }
        // path params
        if ($authorizable_id !== null) {
            $resourcePath = str_replace(
                '{' . 'authorizableId' . '}',
                ObjectSerializer::toPathValue($authorizable_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKeystore
     *
     * @param  string $intermediate_path intermediate_path (required)
     * @param  string $authorizable_id authorizable_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getKeystore($intermediate_path, $authorizable_id)
    {
        list($response) = $this->getKeystoreWithHttpInfo($intermediate_path, $authorizable_id);
        return $response;
    }

    /**
     * Operation getKeystoreWithHttpInfo
     *
     * @param  string $intermediate_path (required)
     * @param  string $authorizable_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKeystoreWithHttpInfo($intermediate_path, $authorizable_id)
    {
        $request = $this->getKeystoreRequest($intermediate_path, $authorizable_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                default:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKeystoreAsync
     *
     * 
     *
     * @param  string $intermediate_path (required)
     * @param  string $authorizable_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKeystoreAsync($intermediate_path, $authorizable_id)
    {
        return $this->getKeystoreAsyncWithHttpInfo($intermediate_path, $authorizable_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKeystoreAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $intermediate_path (required)
     * @param  string $authorizable_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKeystoreAsyncWithHttpInfo($intermediate_path, $authorizable_id)
    {
        $returnType = '\SplFileObject';
        $request = $this->getKeystoreRequest($intermediate_path, $authorizable_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKeystore'
     *
     * @param  string $intermediate_path (required)
     * @param  string $authorizable_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getKeystoreRequest($intermediate_path, $authorizable_id)
    {
        // verify the required parameter 'intermediate_path' is set
        if ($intermediate_path === null || (is_array($intermediate_path) && count($intermediate_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $intermediate_path when calling getKeystore'
            );
        }
        // verify the required parameter 'authorizable_id' is set
        if ($authorizable_id === null || (is_array($authorizable_id) && count($authorizable_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorizable_id when calling getKeystore'
            );
        }

        $resourcePath = '/{intermediatePath}/{authorizableId}/keystore/store.p12';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($intermediate_path !== null) {
            $resourcePath = str_replace(
                '{' . 'intermediatePath' . '}',
                ObjectSerializer::toPathValue($intermediate_path),
                $resourcePath
            );
        }
        // path params
        if ($authorizable_id !== null) {
            $resourcePath = str_replace(
                '{' . 'authorizableId' . '}',
                ObjectSerializer::toPathValue($authorizable_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNode
     *
     * @param  string $path path (required)
     * @param  string $name name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getNode($path, $name)
    {
        $this->getNodeWithHttpInfo($path, $name);
    }

    /**
     * Operation getNodeWithHttpInfo
     *
     * @param  string $path (required)
     * @param  string $name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNodeWithHttpInfo($path, $name)
    {
        $request = $this->getNodeRequest($path, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getNodeAsync
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeAsync($path, $name)
    {
        return $this->getNodeAsyncWithHttpInfo($path, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNodeAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeAsyncWithHttpInfo($path, $name)
    {
        $returnType = '';
        $request = $this->getNodeRequest($path, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNode'
     *
     * @param  string $path (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNodeRequest($path, $name)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getNode'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getNode'
            );
        }

        $resourcePath = '/{path}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPackage
     *
     * @param  string $group group (required)
     * @param  string $name name (required)
     * @param  string $version version (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPackage($group, $name, $version)
    {
        list($response) = $this->getPackageWithHttpInfo($group, $name, $version);
        return $response;
    }

    /**
     * Operation getPackageWithHttpInfo
     *
     * @param  string $group (required)
     * @param  string $name (required)
     * @param  string $version (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPackageWithHttpInfo($group, $name, $version)
    {
        $request = $this->getPackageRequest($group, $name, $version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                default:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPackageAsync
     *
     * 
     *
     * @param  string $group (required)
     * @param  string $name (required)
     * @param  string $version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPackageAsync($group, $name, $version)
    {
        return $this->getPackageAsyncWithHttpInfo($group, $name, $version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPackageAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $group (required)
     * @param  string $name (required)
     * @param  string $version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPackageAsyncWithHttpInfo($group, $name, $version)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPackageRequest($group, $name, $version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPackage'
     *
     * @param  string $group (required)
     * @param  string $name (required)
     * @param  string $version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPackageRequest($group, $name, $version)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling getPackage'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPackage'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getPackage'
            );
        }

        $resourcePath = '/etc/packages/{group}/{name}-{version}.zip';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPackageFilter
     *
     * @param  string $group group (required)
     * @param  string $name name (required)
     * @param  string $version version (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getPackageFilter($group, $name, $version)
    {
        list($response) = $this->getPackageFilterWithHttpInfo($group, $name, $version);
        return $response;
    }

    /**
     * Operation getPackageFilterWithHttpInfo
     *
     * @param  string $group (required)
     * @param  string $name (required)
     * @param  string $version (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPackageFilterWithHttpInfo($group, $name, $version)
    {
        $request = $this->getPackageFilterRequest($group, $name, $version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                default:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPackageFilterAsync
     *
     * 
     *
     * @param  string $group (required)
     * @param  string $name (required)
     * @param  string $version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPackageFilterAsync($group, $name, $version)
    {
        return $this->getPackageFilterAsyncWithHttpInfo($group, $name, $version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPackageFilterAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $group (required)
     * @param  string $name (required)
     * @param  string $version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPackageFilterAsyncWithHttpInfo($group, $name, $version)
    {
        $returnType = 'string';
        $request = $this->getPackageFilterRequest($group, $name, $version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPackageFilter'
     *
     * @param  string $group (required)
     * @param  string $name (required)
     * @param  string $version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPackageFilterRequest($group, $name, $version)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling getPackageFilter'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPackageFilter'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getPackageFilter'
            );
        }

        $resourcePath = '/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getQuery
     *
     * @param  string $path path (required)
     * @param  float $p_limit p_limit (required)
     * @param  string $_1_property _1_property (required)
     * @param  string $_1_property_value _1_property_value (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getQuery($path, $p_limit, $_1_property, $_1_property_value)
    {
        list($response) = $this->getQueryWithHttpInfo($path, $p_limit, $_1_property, $_1_property_value);
        return $response;
    }

    /**
     * Operation getQueryWithHttpInfo
     *
     * @param  string $path (required)
     * @param  float $p_limit (required)
     * @param  string $_1_property (required)
     * @param  string $_1_property_value (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getQueryWithHttpInfo($path, $p_limit, $_1_property, $_1_property_value)
    {
        $request = $this->getQueryRequest($path, $p_limit, $_1_property, $_1_property_value);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                default:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getQueryAsync
     *
     * 
     *
     * @param  string $path (required)
     * @param  float $p_limit (required)
     * @param  string $_1_property (required)
     * @param  string $_1_property_value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getQueryAsync($path, $p_limit, $_1_property, $_1_property_value)
    {
        return $this->getQueryAsyncWithHttpInfo($path, $p_limit, $_1_property, $_1_property_value)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getQueryAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path (required)
     * @param  float $p_limit (required)
     * @param  string $_1_property (required)
     * @param  string $_1_property_value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getQueryAsyncWithHttpInfo($path, $p_limit, $_1_property, $_1_property_value)
    {
        $returnType = 'string';
        $request = $this->getQueryRequest($path, $p_limit, $_1_property, $_1_property_value);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getQuery'
     *
     * @param  string $path (required)
     * @param  float $p_limit (required)
     * @param  string $_1_property (required)
     * @param  string $_1_property_value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getQueryRequest($path, $p_limit, $_1_property, $_1_property_value)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getQuery'
            );
        }
        // verify the required parameter 'p_limit' is set
        if ($p_limit === null || (is_array($p_limit) && count($p_limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $p_limit when calling getQuery'
            );
        }
        // verify the required parameter '_1_property' is set
        if ($_1_property === null || (is_array($_1_property) && count($_1_property) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $_1_property when calling getQuery'
            );
        }
        // verify the required parameter '_1_property_value' is set
        if ($_1_property_value === null || (is_array($_1_property_value) && count($_1_property_value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $_1_property_value when calling getQuery'
            );
        }

        $resourcePath = '/bin/querybuilder.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($p_limit !== null) {
            $queryParams['p.limit'] = ObjectSerializer::toQueryValue($p_limit);
        }
        // query params
        if ($_1_property !== null) {
            $queryParams['1_property'] = ObjectSerializer::toQueryValue($_1_property);
        }
        // query params
        if ($_1_property_value !== null) {
            $queryParams['1_property.value'] = ObjectSerializer::toQueryValue($_1_property_value);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTruststore
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getTruststore()
    {
        list($response) = $this->getTruststoreWithHttpInfo();
        return $response;
    }

    /**
     * Operation getTruststoreWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTruststoreWithHttpInfo()
    {
        $request = $this->getTruststoreRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                default:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTruststoreAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTruststoreAsync()
    {
        return $this->getTruststoreAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTruststoreAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTruststoreAsyncWithHttpInfo()
    {
        $returnType = '\SplFileObject';
        $request = $this->getTruststoreRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTruststore'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTruststoreRequest()
    {

        $resourcePath = '/etc/truststore/truststore.p12';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTruststoreInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TruststoreInfo|string
     */
    public function getTruststoreInfo()
    {
        list($response) = $this->getTruststoreInfoWithHttpInfo();
        return $response;
    }

    /**
     * Operation getTruststoreInfoWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TruststoreInfo|string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTruststoreInfoWithHttpInfo()
    {
        $request = $this->getTruststoreInfoRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TruststoreInfo' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\OpenAPI\Client\Model\TruststoreInfo' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TruststoreInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TruststoreInfo';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TruststoreInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTruststoreInfoAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTruststoreInfoAsync()
    {
        return $this->getTruststoreInfoAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTruststoreInfoAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTruststoreInfoAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\TruststoreInfo';
        $request = $this->getTruststoreInfoRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTruststoreInfo'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTruststoreInfoRequest()
    {

        $resourcePath = '/libs/granite/security/truststore.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postAgent
     *
     * @param  string $runmode runmode (required)
     * @param  string $name name (required)
     * @param  bool $jcrcontentcqdistribute jcrcontentcqdistribute (optional)
     * @param  string $jcrcontentcqdistribute_type_hint jcrcontentcqdistribute_type_hint (optional)
     * @param  string $jcrcontentcqname jcrcontentcqname (optional)
     * @param  string $jcrcontentcqtemplate jcrcontentcqtemplate (optional)
     * @param  bool $jcrcontentenabled jcrcontentenabled (optional)
     * @param  string $jcrcontentjcrdescription jcrcontentjcrdescription (optional)
     * @param  string $jcrcontentjcrlast_modified jcrcontentjcrlast_modified (optional)
     * @param  string $jcrcontentjcrlast_modified_by jcrcontentjcrlast_modified_by (optional)
     * @param  string $jcrcontentjcrmixin_types jcrcontentjcrmixin_types (optional)
     * @param  string $jcrcontentjcrtitle jcrcontentjcrtitle (optional)
     * @param  string $jcrcontentlog_level jcrcontentlog_level (optional)
     * @param  bool $jcrcontentno_status_update jcrcontentno_status_update (optional)
     * @param  bool $jcrcontentno_versioning jcrcontentno_versioning (optional)
     * @param  float $jcrcontentprotocol_connect_timeout jcrcontentprotocol_connect_timeout (optional)
     * @param  bool $jcrcontentprotocol_http_connection_closed jcrcontentprotocol_http_connection_closed (optional)
     * @param  string $jcrcontentprotocol_http_expired jcrcontentprotocol_http_expired (optional)
     * @param  string[] $jcrcontentprotocol_http_headers jcrcontentprotocol_http_headers (optional)
     * @param  string $jcrcontentprotocol_http_headers_type_hint jcrcontentprotocol_http_headers_type_hint (optional)
     * @param  string $jcrcontentprotocol_http_method jcrcontentprotocol_http_method (optional)
     * @param  bool $jcrcontentprotocol_https_relaxed jcrcontentprotocol_https_relaxed (optional)
     * @param  string $jcrcontentprotocol_interface jcrcontentprotocol_interface (optional)
     * @param  float $jcrcontentprotocol_socket_timeout jcrcontentprotocol_socket_timeout (optional)
     * @param  string $jcrcontentprotocol_version jcrcontentprotocol_version (optional)
     * @param  string $jcrcontentproxy_ntlm_domain jcrcontentproxy_ntlm_domain (optional)
     * @param  string $jcrcontentproxy_ntlm_host jcrcontentproxy_ntlm_host (optional)
     * @param  string $jcrcontentproxy_host jcrcontentproxy_host (optional)
     * @param  string $jcrcontentproxy_password jcrcontentproxy_password (optional)
     * @param  float $jcrcontentproxy_port jcrcontentproxy_port (optional)
     * @param  string $jcrcontentproxy_user jcrcontentproxy_user (optional)
     * @param  float $jcrcontentqueue_batch_max_size jcrcontentqueue_batch_max_size (optional)
     * @param  string $jcrcontentqueue_batch_mode jcrcontentqueue_batch_mode (optional)
     * @param  float $jcrcontentqueue_batch_wait_time jcrcontentqueue_batch_wait_time (optional)
     * @param  string $jcrcontentretry_delay jcrcontentretry_delay (optional)
     * @param  bool $jcrcontentreverse_replication jcrcontentreverse_replication (optional)
     * @param  string $jcrcontentserialization_type jcrcontentserialization_type (optional)
     * @param  string $jcrcontentslingresource_type jcrcontentslingresource_type (optional)
     * @param  string $jcrcontentssl jcrcontentssl (optional)
     * @param  string $jcrcontenttransport_ntlm_domain jcrcontenttransport_ntlm_domain (optional)
     * @param  string $jcrcontenttransport_ntlm_host jcrcontenttransport_ntlm_host (optional)
     * @param  string $jcrcontenttransport_password jcrcontenttransport_password (optional)
     * @param  string $jcrcontenttransport_uri jcrcontenttransport_uri (optional)
     * @param  string $jcrcontenttransport_user jcrcontenttransport_user (optional)
     * @param  bool $jcrcontenttrigger_distribute jcrcontenttrigger_distribute (optional)
     * @param  bool $jcrcontenttrigger_modified jcrcontenttrigger_modified (optional)
     * @param  bool $jcrcontenttrigger_on_off_time jcrcontenttrigger_on_off_time (optional)
     * @param  bool $jcrcontenttrigger_receive jcrcontenttrigger_receive (optional)
     * @param  bool $jcrcontenttrigger_specific jcrcontenttrigger_specific (optional)
     * @param  string $jcrcontentuser_id jcrcontentuser_id (optional)
     * @param  string $jcrprimary_type jcrprimary_type (optional)
     * @param  string $operation operation (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postAgent($runmode, $name, $jcrcontentcqdistribute = null, $jcrcontentcqdistribute_type_hint = null, $jcrcontentcqname = null, $jcrcontentcqtemplate = null, $jcrcontentenabled = null, $jcrcontentjcrdescription = null, $jcrcontentjcrlast_modified = null, $jcrcontentjcrlast_modified_by = null, $jcrcontentjcrmixin_types = null, $jcrcontentjcrtitle = null, $jcrcontentlog_level = null, $jcrcontentno_status_update = null, $jcrcontentno_versioning = null, $jcrcontentprotocol_connect_timeout = null, $jcrcontentprotocol_http_connection_closed = null, $jcrcontentprotocol_http_expired = null, $jcrcontentprotocol_http_headers = null, $jcrcontentprotocol_http_headers_type_hint = null, $jcrcontentprotocol_http_method = null, $jcrcontentprotocol_https_relaxed = null, $jcrcontentprotocol_interface = null, $jcrcontentprotocol_socket_timeout = null, $jcrcontentprotocol_version = null, $jcrcontentproxy_ntlm_domain = null, $jcrcontentproxy_ntlm_host = null, $jcrcontentproxy_host = null, $jcrcontentproxy_password = null, $jcrcontentproxy_port = null, $jcrcontentproxy_user = null, $jcrcontentqueue_batch_max_size = null, $jcrcontentqueue_batch_mode = null, $jcrcontentqueue_batch_wait_time = null, $jcrcontentretry_delay = null, $jcrcontentreverse_replication = null, $jcrcontentserialization_type = null, $jcrcontentslingresource_type = null, $jcrcontentssl = null, $jcrcontenttransport_ntlm_domain = null, $jcrcontenttransport_ntlm_host = null, $jcrcontenttransport_password = null, $jcrcontenttransport_uri = null, $jcrcontenttransport_user = null, $jcrcontenttrigger_distribute = null, $jcrcontenttrigger_modified = null, $jcrcontenttrigger_on_off_time = null, $jcrcontenttrigger_receive = null, $jcrcontenttrigger_specific = null, $jcrcontentuser_id = null, $jcrprimary_type = null, $operation = null)
    {
        $this->postAgentWithHttpInfo($runmode, $name, $jcrcontentcqdistribute, $jcrcontentcqdistribute_type_hint, $jcrcontentcqname, $jcrcontentcqtemplate, $jcrcontentenabled, $jcrcontentjcrdescription, $jcrcontentjcrlast_modified, $jcrcontentjcrlast_modified_by, $jcrcontentjcrmixin_types, $jcrcontentjcrtitle, $jcrcontentlog_level, $jcrcontentno_status_update, $jcrcontentno_versioning, $jcrcontentprotocol_connect_timeout, $jcrcontentprotocol_http_connection_closed, $jcrcontentprotocol_http_expired, $jcrcontentprotocol_http_headers, $jcrcontentprotocol_http_headers_type_hint, $jcrcontentprotocol_http_method, $jcrcontentprotocol_https_relaxed, $jcrcontentprotocol_interface, $jcrcontentprotocol_socket_timeout, $jcrcontentprotocol_version, $jcrcontentproxy_ntlm_domain, $jcrcontentproxy_ntlm_host, $jcrcontentproxy_host, $jcrcontentproxy_password, $jcrcontentproxy_port, $jcrcontentproxy_user, $jcrcontentqueue_batch_max_size, $jcrcontentqueue_batch_mode, $jcrcontentqueue_batch_wait_time, $jcrcontentretry_delay, $jcrcontentreverse_replication, $jcrcontentserialization_type, $jcrcontentslingresource_type, $jcrcontentssl, $jcrcontenttransport_ntlm_domain, $jcrcontenttransport_ntlm_host, $jcrcontenttransport_password, $jcrcontenttransport_uri, $jcrcontenttransport_user, $jcrcontenttrigger_distribute, $jcrcontenttrigger_modified, $jcrcontenttrigger_on_off_time, $jcrcontenttrigger_receive, $jcrcontenttrigger_specific, $jcrcontentuser_id, $jcrprimary_type, $operation);
    }

    /**
     * Operation postAgentWithHttpInfo
     *
     * @param  string $runmode (required)
     * @param  string $name (required)
     * @param  bool $jcrcontentcqdistribute (optional)
     * @param  string $jcrcontentcqdistribute_type_hint (optional)
     * @param  string $jcrcontentcqname (optional)
     * @param  string $jcrcontentcqtemplate (optional)
     * @param  bool $jcrcontentenabled (optional)
     * @param  string $jcrcontentjcrdescription (optional)
     * @param  string $jcrcontentjcrlast_modified (optional)
     * @param  string $jcrcontentjcrlast_modified_by (optional)
     * @param  string $jcrcontentjcrmixin_types (optional)
     * @param  string $jcrcontentjcrtitle (optional)
     * @param  string $jcrcontentlog_level (optional)
     * @param  bool $jcrcontentno_status_update (optional)
     * @param  bool $jcrcontentno_versioning (optional)
     * @param  float $jcrcontentprotocol_connect_timeout (optional)
     * @param  bool $jcrcontentprotocol_http_connection_closed (optional)
     * @param  string $jcrcontentprotocol_http_expired (optional)
     * @param  string[] $jcrcontentprotocol_http_headers (optional)
     * @param  string $jcrcontentprotocol_http_headers_type_hint (optional)
     * @param  string $jcrcontentprotocol_http_method (optional)
     * @param  bool $jcrcontentprotocol_https_relaxed (optional)
     * @param  string $jcrcontentprotocol_interface (optional)
     * @param  float $jcrcontentprotocol_socket_timeout (optional)
     * @param  string $jcrcontentprotocol_version (optional)
     * @param  string $jcrcontentproxy_ntlm_domain (optional)
     * @param  string $jcrcontentproxy_ntlm_host (optional)
     * @param  string $jcrcontentproxy_host (optional)
     * @param  string $jcrcontentproxy_password (optional)
     * @param  float $jcrcontentproxy_port (optional)
     * @param  string $jcrcontentproxy_user (optional)
     * @param  float $jcrcontentqueue_batch_max_size (optional)
     * @param  string $jcrcontentqueue_batch_mode (optional)
     * @param  float $jcrcontentqueue_batch_wait_time (optional)
     * @param  string $jcrcontentretry_delay (optional)
     * @param  bool $jcrcontentreverse_replication (optional)
     * @param  string $jcrcontentserialization_type (optional)
     * @param  string $jcrcontentslingresource_type (optional)
     * @param  string $jcrcontentssl (optional)
     * @param  string $jcrcontenttransport_ntlm_domain (optional)
     * @param  string $jcrcontenttransport_ntlm_host (optional)
     * @param  string $jcrcontenttransport_password (optional)
     * @param  string $jcrcontenttransport_uri (optional)
     * @param  string $jcrcontenttransport_user (optional)
     * @param  bool $jcrcontenttrigger_distribute (optional)
     * @param  bool $jcrcontenttrigger_modified (optional)
     * @param  bool $jcrcontenttrigger_on_off_time (optional)
     * @param  bool $jcrcontenttrigger_receive (optional)
     * @param  bool $jcrcontenttrigger_specific (optional)
     * @param  string $jcrcontentuser_id (optional)
     * @param  string $jcrprimary_type (optional)
     * @param  string $operation (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postAgentWithHttpInfo($runmode, $name, $jcrcontentcqdistribute = null, $jcrcontentcqdistribute_type_hint = null, $jcrcontentcqname = null, $jcrcontentcqtemplate = null, $jcrcontentenabled = null, $jcrcontentjcrdescription = null, $jcrcontentjcrlast_modified = null, $jcrcontentjcrlast_modified_by = null, $jcrcontentjcrmixin_types = null, $jcrcontentjcrtitle = null, $jcrcontentlog_level = null, $jcrcontentno_status_update = null, $jcrcontentno_versioning = null, $jcrcontentprotocol_connect_timeout = null, $jcrcontentprotocol_http_connection_closed = null, $jcrcontentprotocol_http_expired = null, $jcrcontentprotocol_http_headers = null, $jcrcontentprotocol_http_headers_type_hint = null, $jcrcontentprotocol_http_method = null, $jcrcontentprotocol_https_relaxed = null, $jcrcontentprotocol_interface = null, $jcrcontentprotocol_socket_timeout = null, $jcrcontentprotocol_version = null, $jcrcontentproxy_ntlm_domain = null, $jcrcontentproxy_ntlm_host = null, $jcrcontentproxy_host = null, $jcrcontentproxy_password = null, $jcrcontentproxy_port = null, $jcrcontentproxy_user = null, $jcrcontentqueue_batch_max_size = null, $jcrcontentqueue_batch_mode = null, $jcrcontentqueue_batch_wait_time = null, $jcrcontentretry_delay = null, $jcrcontentreverse_replication = null, $jcrcontentserialization_type = null, $jcrcontentslingresource_type = null, $jcrcontentssl = null, $jcrcontenttransport_ntlm_domain = null, $jcrcontenttransport_ntlm_host = null, $jcrcontenttransport_password = null, $jcrcontenttransport_uri = null, $jcrcontenttransport_user = null, $jcrcontenttrigger_distribute = null, $jcrcontenttrigger_modified = null, $jcrcontenttrigger_on_off_time = null, $jcrcontenttrigger_receive = null, $jcrcontenttrigger_specific = null, $jcrcontentuser_id = null, $jcrprimary_type = null, $operation = null)
    {
        $request = $this->postAgentRequest($runmode, $name, $jcrcontentcqdistribute, $jcrcontentcqdistribute_type_hint, $jcrcontentcqname, $jcrcontentcqtemplate, $jcrcontentenabled, $jcrcontentjcrdescription, $jcrcontentjcrlast_modified, $jcrcontentjcrlast_modified_by, $jcrcontentjcrmixin_types, $jcrcontentjcrtitle, $jcrcontentlog_level, $jcrcontentno_status_update, $jcrcontentno_versioning, $jcrcontentprotocol_connect_timeout, $jcrcontentprotocol_http_connection_closed, $jcrcontentprotocol_http_expired, $jcrcontentprotocol_http_headers, $jcrcontentprotocol_http_headers_type_hint, $jcrcontentprotocol_http_method, $jcrcontentprotocol_https_relaxed, $jcrcontentprotocol_interface, $jcrcontentprotocol_socket_timeout, $jcrcontentprotocol_version, $jcrcontentproxy_ntlm_domain, $jcrcontentproxy_ntlm_host, $jcrcontentproxy_host, $jcrcontentproxy_password, $jcrcontentproxy_port, $jcrcontentproxy_user, $jcrcontentqueue_batch_max_size, $jcrcontentqueue_batch_mode, $jcrcontentqueue_batch_wait_time, $jcrcontentretry_delay, $jcrcontentreverse_replication, $jcrcontentserialization_type, $jcrcontentslingresource_type, $jcrcontentssl, $jcrcontenttransport_ntlm_domain, $jcrcontenttransport_ntlm_host, $jcrcontenttransport_password, $jcrcontenttransport_uri, $jcrcontenttransport_user, $jcrcontenttrigger_distribute, $jcrcontenttrigger_modified, $jcrcontenttrigger_on_off_time, $jcrcontenttrigger_receive, $jcrcontenttrigger_specific, $jcrcontentuser_id, $jcrprimary_type, $operation);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postAgentAsync
     *
     * 
     *
     * @param  string $runmode (required)
     * @param  string $name (required)
     * @param  bool $jcrcontentcqdistribute (optional)
     * @param  string $jcrcontentcqdistribute_type_hint (optional)
     * @param  string $jcrcontentcqname (optional)
     * @param  string $jcrcontentcqtemplate (optional)
     * @param  bool $jcrcontentenabled (optional)
     * @param  string $jcrcontentjcrdescription (optional)
     * @param  string $jcrcontentjcrlast_modified (optional)
     * @param  string $jcrcontentjcrlast_modified_by (optional)
     * @param  string $jcrcontentjcrmixin_types (optional)
     * @param  string $jcrcontentjcrtitle (optional)
     * @param  string $jcrcontentlog_level (optional)
     * @param  bool $jcrcontentno_status_update (optional)
     * @param  bool $jcrcontentno_versioning (optional)
     * @param  float $jcrcontentprotocol_connect_timeout (optional)
     * @param  bool $jcrcontentprotocol_http_connection_closed (optional)
     * @param  string $jcrcontentprotocol_http_expired (optional)
     * @param  string[] $jcrcontentprotocol_http_headers (optional)
     * @param  string $jcrcontentprotocol_http_headers_type_hint (optional)
     * @param  string $jcrcontentprotocol_http_method (optional)
     * @param  bool $jcrcontentprotocol_https_relaxed (optional)
     * @param  string $jcrcontentprotocol_interface (optional)
     * @param  float $jcrcontentprotocol_socket_timeout (optional)
     * @param  string $jcrcontentprotocol_version (optional)
     * @param  string $jcrcontentproxy_ntlm_domain (optional)
     * @param  string $jcrcontentproxy_ntlm_host (optional)
     * @param  string $jcrcontentproxy_host (optional)
     * @param  string $jcrcontentproxy_password (optional)
     * @param  float $jcrcontentproxy_port (optional)
     * @param  string $jcrcontentproxy_user (optional)
     * @param  float $jcrcontentqueue_batch_max_size (optional)
     * @param  string $jcrcontentqueue_batch_mode (optional)
     * @param  float $jcrcontentqueue_batch_wait_time (optional)
     * @param  string $jcrcontentretry_delay (optional)
     * @param  bool $jcrcontentreverse_replication (optional)
     * @param  string $jcrcontentserialization_type (optional)
     * @param  string $jcrcontentslingresource_type (optional)
     * @param  string $jcrcontentssl (optional)
     * @param  string $jcrcontenttransport_ntlm_domain (optional)
     * @param  string $jcrcontenttransport_ntlm_host (optional)
     * @param  string $jcrcontenttransport_password (optional)
     * @param  string $jcrcontenttransport_uri (optional)
     * @param  string $jcrcontenttransport_user (optional)
     * @param  bool $jcrcontenttrigger_distribute (optional)
     * @param  bool $jcrcontenttrigger_modified (optional)
     * @param  bool $jcrcontenttrigger_on_off_time (optional)
     * @param  bool $jcrcontenttrigger_receive (optional)
     * @param  bool $jcrcontenttrigger_specific (optional)
     * @param  string $jcrcontentuser_id (optional)
     * @param  string $jcrprimary_type (optional)
     * @param  string $operation (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAgentAsync($runmode, $name, $jcrcontentcqdistribute = null, $jcrcontentcqdistribute_type_hint = null, $jcrcontentcqname = null, $jcrcontentcqtemplate = null, $jcrcontentenabled = null, $jcrcontentjcrdescription = null, $jcrcontentjcrlast_modified = null, $jcrcontentjcrlast_modified_by = null, $jcrcontentjcrmixin_types = null, $jcrcontentjcrtitle = null, $jcrcontentlog_level = null, $jcrcontentno_status_update = null, $jcrcontentno_versioning = null, $jcrcontentprotocol_connect_timeout = null, $jcrcontentprotocol_http_connection_closed = null, $jcrcontentprotocol_http_expired = null, $jcrcontentprotocol_http_headers = null, $jcrcontentprotocol_http_headers_type_hint = null, $jcrcontentprotocol_http_method = null, $jcrcontentprotocol_https_relaxed = null, $jcrcontentprotocol_interface = null, $jcrcontentprotocol_socket_timeout = null, $jcrcontentprotocol_version = null, $jcrcontentproxy_ntlm_domain = null, $jcrcontentproxy_ntlm_host = null, $jcrcontentproxy_host = null, $jcrcontentproxy_password = null, $jcrcontentproxy_port = null, $jcrcontentproxy_user = null, $jcrcontentqueue_batch_max_size = null, $jcrcontentqueue_batch_mode = null, $jcrcontentqueue_batch_wait_time = null, $jcrcontentretry_delay = null, $jcrcontentreverse_replication = null, $jcrcontentserialization_type = null, $jcrcontentslingresource_type = null, $jcrcontentssl = null, $jcrcontenttransport_ntlm_domain = null, $jcrcontenttransport_ntlm_host = null, $jcrcontenttransport_password = null, $jcrcontenttransport_uri = null, $jcrcontenttransport_user = null, $jcrcontenttrigger_distribute = null, $jcrcontenttrigger_modified = null, $jcrcontenttrigger_on_off_time = null, $jcrcontenttrigger_receive = null, $jcrcontenttrigger_specific = null, $jcrcontentuser_id = null, $jcrprimary_type = null, $operation = null)
    {
        return $this->postAgentAsyncWithHttpInfo($runmode, $name, $jcrcontentcqdistribute, $jcrcontentcqdistribute_type_hint, $jcrcontentcqname, $jcrcontentcqtemplate, $jcrcontentenabled, $jcrcontentjcrdescription, $jcrcontentjcrlast_modified, $jcrcontentjcrlast_modified_by, $jcrcontentjcrmixin_types, $jcrcontentjcrtitle, $jcrcontentlog_level, $jcrcontentno_status_update, $jcrcontentno_versioning, $jcrcontentprotocol_connect_timeout, $jcrcontentprotocol_http_connection_closed, $jcrcontentprotocol_http_expired, $jcrcontentprotocol_http_headers, $jcrcontentprotocol_http_headers_type_hint, $jcrcontentprotocol_http_method, $jcrcontentprotocol_https_relaxed, $jcrcontentprotocol_interface, $jcrcontentprotocol_socket_timeout, $jcrcontentprotocol_version, $jcrcontentproxy_ntlm_domain, $jcrcontentproxy_ntlm_host, $jcrcontentproxy_host, $jcrcontentproxy_password, $jcrcontentproxy_port, $jcrcontentproxy_user, $jcrcontentqueue_batch_max_size, $jcrcontentqueue_batch_mode, $jcrcontentqueue_batch_wait_time, $jcrcontentretry_delay, $jcrcontentreverse_replication, $jcrcontentserialization_type, $jcrcontentslingresource_type, $jcrcontentssl, $jcrcontenttransport_ntlm_domain, $jcrcontenttransport_ntlm_host, $jcrcontenttransport_password, $jcrcontenttransport_uri, $jcrcontenttransport_user, $jcrcontenttrigger_distribute, $jcrcontenttrigger_modified, $jcrcontenttrigger_on_off_time, $jcrcontenttrigger_receive, $jcrcontenttrigger_specific, $jcrcontentuser_id, $jcrprimary_type, $operation)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postAgentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $runmode (required)
     * @param  string $name (required)
     * @param  bool $jcrcontentcqdistribute (optional)
     * @param  string $jcrcontentcqdistribute_type_hint (optional)
     * @param  string $jcrcontentcqname (optional)
     * @param  string $jcrcontentcqtemplate (optional)
     * @param  bool $jcrcontentenabled (optional)
     * @param  string $jcrcontentjcrdescription (optional)
     * @param  string $jcrcontentjcrlast_modified (optional)
     * @param  string $jcrcontentjcrlast_modified_by (optional)
     * @param  string $jcrcontentjcrmixin_types (optional)
     * @param  string $jcrcontentjcrtitle (optional)
     * @param  string $jcrcontentlog_level (optional)
     * @param  bool $jcrcontentno_status_update (optional)
     * @param  bool $jcrcontentno_versioning (optional)
     * @param  float $jcrcontentprotocol_connect_timeout (optional)
     * @param  bool $jcrcontentprotocol_http_connection_closed (optional)
     * @param  string $jcrcontentprotocol_http_expired (optional)
     * @param  string[] $jcrcontentprotocol_http_headers (optional)
     * @param  string $jcrcontentprotocol_http_headers_type_hint (optional)
     * @param  string $jcrcontentprotocol_http_method (optional)
     * @param  bool $jcrcontentprotocol_https_relaxed (optional)
     * @param  string $jcrcontentprotocol_interface (optional)
     * @param  float $jcrcontentprotocol_socket_timeout (optional)
     * @param  string $jcrcontentprotocol_version (optional)
     * @param  string $jcrcontentproxy_ntlm_domain (optional)
     * @param  string $jcrcontentproxy_ntlm_host (optional)
     * @param  string $jcrcontentproxy_host (optional)
     * @param  string $jcrcontentproxy_password (optional)
     * @param  float $jcrcontentproxy_port (optional)
     * @param  string $jcrcontentproxy_user (optional)
     * @param  float $jcrcontentqueue_batch_max_size (optional)
     * @param  string $jcrcontentqueue_batch_mode (optional)
     * @param  float $jcrcontentqueue_batch_wait_time (optional)
     * @param  string $jcrcontentretry_delay (optional)
     * @param  bool $jcrcontentreverse_replication (optional)
     * @param  string $jcrcontentserialization_type (optional)
     * @param  string $jcrcontentslingresource_type (optional)
     * @param  string $jcrcontentssl (optional)
     * @param  string $jcrcontenttransport_ntlm_domain (optional)
     * @param  string $jcrcontenttransport_ntlm_host (optional)
     * @param  string $jcrcontenttransport_password (optional)
     * @param  string $jcrcontenttransport_uri (optional)
     * @param  string $jcrcontenttransport_user (optional)
     * @param  bool $jcrcontenttrigger_distribute (optional)
     * @param  bool $jcrcontenttrigger_modified (optional)
     * @param  bool $jcrcontenttrigger_on_off_time (optional)
     * @param  bool $jcrcontenttrigger_receive (optional)
     * @param  bool $jcrcontenttrigger_specific (optional)
     * @param  string $jcrcontentuser_id (optional)
     * @param  string $jcrprimary_type (optional)
     * @param  string $operation (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAgentAsyncWithHttpInfo($runmode, $name, $jcrcontentcqdistribute = null, $jcrcontentcqdistribute_type_hint = null, $jcrcontentcqname = null, $jcrcontentcqtemplate = null, $jcrcontentenabled = null, $jcrcontentjcrdescription = null, $jcrcontentjcrlast_modified = null, $jcrcontentjcrlast_modified_by = null, $jcrcontentjcrmixin_types = null, $jcrcontentjcrtitle = null, $jcrcontentlog_level = null, $jcrcontentno_status_update = null, $jcrcontentno_versioning = null, $jcrcontentprotocol_connect_timeout = null, $jcrcontentprotocol_http_connection_closed = null, $jcrcontentprotocol_http_expired = null, $jcrcontentprotocol_http_headers = null, $jcrcontentprotocol_http_headers_type_hint = null, $jcrcontentprotocol_http_method = null, $jcrcontentprotocol_https_relaxed = null, $jcrcontentprotocol_interface = null, $jcrcontentprotocol_socket_timeout = null, $jcrcontentprotocol_version = null, $jcrcontentproxy_ntlm_domain = null, $jcrcontentproxy_ntlm_host = null, $jcrcontentproxy_host = null, $jcrcontentproxy_password = null, $jcrcontentproxy_port = null, $jcrcontentproxy_user = null, $jcrcontentqueue_batch_max_size = null, $jcrcontentqueue_batch_mode = null, $jcrcontentqueue_batch_wait_time = null, $jcrcontentretry_delay = null, $jcrcontentreverse_replication = null, $jcrcontentserialization_type = null, $jcrcontentslingresource_type = null, $jcrcontentssl = null, $jcrcontenttransport_ntlm_domain = null, $jcrcontenttransport_ntlm_host = null, $jcrcontenttransport_password = null, $jcrcontenttransport_uri = null, $jcrcontenttransport_user = null, $jcrcontenttrigger_distribute = null, $jcrcontenttrigger_modified = null, $jcrcontenttrigger_on_off_time = null, $jcrcontenttrigger_receive = null, $jcrcontenttrigger_specific = null, $jcrcontentuser_id = null, $jcrprimary_type = null, $operation = null)
    {
        $returnType = '';
        $request = $this->postAgentRequest($runmode, $name, $jcrcontentcqdistribute, $jcrcontentcqdistribute_type_hint, $jcrcontentcqname, $jcrcontentcqtemplate, $jcrcontentenabled, $jcrcontentjcrdescription, $jcrcontentjcrlast_modified, $jcrcontentjcrlast_modified_by, $jcrcontentjcrmixin_types, $jcrcontentjcrtitle, $jcrcontentlog_level, $jcrcontentno_status_update, $jcrcontentno_versioning, $jcrcontentprotocol_connect_timeout, $jcrcontentprotocol_http_connection_closed, $jcrcontentprotocol_http_expired, $jcrcontentprotocol_http_headers, $jcrcontentprotocol_http_headers_type_hint, $jcrcontentprotocol_http_method, $jcrcontentprotocol_https_relaxed, $jcrcontentprotocol_interface, $jcrcontentprotocol_socket_timeout, $jcrcontentprotocol_version, $jcrcontentproxy_ntlm_domain, $jcrcontentproxy_ntlm_host, $jcrcontentproxy_host, $jcrcontentproxy_password, $jcrcontentproxy_port, $jcrcontentproxy_user, $jcrcontentqueue_batch_max_size, $jcrcontentqueue_batch_mode, $jcrcontentqueue_batch_wait_time, $jcrcontentretry_delay, $jcrcontentreverse_replication, $jcrcontentserialization_type, $jcrcontentslingresource_type, $jcrcontentssl, $jcrcontenttransport_ntlm_domain, $jcrcontenttransport_ntlm_host, $jcrcontenttransport_password, $jcrcontenttransport_uri, $jcrcontenttransport_user, $jcrcontenttrigger_distribute, $jcrcontenttrigger_modified, $jcrcontenttrigger_on_off_time, $jcrcontenttrigger_receive, $jcrcontenttrigger_specific, $jcrcontentuser_id, $jcrprimary_type, $operation);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postAgent'
     *
     * @param  string $runmode (required)
     * @param  string $name (required)
     * @param  bool $jcrcontentcqdistribute (optional)
     * @param  string $jcrcontentcqdistribute_type_hint (optional)
     * @param  string $jcrcontentcqname (optional)
     * @param  string $jcrcontentcqtemplate (optional)
     * @param  bool $jcrcontentenabled (optional)
     * @param  string $jcrcontentjcrdescription (optional)
     * @param  string $jcrcontentjcrlast_modified (optional)
     * @param  string $jcrcontentjcrlast_modified_by (optional)
     * @param  string $jcrcontentjcrmixin_types (optional)
     * @param  string $jcrcontentjcrtitle (optional)
     * @param  string $jcrcontentlog_level (optional)
     * @param  bool $jcrcontentno_status_update (optional)
     * @param  bool $jcrcontentno_versioning (optional)
     * @param  float $jcrcontentprotocol_connect_timeout (optional)
     * @param  bool $jcrcontentprotocol_http_connection_closed (optional)
     * @param  string $jcrcontentprotocol_http_expired (optional)
     * @param  string[] $jcrcontentprotocol_http_headers (optional)
     * @param  string $jcrcontentprotocol_http_headers_type_hint (optional)
     * @param  string $jcrcontentprotocol_http_method (optional)
     * @param  bool $jcrcontentprotocol_https_relaxed (optional)
     * @param  string $jcrcontentprotocol_interface (optional)
     * @param  float $jcrcontentprotocol_socket_timeout (optional)
     * @param  string $jcrcontentprotocol_version (optional)
     * @param  string $jcrcontentproxy_ntlm_domain (optional)
     * @param  string $jcrcontentproxy_ntlm_host (optional)
     * @param  string $jcrcontentproxy_host (optional)
     * @param  string $jcrcontentproxy_password (optional)
     * @param  float $jcrcontentproxy_port (optional)
     * @param  string $jcrcontentproxy_user (optional)
     * @param  float $jcrcontentqueue_batch_max_size (optional)
     * @param  string $jcrcontentqueue_batch_mode (optional)
     * @param  float $jcrcontentqueue_batch_wait_time (optional)
     * @param  string $jcrcontentretry_delay (optional)
     * @param  bool $jcrcontentreverse_replication (optional)
     * @param  string $jcrcontentserialization_type (optional)
     * @param  string $jcrcontentslingresource_type (optional)
     * @param  string $jcrcontentssl (optional)
     * @param  string $jcrcontenttransport_ntlm_domain (optional)
     * @param  string $jcrcontenttransport_ntlm_host (optional)
     * @param  string $jcrcontenttransport_password (optional)
     * @param  string $jcrcontenttransport_uri (optional)
     * @param  string $jcrcontenttransport_user (optional)
     * @param  bool $jcrcontenttrigger_distribute (optional)
     * @param  bool $jcrcontenttrigger_modified (optional)
     * @param  bool $jcrcontenttrigger_on_off_time (optional)
     * @param  bool $jcrcontenttrigger_receive (optional)
     * @param  bool $jcrcontenttrigger_specific (optional)
     * @param  string $jcrcontentuser_id (optional)
     * @param  string $jcrprimary_type (optional)
     * @param  string $operation (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postAgentRequest($runmode, $name, $jcrcontentcqdistribute = null, $jcrcontentcqdistribute_type_hint = null, $jcrcontentcqname = null, $jcrcontentcqtemplate = null, $jcrcontentenabled = null, $jcrcontentjcrdescription = null, $jcrcontentjcrlast_modified = null, $jcrcontentjcrlast_modified_by = null, $jcrcontentjcrmixin_types = null, $jcrcontentjcrtitle = null, $jcrcontentlog_level = null, $jcrcontentno_status_update = null, $jcrcontentno_versioning = null, $jcrcontentprotocol_connect_timeout = null, $jcrcontentprotocol_http_connection_closed = null, $jcrcontentprotocol_http_expired = null, $jcrcontentprotocol_http_headers = null, $jcrcontentprotocol_http_headers_type_hint = null, $jcrcontentprotocol_http_method = null, $jcrcontentprotocol_https_relaxed = null, $jcrcontentprotocol_interface = null, $jcrcontentprotocol_socket_timeout = null, $jcrcontentprotocol_version = null, $jcrcontentproxy_ntlm_domain = null, $jcrcontentproxy_ntlm_host = null, $jcrcontentproxy_host = null, $jcrcontentproxy_password = null, $jcrcontentproxy_port = null, $jcrcontentproxy_user = null, $jcrcontentqueue_batch_max_size = null, $jcrcontentqueue_batch_mode = null, $jcrcontentqueue_batch_wait_time = null, $jcrcontentretry_delay = null, $jcrcontentreverse_replication = null, $jcrcontentserialization_type = null, $jcrcontentslingresource_type = null, $jcrcontentssl = null, $jcrcontenttransport_ntlm_domain = null, $jcrcontenttransport_ntlm_host = null, $jcrcontenttransport_password = null, $jcrcontenttransport_uri = null, $jcrcontenttransport_user = null, $jcrcontenttrigger_distribute = null, $jcrcontenttrigger_modified = null, $jcrcontenttrigger_on_off_time = null, $jcrcontenttrigger_receive = null, $jcrcontenttrigger_specific = null, $jcrcontentuser_id = null, $jcrprimary_type = null, $operation = null)
    {
        // verify the required parameter 'runmode' is set
        if ($runmode === null || (is_array($runmode) && count($runmode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runmode when calling postAgent'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postAgent'
            );
        }

        $resourcePath = '/etc/replication/agents.{runmode}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($jcrcontentcqdistribute !== null) {
            $queryParams['jcr:content/cq:distribute'] = ObjectSerializer::toQueryValue($jcrcontentcqdistribute);
        }
        // query params
        if ($jcrcontentcqdistribute_type_hint !== null) {
            $queryParams['jcr:content/cq:distribute@TypeHint'] = ObjectSerializer::toQueryValue($jcrcontentcqdistribute_type_hint);
        }
        // query params
        if ($jcrcontentcqname !== null) {
            $queryParams['jcr:content/cq:name'] = ObjectSerializer::toQueryValue($jcrcontentcqname);
        }
        // query params
        if ($jcrcontentcqtemplate !== null) {
            $queryParams['jcr:content/cq:template'] = ObjectSerializer::toQueryValue($jcrcontentcqtemplate);
        }
        // query params
        if ($jcrcontentenabled !== null) {
            $queryParams['jcr:content/enabled'] = ObjectSerializer::toQueryValue($jcrcontentenabled);
        }
        // query params
        if ($jcrcontentjcrdescription !== null) {
            $queryParams['jcr:content/jcr:description'] = ObjectSerializer::toQueryValue($jcrcontentjcrdescription);
        }
        // query params
        if ($jcrcontentjcrlast_modified !== null) {
            $queryParams['jcr:content/jcr:lastModified'] = ObjectSerializer::toQueryValue($jcrcontentjcrlast_modified);
        }
        // query params
        if ($jcrcontentjcrlast_modified_by !== null) {
            $queryParams['jcr:content/jcr:lastModifiedBy'] = ObjectSerializer::toQueryValue($jcrcontentjcrlast_modified_by);
        }
        // query params
        if ($jcrcontentjcrmixin_types !== null) {
            $queryParams['jcr:content/jcr:mixinTypes'] = ObjectSerializer::toQueryValue($jcrcontentjcrmixin_types);
        }
        // query params
        if ($jcrcontentjcrtitle !== null) {
            $queryParams['jcr:content/jcr:title'] = ObjectSerializer::toQueryValue($jcrcontentjcrtitle);
        }
        // query params
        if ($jcrcontentlog_level !== null) {
            $queryParams['jcr:content/logLevel'] = ObjectSerializer::toQueryValue($jcrcontentlog_level);
        }
        // query params
        if ($jcrcontentno_status_update !== null) {
            $queryParams['jcr:content/noStatusUpdate'] = ObjectSerializer::toQueryValue($jcrcontentno_status_update);
        }
        // query params
        if ($jcrcontentno_versioning !== null) {
            $queryParams['jcr:content/noVersioning'] = ObjectSerializer::toQueryValue($jcrcontentno_versioning);
        }
        // query params
        if ($jcrcontentprotocol_connect_timeout !== null) {
            $queryParams['jcr:content/protocolConnectTimeout'] = ObjectSerializer::toQueryValue($jcrcontentprotocol_connect_timeout);
        }
        // query params
        if ($jcrcontentprotocol_http_connection_closed !== null) {
            $queryParams['jcr:content/protocolHTTPConnectionClosed'] = ObjectSerializer::toQueryValue($jcrcontentprotocol_http_connection_closed);
        }
        // query params
        if ($jcrcontentprotocol_http_expired !== null) {
            $queryParams['jcr:content/protocolHTTPExpired'] = ObjectSerializer::toQueryValue($jcrcontentprotocol_http_expired);
        }
        // query params
        if (is_array($jcrcontentprotocol_http_headers)) {
            $jcrcontentprotocol_http_headers = ObjectSerializer::serializeCollection($jcrcontentprotocol_http_headers, 'multi', true);
        }
        if ($jcrcontentprotocol_http_headers !== null) {
            $queryParams['jcr:content/protocolHTTPHeaders'] = ObjectSerializer::toQueryValue($jcrcontentprotocol_http_headers);
        }
        // query params
        if ($jcrcontentprotocol_http_headers_type_hint !== null) {
            $queryParams['jcr:content/protocolHTTPHeaders@TypeHint'] = ObjectSerializer::toQueryValue($jcrcontentprotocol_http_headers_type_hint);
        }
        // query params
        if ($jcrcontentprotocol_http_method !== null) {
            $queryParams['jcr:content/protocolHTTPMethod'] = ObjectSerializer::toQueryValue($jcrcontentprotocol_http_method);
        }
        // query params
        if ($jcrcontentprotocol_https_relaxed !== null) {
            $queryParams['jcr:content/protocolHTTPSRelaxed'] = ObjectSerializer::toQueryValue($jcrcontentprotocol_https_relaxed);
        }
        // query params
        if ($jcrcontentprotocol_interface !== null) {
            $queryParams['jcr:content/protocolInterface'] = ObjectSerializer::toQueryValue($jcrcontentprotocol_interface);
        }
        // query params
        if ($jcrcontentprotocol_socket_timeout !== null) {
            $queryParams['jcr:content/protocolSocketTimeout'] = ObjectSerializer::toQueryValue($jcrcontentprotocol_socket_timeout);
        }
        // query params
        if ($jcrcontentprotocol_version !== null) {
            $queryParams['jcr:content/protocolVersion'] = ObjectSerializer::toQueryValue($jcrcontentprotocol_version);
        }
        // query params
        if ($jcrcontentproxy_ntlm_domain !== null) {
            $queryParams['jcr:content/proxyNTLMDomain'] = ObjectSerializer::toQueryValue($jcrcontentproxy_ntlm_domain);
        }
        // query params
        if ($jcrcontentproxy_ntlm_host !== null) {
            $queryParams['jcr:content/proxyNTLMHost'] = ObjectSerializer::toQueryValue($jcrcontentproxy_ntlm_host);
        }
        // query params
        if ($jcrcontentproxy_host !== null) {
            $queryParams['jcr:content/proxyHost'] = ObjectSerializer::toQueryValue($jcrcontentproxy_host);
        }
        // query params
        if ($jcrcontentproxy_password !== null) {
            $queryParams['jcr:content/proxyPassword'] = ObjectSerializer::toQueryValue($jcrcontentproxy_password);
        }
        // query params
        if ($jcrcontentproxy_port !== null) {
            $queryParams['jcr:content/proxyPort'] = ObjectSerializer::toQueryValue($jcrcontentproxy_port);
        }
        // query params
        if ($jcrcontentproxy_user !== null) {
            $queryParams['jcr:content/proxyUser'] = ObjectSerializer::toQueryValue($jcrcontentproxy_user);
        }
        // query params
        if ($jcrcontentqueue_batch_max_size !== null) {
            $queryParams['jcr:content/queueBatchMaxSize'] = ObjectSerializer::toQueryValue($jcrcontentqueue_batch_max_size);
        }
        // query params
        if ($jcrcontentqueue_batch_mode !== null) {
            $queryParams['jcr:content/queueBatchMode'] = ObjectSerializer::toQueryValue($jcrcontentqueue_batch_mode);
        }
        // query params
        if ($jcrcontentqueue_batch_wait_time !== null) {
            $queryParams['jcr:content/queueBatchWaitTime'] = ObjectSerializer::toQueryValue($jcrcontentqueue_batch_wait_time);
        }
        // query params
        if ($jcrcontentretry_delay !== null) {
            $queryParams['jcr:content/retryDelay'] = ObjectSerializer::toQueryValue($jcrcontentretry_delay);
        }
        // query params
        if ($jcrcontentreverse_replication !== null) {
            $queryParams['jcr:content/reverseReplication'] = ObjectSerializer::toQueryValue($jcrcontentreverse_replication);
        }
        // query params
        if ($jcrcontentserialization_type !== null) {
            $queryParams['jcr:content/serializationType'] = ObjectSerializer::toQueryValue($jcrcontentserialization_type);
        }
        // query params
        if ($jcrcontentslingresource_type !== null) {
            $queryParams['jcr:content/sling:resourceType'] = ObjectSerializer::toQueryValue($jcrcontentslingresource_type);
        }
        // query params
        if ($jcrcontentssl !== null) {
            $queryParams['jcr:content/ssl'] = ObjectSerializer::toQueryValue($jcrcontentssl);
        }
        // query params
        if ($jcrcontenttransport_ntlm_domain !== null) {
            $queryParams['jcr:content/transportNTLMDomain'] = ObjectSerializer::toQueryValue($jcrcontenttransport_ntlm_domain);
        }
        // query params
        if ($jcrcontenttransport_ntlm_host !== null) {
            $queryParams['jcr:content/transportNTLMHost'] = ObjectSerializer::toQueryValue($jcrcontenttransport_ntlm_host);
        }
        // query params
        if ($jcrcontenttransport_password !== null) {
            $queryParams['jcr:content/transportPassword'] = ObjectSerializer::toQueryValue($jcrcontenttransport_password);
        }
        // query params
        if ($jcrcontenttransport_uri !== null) {
            $queryParams['jcr:content/transportUri'] = ObjectSerializer::toQueryValue($jcrcontenttransport_uri);
        }
        // query params
        if ($jcrcontenttransport_user !== null) {
            $queryParams['jcr:content/transportUser'] = ObjectSerializer::toQueryValue($jcrcontenttransport_user);
        }
        // query params
        if ($jcrcontenttrigger_distribute !== null) {
            $queryParams['jcr:content/triggerDistribute'] = ObjectSerializer::toQueryValue($jcrcontenttrigger_distribute);
        }
        // query params
        if ($jcrcontenttrigger_modified !== null) {
            $queryParams['jcr:content/triggerModified'] = ObjectSerializer::toQueryValue($jcrcontenttrigger_modified);
        }
        // query params
        if ($jcrcontenttrigger_on_off_time !== null) {
            $queryParams['jcr:content/triggerOnOffTime'] = ObjectSerializer::toQueryValue($jcrcontenttrigger_on_off_time);
        }
        // query params
        if ($jcrcontenttrigger_receive !== null) {
            $queryParams['jcr:content/triggerReceive'] = ObjectSerializer::toQueryValue($jcrcontenttrigger_receive);
        }
        // query params
        if ($jcrcontenttrigger_specific !== null) {
            $queryParams['jcr:content/triggerSpecific'] = ObjectSerializer::toQueryValue($jcrcontenttrigger_specific);
        }
        // query params
        if ($jcrcontentuser_id !== null) {
            $queryParams['jcr:content/userId'] = ObjectSerializer::toQueryValue($jcrcontentuser_id);
        }
        // query params
        if ($jcrprimary_type !== null) {
            $queryParams['jcr:primaryType'] = ObjectSerializer::toQueryValue($jcrprimary_type);
        }
        // query params
        if ($operation !== null) {
            $queryParams[':operation'] = ObjectSerializer::toQueryValue($operation);
        }

        // path params
        if ($runmode !== null) {
            $resourcePath = str_replace(
                '{' . 'runmode' . '}',
                ObjectSerializer::toPathValue($runmode),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postAuthorizableKeystore
     *
     * @param  string $intermediate_path intermediate_path (required)
     * @param  string $authorizable_id authorizable_id (required)
     * @param  string $operation operation (optional)
     * @param  string $current_password current_password (optional)
     * @param  string $new_password new_password (optional)
     * @param  string $re_password re_password (optional)
     * @param  string $key_password key_password (optional)
     * @param  string $key_store_pass key_store_pass (optional)
     * @param  string $alias alias (optional)
     * @param  string $new_alias new_alias (optional)
     * @param  string $remove_alias remove_alias (optional)
     * @param  \SplFileObject $cert_chain cert_chain (optional)
     * @param  \SplFileObject $pk pk (optional)
     * @param  \SplFileObject $key_store key_store (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\KeystoreInfo|string
     */
    public function postAuthorizableKeystore($intermediate_path, $authorizable_id, $operation = null, $current_password = null, $new_password = null, $re_password = null, $key_password = null, $key_store_pass = null, $alias = null, $new_alias = null, $remove_alias = null, $cert_chain = null, $pk = null, $key_store = null)
    {
        list($response) = $this->postAuthorizableKeystoreWithHttpInfo($intermediate_path, $authorizable_id, $operation, $current_password, $new_password, $re_password, $key_password, $key_store_pass, $alias, $new_alias, $remove_alias, $cert_chain, $pk, $key_store);
        return $response;
    }

    /**
     * Operation postAuthorizableKeystoreWithHttpInfo
     *
     * @param  string $intermediate_path (required)
     * @param  string $authorizable_id (required)
     * @param  string $operation (optional)
     * @param  string $current_password (optional)
     * @param  string $new_password (optional)
     * @param  string $re_password (optional)
     * @param  string $key_password (optional)
     * @param  string $key_store_pass (optional)
     * @param  string $alias (optional)
     * @param  string $new_alias (optional)
     * @param  string $remove_alias (optional)
     * @param  \SplFileObject $cert_chain (optional)
     * @param  \SplFileObject $pk (optional)
     * @param  \SplFileObject $key_store (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\KeystoreInfo|string, HTTP status code, HTTP response headers (array of strings)
     */
    public function postAuthorizableKeystoreWithHttpInfo($intermediate_path, $authorizable_id, $operation = null, $current_password = null, $new_password = null, $re_password = null, $key_password = null, $key_store_pass = null, $alias = null, $new_alias = null, $remove_alias = null, $cert_chain = null, $pk = null, $key_store = null)
    {
        $request = $this->postAuthorizableKeystoreRequest($intermediate_path, $authorizable_id, $operation, $current_password, $new_password, $re_password, $key_password, $key_store_pass, $alias, $new_alias, $remove_alias, $cert_chain, $pk, $key_store);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\KeystoreInfo' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\OpenAPI\Client\Model\KeystoreInfo' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\KeystoreInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\KeystoreInfo';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\KeystoreInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postAuthorizableKeystoreAsync
     *
     * 
     *
     * @param  string $intermediate_path (required)
     * @param  string $authorizable_id (required)
     * @param  string $operation (optional)
     * @param  string $current_password (optional)
     * @param  string $new_password (optional)
     * @param  string $re_password (optional)
     * @param  string $key_password (optional)
     * @param  string $key_store_pass (optional)
     * @param  string $alias (optional)
     * @param  string $new_alias (optional)
     * @param  string $remove_alias (optional)
     * @param  \SplFileObject $cert_chain (optional)
     * @param  \SplFileObject $pk (optional)
     * @param  \SplFileObject $key_store (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAuthorizableKeystoreAsync($intermediate_path, $authorizable_id, $operation = null, $current_password = null, $new_password = null, $re_password = null, $key_password = null, $key_store_pass = null, $alias = null, $new_alias = null, $remove_alias = null, $cert_chain = null, $pk = null, $key_store = null)
    {
        return $this->postAuthorizableKeystoreAsyncWithHttpInfo($intermediate_path, $authorizable_id, $operation, $current_password, $new_password, $re_password, $key_password, $key_store_pass, $alias, $new_alias, $remove_alias, $cert_chain, $pk, $key_store)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postAuthorizableKeystoreAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $intermediate_path (required)
     * @param  string $authorizable_id (required)
     * @param  string $operation (optional)
     * @param  string $current_password (optional)
     * @param  string $new_password (optional)
     * @param  string $re_password (optional)
     * @param  string $key_password (optional)
     * @param  string $key_store_pass (optional)
     * @param  string $alias (optional)
     * @param  string $new_alias (optional)
     * @param  string $remove_alias (optional)
     * @param  \SplFileObject $cert_chain (optional)
     * @param  \SplFileObject $pk (optional)
     * @param  \SplFileObject $key_store (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAuthorizableKeystoreAsyncWithHttpInfo($intermediate_path, $authorizable_id, $operation = null, $current_password = null, $new_password = null, $re_password = null, $key_password = null, $key_store_pass = null, $alias = null, $new_alias = null, $remove_alias = null, $cert_chain = null, $pk = null, $key_store = null)
    {
        $returnType = '\OpenAPI\Client\Model\KeystoreInfo';
        $request = $this->postAuthorizableKeystoreRequest($intermediate_path, $authorizable_id, $operation, $current_password, $new_password, $re_password, $key_password, $key_store_pass, $alias, $new_alias, $remove_alias, $cert_chain, $pk, $key_store);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postAuthorizableKeystore'
     *
     * @param  string $intermediate_path (required)
     * @param  string $authorizable_id (required)
     * @param  string $operation (optional)
     * @param  string $current_password (optional)
     * @param  string $new_password (optional)
     * @param  string $re_password (optional)
     * @param  string $key_password (optional)
     * @param  string $key_store_pass (optional)
     * @param  string $alias (optional)
     * @param  string $new_alias (optional)
     * @param  string $remove_alias (optional)
     * @param  \SplFileObject $cert_chain (optional)
     * @param  \SplFileObject $pk (optional)
     * @param  \SplFileObject $key_store (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postAuthorizableKeystoreRequest($intermediate_path, $authorizable_id, $operation = null, $current_password = null, $new_password = null, $re_password = null, $key_password = null, $key_store_pass = null, $alias = null, $new_alias = null, $remove_alias = null, $cert_chain = null, $pk = null, $key_store = null)
    {
        // verify the required parameter 'intermediate_path' is set
        if ($intermediate_path === null || (is_array($intermediate_path) && count($intermediate_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $intermediate_path when calling postAuthorizableKeystore'
            );
        }
        // verify the required parameter 'authorizable_id' is set
        if ($authorizable_id === null || (is_array($authorizable_id) && count($authorizable_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorizable_id when calling postAuthorizableKeystore'
            );
        }

        $resourcePath = '/{intermediatePath}/{authorizableId}.ks.html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($operation !== null) {
            $queryParams[':operation'] = ObjectSerializer::toQueryValue($operation);
        }
        // query params
        if ($current_password !== null) {
            $queryParams['currentPassword'] = ObjectSerializer::toQueryValue($current_password);
        }
        // query params
        if ($new_password !== null) {
            $queryParams['newPassword'] = ObjectSerializer::toQueryValue($new_password);
        }
        // query params
        if ($re_password !== null) {
            $queryParams['rePassword'] = ObjectSerializer::toQueryValue($re_password);
        }
        // query params
        if ($key_password !== null) {
            $queryParams['keyPassword'] = ObjectSerializer::toQueryValue($key_password);
        }
        // query params
        if ($key_store_pass !== null) {
            $queryParams['keyStorePass'] = ObjectSerializer::toQueryValue($key_store_pass);
        }
        // query params
        if ($alias !== null) {
            $queryParams['alias'] = ObjectSerializer::toQueryValue($alias);
        }
        // query params
        if ($new_alias !== null) {
            $queryParams['newAlias'] = ObjectSerializer::toQueryValue($new_alias);
        }
        // query params
        if ($remove_alias !== null) {
            $queryParams['removeAlias'] = ObjectSerializer::toQueryValue($remove_alias);
        }

        // path params
        if ($intermediate_path !== null) {
            $resourcePath = str_replace(
                '{' . 'intermediatePath' . '}',
                ObjectSerializer::toPathValue($intermediate_path),
                $resourcePath
            );
        }
        // path params
        if ($authorizable_id !== null) {
            $resourcePath = str_replace(
                '{' . 'authorizableId' . '}',
                ObjectSerializer::toPathValue($authorizable_id),
                $resourcePath
            );
        }

        // form params
        if ($cert_chain !== null) {
            $multipart = true;
            $formParams['cert-chain'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($cert_chain), 'rb');
        }
        // form params
        if ($pk !== null) {
            $multipart = true;
            $formParams['pk'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($pk), 'rb');
        }
        // form params
        if ($key_store !== null) {
            $multipart = true;
            $formParams['keyStore'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($key_store), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postAuthorizables
     *
     * @param  string $authorizable_id authorizable_id (required)
     * @param  string $intermediate_path intermediate_path (required)
     * @param  string $create_user create_user (optional)
     * @param  string $create_group create_group (optional)
     * @param  string $reppassword reppassword (optional)
     * @param  string $profilegiven_name profilegiven_name (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function postAuthorizables($authorizable_id, $intermediate_path, $create_user = null, $create_group = null, $reppassword = null, $profilegiven_name = null)
    {
        list($response) = $this->postAuthorizablesWithHttpInfo($authorizable_id, $intermediate_path, $create_user, $create_group, $reppassword, $profilegiven_name);
        return $response;
    }

    /**
     * Operation postAuthorizablesWithHttpInfo
     *
     * @param  string $authorizable_id (required)
     * @param  string $intermediate_path (required)
     * @param  string $create_user (optional)
     * @param  string $create_group (optional)
     * @param  string $reppassword (optional)
     * @param  string $profilegiven_name (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function postAuthorizablesWithHttpInfo($authorizable_id, $intermediate_path, $create_user = null, $create_group = null, $reppassword = null, $profilegiven_name = null)
    {
        $request = $this->postAuthorizablesRequest($authorizable_id, $intermediate_path, $create_user, $create_group, $reppassword, $profilegiven_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                default:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postAuthorizablesAsync
     *
     * 
     *
     * @param  string $authorizable_id (required)
     * @param  string $intermediate_path (required)
     * @param  string $create_user (optional)
     * @param  string $create_group (optional)
     * @param  string $reppassword (optional)
     * @param  string $profilegiven_name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAuthorizablesAsync($authorizable_id, $intermediate_path, $create_user = null, $create_group = null, $reppassword = null, $profilegiven_name = null)
    {
        return $this->postAuthorizablesAsyncWithHttpInfo($authorizable_id, $intermediate_path, $create_user, $create_group, $reppassword, $profilegiven_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postAuthorizablesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $authorizable_id (required)
     * @param  string $intermediate_path (required)
     * @param  string $create_user (optional)
     * @param  string $create_group (optional)
     * @param  string $reppassword (optional)
     * @param  string $profilegiven_name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAuthorizablesAsyncWithHttpInfo($authorizable_id, $intermediate_path, $create_user = null, $create_group = null, $reppassword = null, $profilegiven_name = null)
    {
        $returnType = 'string';
        $request = $this->postAuthorizablesRequest($authorizable_id, $intermediate_path, $create_user, $create_group, $reppassword, $profilegiven_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postAuthorizables'
     *
     * @param  string $authorizable_id (required)
     * @param  string $intermediate_path (required)
     * @param  string $create_user (optional)
     * @param  string $create_group (optional)
     * @param  string $reppassword (optional)
     * @param  string $profilegiven_name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postAuthorizablesRequest($authorizable_id, $intermediate_path, $create_user = null, $create_group = null, $reppassword = null, $profilegiven_name = null)
    {
        // verify the required parameter 'authorizable_id' is set
        if ($authorizable_id === null || (is_array($authorizable_id) && count($authorizable_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorizable_id when calling postAuthorizables'
            );
        }
        // verify the required parameter 'intermediate_path' is set
        if ($intermediate_path === null || (is_array($intermediate_path) && count($intermediate_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $intermediate_path when calling postAuthorizables'
            );
        }

        $resourcePath = '/libs/granite/security/post/authorizables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($authorizable_id !== null) {
            $queryParams['authorizableId'] = ObjectSerializer::toQueryValue($authorizable_id);
        }
        // query params
        if ($intermediate_path !== null) {
            $queryParams['intermediatePath'] = ObjectSerializer::toQueryValue($intermediate_path);
        }
        // query params
        if ($create_user !== null) {
            $queryParams['createUser'] = ObjectSerializer::toQueryValue($create_user);
        }
        // query params
        if ($create_group !== null) {
            $queryParams['createGroup'] = ObjectSerializer::toQueryValue($create_group);
        }
        // query params
        if ($reppassword !== null) {
            $queryParams['rep:password'] = ObjectSerializer::toQueryValue($reppassword);
        }
        // query params
        if ($profilegiven_name !== null) {
            $queryParams['profile/givenName'] = ObjectSerializer::toQueryValue($profilegiven_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postConfigAdobeGraniteSamlAuthenticationHandler
     *
     * @param  string $key_store_password key_store_password (optional)
     * @param  string $key_store_password_type_hint key_store_password_type_hint (optional)
     * @param  int $service_ranking service_ranking (optional)
     * @param  string $service_ranking_type_hint service_ranking_type_hint (optional)
     * @param  bool $idp_http_redirect idp_http_redirect (optional)
     * @param  string $idp_http_redirect_type_hint idp_http_redirect_type_hint (optional)
     * @param  bool $create_user create_user (optional)
     * @param  string $create_user_type_hint create_user_type_hint (optional)
     * @param  string $default_redirect_url default_redirect_url (optional)
     * @param  string $default_redirect_url_type_hint default_redirect_url_type_hint (optional)
     * @param  string $user_id_attribute user_id_attribute (optional)
     * @param  string $user_id_attribute_type_hint user_id_attribute_type_hint (optional)
     * @param  string[] $default_groups default_groups (optional)
     * @param  string $default_groups_type_hint default_groups_type_hint (optional)
     * @param  string $idp_cert_alias idp_cert_alias (optional)
     * @param  string $idp_cert_alias_type_hint idp_cert_alias_type_hint (optional)
     * @param  bool $add_group_memberships add_group_memberships (optional)
     * @param  string $add_group_memberships_type_hint add_group_memberships_type_hint (optional)
     * @param  string[] $path path (optional)
     * @param  string $path_type_hint path_type_hint (optional)
     * @param  string[] $synchronize_attributes synchronize_attributes (optional)
     * @param  string $synchronize_attributes_type_hint synchronize_attributes_type_hint (optional)
     * @param  int $clock_tolerance clock_tolerance (optional)
     * @param  string $clock_tolerance_type_hint clock_tolerance_type_hint (optional)
     * @param  string $group_membership_attribute group_membership_attribute (optional)
     * @param  string $group_membership_attribute_type_hint group_membership_attribute_type_hint (optional)
     * @param  string $idp_url idp_url (optional)
     * @param  string $idp_url_type_hint idp_url_type_hint (optional)
     * @param  string $logout_url logout_url (optional)
     * @param  string $logout_url_type_hint logout_url_type_hint (optional)
     * @param  string $service_provider_entity_id service_provider_entity_id (optional)
     * @param  string $service_provider_entity_id_type_hint service_provider_entity_id_type_hint (optional)
     * @param  string $assertion_consumer_service_url assertion_consumer_service_url (optional)
     * @param  string $assertion_consumer_service_url_type_hint assertion_consumer_service_url_type_hint (optional)
     * @param  bool $handle_logout handle_logout (optional)
     * @param  string $handle_logout_type_hint handle_logout_type_hint (optional)
     * @param  string $sp_private_key_alias sp_private_key_alias (optional)
     * @param  string $sp_private_key_alias_type_hint sp_private_key_alias_type_hint (optional)
     * @param  bool $use_encryption use_encryption (optional)
     * @param  string $use_encryption_type_hint use_encryption_type_hint (optional)
     * @param  string $name_id_format name_id_format (optional)
     * @param  string $name_id_format_type_hint name_id_format_type_hint (optional)
     * @param  string $digest_method digest_method (optional)
     * @param  string $digest_method_type_hint digest_method_type_hint (optional)
     * @param  string $signature_method signature_method (optional)
     * @param  string $signature_method_type_hint signature_method_type_hint (optional)
     * @param  string $user_intermediate_path user_intermediate_path (optional)
     * @param  string $user_intermediate_path_type_hint user_intermediate_path_type_hint (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postConfigAdobeGraniteSamlAuthenticationHandler($key_store_password = null, $key_store_password_type_hint = null, $service_ranking = null, $service_ranking_type_hint = null, $idp_http_redirect = null, $idp_http_redirect_type_hint = null, $create_user = null, $create_user_type_hint = null, $default_redirect_url = null, $default_redirect_url_type_hint = null, $user_id_attribute = null, $user_id_attribute_type_hint = null, $default_groups = null, $default_groups_type_hint = null, $idp_cert_alias = null, $idp_cert_alias_type_hint = null, $add_group_memberships = null, $add_group_memberships_type_hint = null, $path = null, $path_type_hint = null, $synchronize_attributes = null, $synchronize_attributes_type_hint = null, $clock_tolerance = null, $clock_tolerance_type_hint = null, $group_membership_attribute = null, $group_membership_attribute_type_hint = null, $idp_url = null, $idp_url_type_hint = null, $logout_url = null, $logout_url_type_hint = null, $service_provider_entity_id = null, $service_provider_entity_id_type_hint = null, $assertion_consumer_service_url = null, $assertion_consumer_service_url_type_hint = null, $handle_logout = null, $handle_logout_type_hint = null, $sp_private_key_alias = null, $sp_private_key_alias_type_hint = null, $use_encryption = null, $use_encryption_type_hint = null, $name_id_format = null, $name_id_format_type_hint = null, $digest_method = null, $digest_method_type_hint = null, $signature_method = null, $signature_method_type_hint = null, $user_intermediate_path = null, $user_intermediate_path_type_hint = null)
    {
        $this->postConfigAdobeGraniteSamlAuthenticationHandlerWithHttpInfo($key_store_password, $key_store_password_type_hint, $service_ranking, $service_ranking_type_hint, $idp_http_redirect, $idp_http_redirect_type_hint, $create_user, $create_user_type_hint, $default_redirect_url, $default_redirect_url_type_hint, $user_id_attribute, $user_id_attribute_type_hint, $default_groups, $default_groups_type_hint, $idp_cert_alias, $idp_cert_alias_type_hint, $add_group_memberships, $add_group_memberships_type_hint, $path, $path_type_hint, $synchronize_attributes, $synchronize_attributes_type_hint, $clock_tolerance, $clock_tolerance_type_hint, $group_membership_attribute, $group_membership_attribute_type_hint, $idp_url, $idp_url_type_hint, $logout_url, $logout_url_type_hint, $service_provider_entity_id, $service_provider_entity_id_type_hint, $assertion_consumer_service_url, $assertion_consumer_service_url_type_hint, $handle_logout, $handle_logout_type_hint, $sp_private_key_alias, $sp_private_key_alias_type_hint, $use_encryption, $use_encryption_type_hint, $name_id_format, $name_id_format_type_hint, $digest_method, $digest_method_type_hint, $signature_method, $signature_method_type_hint, $user_intermediate_path, $user_intermediate_path_type_hint);
    }

    /**
     * Operation postConfigAdobeGraniteSamlAuthenticationHandlerWithHttpInfo
     *
     * @param  string $key_store_password (optional)
     * @param  string $key_store_password_type_hint (optional)
     * @param  int $service_ranking (optional)
     * @param  string $service_ranking_type_hint (optional)
     * @param  bool $idp_http_redirect (optional)
     * @param  string $idp_http_redirect_type_hint (optional)
     * @param  bool $create_user (optional)
     * @param  string $create_user_type_hint (optional)
     * @param  string $default_redirect_url (optional)
     * @param  string $default_redirect_url_type_hint (optional)
     * @param  string $user_id_attribute (optional)
     * @param  string $user_id_attribute_type_hint (optional)
     * @param  string[] $default_groups (optional)
     * @param  string $default_groups_type_hint (optional)
     * @param  string $idp_cert_alias (optional)
     * @param  string $idp_cert_alias_type_hint (optional)
     * @param  bool $add_group_memberships (optional)
     * @param  string $add_group_memberships_type_hint (optional)
     * @param  string[] $path (optional)
     * @param  string $path_type_hint (optional)
     * @param  string[] $synchronize_attributes (optional)
     * @param  string $synchronize_attributes_type_hint (optional)
     * @param  int $clock_tolerance (optional)
     * @param  string $clock_tolerance_type_hint (optional)
     * @param  string $group_membership_attribute (optional)
     * @param  string $group_membership_attribute_type_hint (optional)
     * @param  string $idp_url (optional)
     * @param  string $idp_url_type_hint (optional)
     * @param  string $logout_url (optional)
     * @param  string $logout_url_type_hint (optional)
     * @param  string $service_provider_entity_id (optional)
     * @param  string $service_provider_entity_id_type_hint (optional)
     * @param  string $assertion_consumer_service_url (optional)
     * @param  string $assertion_consumer_service_url_type_hint (optional)
     * @param  bool $handle_logout (optional)
     * @param  string $handle_logout_type_hint (optional)
     * @param  string $sp_private_key_alias (optional)
     * @param  string $sp_private_key_alias_type_hint (optional)
     * @param  bool $use_encryption (optional)
     * @param  string $use_encryption_type_hint (optional)
     * @param  string $name_id_format (optional)
     * @param  string $name_id_format_type_hint (optional)
     * @param  string $digest_method (optional)
     * @param  string $digest_method_type_hint (optional)
     * @param  string $signature_method (optional)
     * @param  string $signature_method_type_hint (optional)
     * @param  string $user_intermediate_path (optional)
     * @param  string $user_intermediate_path_type_hint (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postConfigAdobeGraniteSamlAuthenticationHandlerWithHttpInfo($key_store_password = null, $key_store_password_type_hint = null, $service_ranking = null, $service_ranking_type_hint = null, $idp_http_redirect = null, $idp_http_redirect_type_hint = null, $create_user = null, $create_user_type_hint = null, $default_redirect_url = null, $default_redirect_url_type_hint = null, $user_id_attribute = null, $user_id_attribute_type_hint = null, $default_groups = null, $default_groups_type_hint = null, $idp_cert_alias = null, $idp_cert_alias_type_hint = null, $add_group_memberships = null, $add_group_memberships_type_hint = null, $path = null, $path_type_hint = null, $synchronize_attributes = null, $synchronize_attributes_type_hint = null, $clock_tolerance = null, $clock_tolerance_type_hint = null, $group_membership_attribute = null, $group_membership_attribute_type_hint = null, $idp_url = null, $idp_url_type_hint = null, $logout_url = null, $logout_url_type_hint = null, $service_provider_entity_id = null, $service_provider_entity_id_type_hint = null, $assertion_consumer_service_url = null, $assertion_consumer_service_url_type_hint = null, $handle_logout = null, $handle_logout_type_hint = null, $sp_private_key_alias = null, $sp_private_key_alias_type_hint = null, $use_encryption = null, $use_encryption_type_hint = null, $name_id_format = null, $name_id_format_type_hint = null, $digest_method = null, $digest_method_type_hint = null, $signature_method = null, $signature_method_type_hint = null, $user_intermediate_path = null, $user_intermediate_path_type_hint = null)
    {
        $request = $this->postConfigAdobeGraniteSamlAuthenticationHandlerRequest($key_store_password, $key_store_password_type_hint, $service_ranking, $service_ranking_type_hint, $idp_http_redirect, $idp_http_redirect_type_hint, $create_user, $create_user_type_hint, $default_redirect_url, $default_redirect_url_type_hint, $user_id_attribute, $user_id_attribute_type_hint, $default_groups, $default_groups_type_hint, $idp_cert_alias, $idp_cert_alias_type_hint, $add_group_memberships, $add_group_memberships_type_hint, $path, $path_type_hint, $synchronize_attributes, $synchronize_attributes_type_hint, $clock_tolerance, $clock_tolerance_type_hint, $group_membership_attribute, $group_membership_attribute_type_hint, $idp_url, $idp_url_type_hint, $logout_url, $logout_url_type_hint, $service_provider_entity_id, $service_provider_entity_id_type_hint, $assertion_consumer_service_url, $assertion_consumer_service_url_type_hint, $handle_logout, $handle_logout_type_hint, $sp_private_key_alias, $sp_private_key_alias_type_hint, $use_encryption, $use_encryption_type_hint, $name_id_format, $name_id_format_type_hint, $digest_method, $digest_method_type_hint, $signature_method, $signature_method_type_hint, $user_intermediate_path, $user_intermediate_path_type_hint);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postConfigAdobeGraniteSamlAuthenticationHandlerAsync
     *
     * 
     *
     * @param  string $key_store_password (optional)
     * @param  string $key_store_password_type_hint (optional)
     * @param  int $service_ranking (optional)
     * @param  string $service_ranking_type_hint (optional)
     * @param  bool $idp_http_redirect (optional)
     * @param  string $idp_http_redirect_type_hint (optional)
     * @param  bool $create_user (optional)
     * @param  string $create_user_type_hint (optional)
     * @param  string $default_redirect_url (optional)
     * @param  string $default_redirect_url_type_hint (optional)
     * @param  string $user_id_attribute (optional)
     * @param  string $user_id_attribute_type_hint (optional)
     * @param  string[] $default_groups (optional)
     * @param  string $default_groups_type_hint (optional)
     * @param  string $idp_cert_alias (optional)
     * @param  string $idp_cert_alias_type_hint (optional)
     * @param  bool $add_group_memberships (optional)
     * @param  string $add_group_memberships_type_hint (optional)
     * @param  string[] $path (optional)
     * @param  string $path_type_hint (optional)
     * @param  string[] $synchronize_attributes (optional)
     * @param  string $synchronize_attributes_type_hint (optional)
     * @param  int $clock_tolerance (optional)
     * @param  string $clock_tolerance_type_hint (optional)
     * @param  string $group_membership_attribute (optional)
     * @param  string $group_membership_attribute_type_hint (optional)
     * @param  string $idp_url (optional)
     * @param  string $idp_url_type_hint (optional)
     * @param  string $logout_url (optional)
     * @param  string $logout_url_type_hint (optional)
     * @param  string $service_provider_entity_id (optional)
     * @param  string $service_provider_entity_id_type_hint (optional)
     * @param  string $assertion_consumer_service_url (optional)
     * @param  string $assertion_consumer_service_url_type_hint (optional)
     * @param  bool $handle_logout (optional)
     * @param  string $handle_logout_type_hint (optional)
     * @param  string $sp_private_key_alias (optional)
     * @param  string $sp_private_key_alias_type_hint (optional)
     * @param  bool $use_encryption (optional)
     * @param  string $use_encryption_type_hint (optional)
     * @param  string $name_id_format (optional)
     * @param  string $name_id_format_type_hint (optional)
     * @param  string $digest_method (optional)
     * @param  string $digest_method_type_hint (optional)
     * @param  string $signature_method (optional)
     * @param  string $signature_method_type_hint (optional)
     * @param  string $user_intermediate_path (optional)
     * @param  string $user_intermediate_path_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postConfigAdobeGraniteSamlAuthenticationHandlerAsync($key_store_password = null, $key_store_password_type_hint = null, $service_ranking = null, $service_ranking_type_hint = null, $idp_http_redirect = null, $idp_http_redirect_type_hint = null, $create_user = null, $create_user_type_hint = null, $default_redirect_url = null, $default_redirect_url_type_hint = null, $user_id_attribute = null, $user_id_attribute_type_hint = null, $default_groups = null, $default_groups_type_hint = null, $idp_cert_alias = null, $idp_cert_alias_type_hint = null, $add_group_memberships = null, $add_group_memberships_type_hint = null, $path = null, $path_type_hint = null, $synchronize_attributes = null, $synchronize_attributes_type_hint = null, $clock_tolerance = null, $clock_tolerance_type_hint = null, $group_membership_attribute = null, $group_membership_attribute_type_hint = null, $idp_url = null, $idp_url_type_hint = null, $logout_url = null, $logout_url_type_hint = null, $service_provider_entity_id = null, $service_provider_entity_id_type_hint = null, $assertion_consumer_service_url = null, $assertion_consumer_service_url_type_hint = null, $handle_logout = null, $handle_logout_type_hint = null, $sp_private_key_alias = null, $sp_private_key_alias_type_hint = null, $use_encryption = null, $use_encryption_type_hint = null, $name_id_format = null, $name_id_format_type_hint = null, $digest_method = null, $digest_method_type_hint = null, $signature_method = null, $signature_method_type_hint = null, $user_intermediate_path = null, $user_intermediate_path_type_hint = null)
    {
        return $this->postConfigAdobeGraniteSamlAuthenticationHandlerAsyncWithHttpInfo($key_store_password, $key_store_password_type_hint, $service_ranking, $service_ranking_type_hint, $idp_http_redirect, $idp_http_redirect_type_hint, $create_user, $create_user_type_hint, $default_redirect_url, $default_redirect_url_type_hint, $user_id_attribute, $user_id_attribute_type_hint, $default_groups, $default_groups_type_hint, $idp_cert_alias, $idp_cert_alias_type_hint, $add_group_memberships, $add_group_memberships_type_hint, $path, $path_type_hint, $synchronize_attributes, $synchronize_attributes_type_hint, $clock_tolerance, $clock_tolerance_type_hint, $group_membership_attribute, $group_membership_attribute_type_hint, $idp_url, $idp_url_type_hint, $logout_url, $logout_url_type_hint, $service_provider_entity_id, $service_provider_entity_id_type_hint, $assertion_consumer_service_url, $assertion_consumer_service_url_type_hint, $handle_logout, $handle_logout_type_hint, $sp_private_key_alias, $sp_private_key_alias_type_hint, $use_encryption, $use_encryption_type_hint, $name_id_format, $name_id_format_type_hint, $digest_method, $digest_method_type_hint, $signature_method, $signature_method_type_hint, $user_intermediate_path, $user_intermediate_path_type_hint)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postConfigAdobeGraniteSamlAuthenticationHandlerAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $key_store_password (optional)
     * @param  string $key_store_password_type_hint (optional)
     * @param  int $service_ranking (optional)
     * @param  string $service_ranking_type_hint (optional)
     * @param  bool $idp_http_redirect (optional)
     * @param  string $idp_http_redirect_type_hint (optional)
     * @param  bool $create_user (optional)
     * @param  string $create_user_type_hint (optional)
     * @param  string $default_redirect_url (optional)
     * @param  string $default_redirect_url_type_hint (optional)
     * @param  string $user_id_attribute (optional)
     * @param  string $user_id_attribute_type_hint (optional)
     * @param  string[] $default_groups (optional)
     * @param  string $default_groups_type_hint (optional)
     * @param  string $idp_cert_alias (optional)
     * @param  string $idp_cert_alias_type_hint (optional)
     * @param  bool $add_group_memberships (optional)
     * @param  string $add_group_memberships_type_hint (optional)
     * @param  string[] $path (optional)
     * @param  string $path_type_hint (optional)
     * @param  string[] $synchronize_attributes (optional)
     * @param  string $synchronize_attributes_type_hint (optional)
     * @param  int $clock_tolerance (optional)
     * @param  string $clock_tolerance_type_hint (optional)
     * @param  string $group_membership_attribute (optional)
     * @param  string $group_membership_attribute_type_hint (optional)
     * @param  string $idp_url (optional)
     * @param  string $idp_url_type_hint (optional)
     * @param  string $logout_url (optional)
     * @param  string $logout_url_type_hint (optional)
     * @param  string $service_provider_entity_id (optional)
     * @param  string $service_provider_entity_id_type_hint (optional)
     * @param  string $assertion_consumer_service_url (optional)
     * @param  string $assertion_consumer_service_url_type_hint (optional)
     * @param  bool $handle_logout (optional)
     * @param  string $handle_logout_type_hint (optional)
     * @param  string $sp_private_key_alias (optional)
     * @param  string $sp_private_key_alias_type_hint (optional)
     * @param  bool $use_encryption (optional)
     * @param  string $use_encryption_type_hint (optional)
     * @param  string $name_id_format (optional)
     * @param  string $name_id_format_type_hint (optional)
     * @param  string $digest_method (optional)
     * @param  string $digest_method_type_hint (optional)
     * @param  string $signature_method (optional)
     * @param  string $signature_method_type_hint (optional)
     * @param  string $user_intermediate_path (optional)
     * @param  string $user_intermediate_path_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postConfigAdobeGraniteSamlAuthenticationHandlerAsyncWithHttpInfo($key_store_password = null, $key_store_password_type_hint = null, $service_ranking = null, $service_ranking_type_hint = null, $idp_http_redirect = null, $idp_http_redirect_type_hint = null, $create_user = null, $create_user_type_hint = null, $default_redirect_url = null, $default_redirect_url_type_hint = null, $user_id_attribute = null, $user_id_attribute_type_hint = null, $default_groups = null, $default_groups_type_hint = null, $idp_cert_alias = null, $idp_cert_alias_type_hint = null, $add_group_memberships = null, $add_group_memberships_type_hint = null, $path = null, $path_type_hint = null, $synchronize_attributes = null, $synchronize_attributes_type_hint = null, $clock_tolerance = null, $clock_tolerance_type_hint = null, $group_membership_attribute = null, $group_membership_attribute_type_hint = null, $idp_url = null, $idp_url_type_hint = null, $logout_url = null, $logout_url_type_hint = null, $service_provider_entity_id = null, $service_provider_entity_id_type_hint = null, $assertion_consumer_service_url = null, $assertion_consumer_service_url_type_hint = null, $handle_logout = null, $handle_logout_type_hint = null, $sp_private_key_alias = null, $sp_private_key_alias_type_hint = null, $use_encryption = null, $use_encryption_type_hint = null, $name_id_format = null, $name_id_format_type_hint = null, $digest_method = null, $digest_method_type_hint = null, $signature_method = null, $signature_method_type_hint = null, $user_intermediate_path = null, $user_intermediate_path_type_hint = null)
    {
        $returnType = '';
        $request = $this->postConfigAdobeGraniteSamlAuthenticationHandlerRequest($key_store_password, $key_store_password_type_hint, $service_ranking, $service_ranking_type_hint, $idp_http_redirect, $idp_http_redirect_type_hint, $create_user, $create_user_type_hint, $default_redirect_url, $default_redirect_url_type_hint, $user_id_attribute, $user_id_attribute_type_hint, $default_groups, $default_groups_type_hint, $idp_cert_alias, $idp_cert_alias_type_hint, $add_group_memberships, $add_group_memberships_type_hint, $path, $path_type_hint, $synchronize_attributes, $synchronize_attributes_type_hint, $clock_tolerance, $clock_tolerance_type_hint, $group_membership_attribute, $group_membership_attribute_type_hint, $idp_url, $idp_url_type_hint, $logout_url, $logout_url_type_hint, $service_provider_entity_id, $service_provider_entity_id_type_hint, $assertion_consumer_service_url, $assertion_consumer_service_url_type_hint, $handle_logout, $handle_logout_type_hint, $sp_private_key_alias, $sp_private_key_alias_type_hint, $use_encryption, $use_encryption_type_hint, $name_id_format, $name_id_format_type_hint, $digest_method, $digest_method_type_hint, $signature_method, $signature_method_type_hint, $user_intermediate_path, $user_intermediate_path_type_hint);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postConfigAdobeGraniteSamlAuthenticationHandler'
     *
     * @param  string $key_store_password (optional)
     * @param  string $key_store_password_type_hint (optional)
     * @param  int $service_ranking (optional)
     * @param  string $service_ranking_type_hint (optional)
     * @param  bool $idp_http_redirect (optional)
     * @param  string $idp_http_redirect_type_hint (optional)
     * @param  bool $create_user (optional)
     * @param  string $create_user_type_hint (optional)
     * @param  string $default_redirect_url (optional)
     * @param  string $default_redirect_url_type_hint (optional)
     * @param  string $user_id_attribute (optional)
     * @param  string $user_id_attribute_type_hint (optional)
     * @param  string[] $default_groups (optional)
     * @param  string $default_groups_type_hint (optional)
     * @param  string $idp_cert_alias (optional)
     * @param  string $idp_cert_alias_type_hint (optional)
     * @param  bool $add_group_memberships (optional)
     * @param  string $add_group_memberships_type_hint (optional)
     * @param  string[] $path (optional)
     * @param  string $path_type_hint (optional)
     * @param  string[] $synchronize_attributes (optional)
     * @param  string $synchronize_attributes_type_hint (optional)
     * @param  int $clock_tolerance (optional)
     * @param  string $clock_tolerance_type_hint (optional)
     * @param  string $group_membership_attribute (optional)
     * @param  string $group_membership_attribute_type_hint (optional)
     * @param  string $idp_url (optional)
     * @param  string $idp_url_type_hint (optional)
     * @param  string $logout_url (optional)
     * @param  string $logout_url_type_hint (optional)
     * @param  string $service_provider_entity_id (optional)
     * @param  string $service_provider_entity_id_type_hint (optional)
     * @param  string $assertion_consumer_service_url (optional)
     * @param  string $assertion_consumer_service_url_type_hint (optional)
     * @param  bool $handle_logout (optional)
     * @param  string $handle_logout_type_hint (optional)
     * @param  string $sp_private_key_alias (optional)
     * @param  string $sp_private_key_alias_type_hint (optional)
     * @param  bool $use_encryption (optional)
     * @param  string $use_encryption_type_hint (optional)
     * @param  string $name_id_format (optional)
     * @param  string $name_id_format_type_hint (optional)
     * @param  string $digest_method (optional)
     * @param  string $digest_method_type_hint (optional)
     * @param  string $signature_method (optional)
     * @param  string $signature_method_type_hint (optional)
     * @param  string $user_intermediate_path (optional)
     * @param  string $user_intermediate_path_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postConfigAdobeGraniteSamlAuthenticationHandlerRequest($key_store_password = null, $key_store_password_type_hint = null, $service_ranking = null, $service_ranking_type_hint = null, $idp_http_redirect = null, $idp_http_redirect_type_hint = null, $create_user = null, $create_user_type_hint = null, $default_redirect_url = null, $default_redirect_url_type_hint = null, $user_id_attribute = null, $user_id_attribute_type_hint = null, $default_groups = null, $default_groups_type_hint = null, $idp_cert_alias = null, $idp_cert_alias_type_hint = null, $add_group_memberships = null, $add_group_memberships_type_hint = null, $path = null, $path_type_hint = null, $synchronize_attributes = null, $synchronize_attributes_type_hint = null, $clock_tolerance = null, $clock_tolerance_type_hint = null, $group_membership_attribute = null, $group_membership_attribute_type_hint = null, $idp_url = null, $idp_url_type_hint = null, $logout_url = null, $logout_url_type_hint = null, $service_provider_entity_id = null, $service_provider_entity_id_type_hint = null, $assertion_consumer_service_url = null, $assertion_consumer_service_url_type_hint = null, $handle_logout = null, $handle_logout_type_hint = null, $sp_private_key_alias = null, $sp_private_key_alias_type_hint = null, $use_encryption = null, $use_encryption_type_hint = null, $name_id_format = null, $name_id_format_type_hint = null, $digest_method = null, $digest_method_type_hint = null, $signature_method = null, $signature_method_type_hint = null, $user_intermediate_path = null, $user_intermediate_path_type_hint = null)
    {

        $resourcePath = '/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($key_store_password !== null) {
            $queryParams['keyStorePassword'] = ObjectSerializer::toQueryValue($key_store_password);
        }
        // query params
        if ($key_store_password_type_hint !== null) {
            $queryParams['keyStorePassword@TypeHint'] = ObjectSerializer::toQueryValue($key_store_password_type_hint);
        }
        // query params
        if ($service_ranking !== null) {
            $queryParams['service.ranking'] = ObjectSerializer::toQueryValue($service_ranking);
        }
        // query params
        if ($service_ranking_type_hint !== null) {
            $queryParams['service.ranking@TypeHint'] = ObjectSerializer::toQueryValue($service_ranking_type_hint);
        }
        // query params
        if ($idp_http_redirect !== null) {
            $queryParams['idpHttpRedirect'] = ObjectSerializer::toQueryValue($idp_http_redirect);
        }
        // query params
        if ($idp_http_redirect_type_hint !== null) {
            $queryParams['idpHttpRedirect@TypeHint'] = ObjectSerializer::toQueryValue($idp_http_redirect_type_hint);
        }
        // query params
        if ($create_user !== null) {
            $queryParams['createUser'] = ObjectSerializer::toQueryValue($create_user);
        }
        // query params
        if ($create_user_type_hint !== null) {
            $queryParams['createUser@TypeHint'] = ObjectSerializer::toQueryValue($create_user_type_hint);
        }
        // query params
        if ($default_redirect_url !== null) {
            $queryParams['defaultRedirectUrl'] = ObjectSerializer::toQueryValue($default_redirect_url);
        }
        // query params
        if ($default_redirect_url_type_hint !== null) {
            $queryParams['defaultRedirectUrl@TypeHint'] = ObjectSerializer::toQueryValue($default_redirect_url_type_hint);
        }
        // query params
        if ($user_id_attribute !== null) {
            $queryParams['userIDAttribute'] = ObjectSerializer::toQueryValue($user_id_attribute);
        }
        // query params
        if ($user_id_attribute_type_hint !== null) {
            $queryParams['userIDAttribute@TypeHint'] = ObjectSerializer::toQueryValue($user_id_attribute_type_hint);
        }
        // query params
        if (is_array($default_groups)) {
            $default_groups = ObjectSerializer::serializeCollection($default_groups, 'multi', true);
        }
        if ($default_groups !== null) {
            $queryParams['defaultGroups'] = ObjectSerializer::toQueryValue($default_groups);
        }
        // query params
        if ($default_groups_type_hint !== null) {
            $queryParams['defaultGroups@TypeHint'] = ObjectSerializer::toQueryValue($default_groups_type_hint);
        }
        // query params
        if ($idp_cert_alias !== null) {
            $queryParams['idpCertAlias'] = ObjectSerializer::toQueryValue($idp_cert_alias);
        }
        // query params
        if ($idp_cert_alias_type_hint !== null) {
            $queryParams['idpCertAlias@TypeHint'] = ObjectSerializer::toQueryValue($idp_cert_alias_type_hint);
        }
        // query params
        if ($add_group_memberships !== null) {
            $queryParams['addGroupMemberships'] = ObjectSerializer::toQueryValue($add_group_memberships);
        }
        // query params
        if ($add_group_memberships_type_hint !== null) {
            $queryParams['addGroupMemberships@TypeHint'] = ObjectSerializer::toQueryValue($add_group_memberships_type_hint);
        }
        // query params
        if (is_array($path)) {
            $path = ObjectSerializer::serializeCollection($path, 'multi', true);
        }
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($path_type_hint !== null) {
            $queryParams['path@TypeHint'] = ObjectSerializer::toQueryValue($path_type_hint);
        }
        // query params
        if (is_array($synchronize_attributes)) {
            $synchronize_attributes = ObjectSerializer::serializeCollection($synchronize_attributes, 'multi', true);
        }
        if ($synchronize_attributes !== null) {
            $queryParams['synchronizeAttributes'] = ObjectSerializer::toQueryValue($synchronize_attributes);
        }
        // query params
        if ($synchronize_attributes_type_hint !== null) {
            $queryParams['synchronizeAttributes@TypeHint'] = ObjectSerializer::toQueryValue($synchronize_attributes_type_hint);
        }
        // query params
        if ($clock_tolerance !== null) {
            $queryParams['clockTolerance'] = ObjectSerializer::toQueryValue($clock_tolerance);
        }
        // query params
        if ($clock_tolerance_type_hint !== null) {
            $queryParams['clockTolerance@TypeHint'] = ObjectSerializer::toQueryValue($clock_tolerance_type_hint);
        }
        // query params
        if ($group_membership_attribute !== null) {
            $queryParams['groupMembershipAttribute'] = ObjectSerializer::toQueryValue($group_membership_attribute);
        }
        // query params
        if ($group_membership_attribute_type_hint !== null) {
            $queryParams['groupMembershipAttribute@TypeHint'] = ObjectSerializer::toQueryValue($group_membership_attribute_type_hint);
        }
        // query params
        if ($idp_url !== null) {
            $queryParams['idpUrl'] = ObjectSerializer::toQueryValue($idp_url);
        }
        // query params
        if ($idp_url_type_hint !== null) {
            $queryParams['idpUrl@TypeHint'] = ObjectSerializer::toQueryValue($idp_url_type_hint);
        }
        // query params
        if ($logout_url !== null) {
            $queryParams['logoutUrl'] = ObjectSerializer::toQueryValue($logout_url);
        }
        // query params
        if ($logout_url_type_hint !== null) {
            $queryParams['logoutUrl@TypeHint'] = ObjectSerializer::toQueryValue($logout_url_type_hint);
        }
        // query params
        if ($service_provider_entity_id !== null) {
            $queryParams['serviceProviderEntityId'] = ObjectSerializer::toQueryValue($service_provider_entity_id);
        }
        // query params
        if ($service_provider_entity_id_type_hint !== null) {
            $queryParams['serviceProviderEntityId@TypeHint'] = ObjectSerializer::toQueryValue($service_provider_entity_id_type_hint);
        }
        // query params
        if ($assertion_consumer_service_url !== null) {
            $queryParams['assertionConsumerServiceURL'] = ObjectSerializer::toQueryValue($assertion_consumer_service_url);
        }
        // query params
        if ($assertion_consumer_service_url_type_hint !== null) {
            $queryParams['assertionConsumerServiceURL@TypeHint'] = ObjectSerializer::toQueryValue($assertion_consumer_service_url_type_hint);
        }
        // query params
        if ($handle_logout !== null) {
            $queryParams['handleLogout'] = ObjectSerializer::toQueryValue($handle_logout);
        }
        // query params
        if ($handle_logout_type_hint !== null) {
            $queryParams['handleLogout@TypeHint'] = ObjectSerializer::toQueryValue($handle_logout_type_hint);
        }
        // query params
        if ($sp_private_key_alias !== null) {
            $queryParams['spPrivateKeyAlias'] = ObjectSerializer::toQueryValue($sp_private_key_alias);
        }
        // query params
        if ($sp_private_key_alias_type_hint !== null) {
            $queryParams['spPrivateKeyAlias@TypeHint'] = ObjectSerializer::toQueryValue($sp_private_key_alias_type_hint);
        }
        // query params
        if ($use_encryption !== null) {
            $queryParams['useEncryption'] = ObjectSerializer::toQueryValue($use_encryption);
        }
        // query params
        if ($use_encryption_type_hint !== null) {
            $queryParams['useEncryption@TypeHint'] = ObjectSerializer::toQueryValue($use_encryption_type_hint);
        }
        // query params
        if ($name_id_format !== null) {
            $queryParams['nameIdFormat'] = ObjectSerializer::toQueryValue($name_id_format);
        }
        // query params
        if ($name_id_format_type_hint !== null) {
            $queryParams['nameIdFormat@TypeHint'] = ObjectSerializer::toQueryValue($name_id_format_type_hint);
        }
        // query params
        if ($digest_method !== null) {
            $queryParams['digestMethod'] = ObjectSerializer::toQueryValue($digest_method);
        }
        // query params
        if ($digest_method_type_hint !== null) {
            $queryParams['digestMethod@TypeHint'] = ObjectSerializer::toQueryValue($digest_method_type_hint);
        }
        // query params
        if ($signature_method !== null) {
            $queryParams['signatureMethod'] = ObjectSerializer::toQueryValue($signature_method);
        }
        // query params
        if ($signature_method_type_hint !== null) {
            $queryParams['signatureMethod@TypeHint'] = ObjectSerializer::toQueryValue($signature_method_type_hint);
        }
        // query params
        if ($user_intermediate_path !== null) {
            $queryParams['userIntermediatePath'] = ObjectSerializer::toQueryValue($user_intermediate_path);
        }
        // query params
        if ($user_intermediate_path_type_hint !== null) {
            $queryParams['userIntermediatePath@TypeHint'] = ObjectSerializer::toQueryValue($user_intermediate_path_type_hint);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postConfigApacheFelixJettyBasedHttpService
     *
     * @param  bool $org_apache_felix_https_nio org_apache_felix_https_nio (optional)
     * @param  string $org_apache_felix_https_nio_type_hint org_apache_felix_https_nio_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore org_apache_felix_https_keystore (optional)
     * @param  string $org_apache_felix_https_keystore_type_hint org_apache_felix_https_keystore_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_password org_apache_felix_https_keystore_password (optional)
     * @param  string $org_apache_felix_https_keystore_password_type_hint org_apache_felix_https_keystore_password_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_key org_apache_felix_https_keystore_key (optional)
     * @param  string $org_apache_felix_https_keystore_key_type_hint org_apache_felix_https_keystore_key_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_key_password org_apache_felix_https_keystore_key_password (optional)
     * @param  string $org_apache_felix_https_keystore_key_password_type_hint org_apache_felix_https_keystore_key_password_type_hint (optional)
     * @param  string $org_apache_felix_https_truststore org_apache_felix_https_truststore (optional)
     * @param  string $org_apache_felix_https_truststore_type_hint org_apache_felix_https_truststore_type_hint (optional)
     * @param  string $org_apache_felix_https_truststore_password org_apache_felix_https_truststore_password (optional)
     * @param  string $org_apache_felix_https_truststore_password_type_hint org_apache_felix_https_truststore_password_type_hint (optional)
     * @param  string $org_apache_felix_https_clientcertificate org_apache_felix_https_clientcertificate (optional)
     * @param  string $org_apache_felix_https_clientcertificate_type_hint org_apache_felix_https_clientcertificate_type_hint (optional)
     * @param  bool $org_apache_felix_https_enable org_apache_felix_https_enable (optional)
     * @param  string $org_apache_felix_https_enable_type_hint org_apache_felix_https_enable_type_hint (optional)
     * @param  string $org_osgi_service_http_port_secure org_osgi_service_http_port_secure (optional)
     * @param  string $org_osgi_service_http_port_secure_type_hint org_osgi_service_http_port_secure_type_hint (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postConfigApacheFelixJettyBasedHttpService($org_apache_felix_https_nio = null, $org_apache_felix_https_nio_type_hint = null, $org_apache_felix_https_keystore = null, $org_apache_felix_https_keystore_type_hint = null, $org_apache_felix_https_keystore_password = null, $org_apache_felix_https_keystore_password_type_hint = null, $org_apache_felix_https_keystore_key = null, $org_apache_felix_https_keystore_key_type_hint = null, $org_apache_felix_https_keystore_key_password = null, $org_apache_felix_https_keystore_key_password_type_hint = null, $org_apache_felix_https_truststore = null, $org_apache_felix_https_truststore_type_hint = null, $org_apache_felix_https_truststore_password = null, $org_apache_felix_https_truststore_password_type_hint = null, $org_apache_felix_https_clientcertificate = null, $org_apache_felix_https_clientcertificate_type_hint = null, $org_apache_felix_https_enable = null, $org_apache_felix_https_enable_type_hint = null, $org_osgi_service_http_port_secure = null, $org_osgi_service_http_port_secure_type_hint = null)
    {
        $this->postConfigApacheFelixJettyBasedHttpServiceWithHttpInfo($org_apache_felix_https_nio, $org_apache_felix_https_nio_type_hint, $org_apache_felix_https_keystore, $org_apache_felix_https_keystore_type_hint, $org_apache_felix_https_keystore_password, $org_apache_felix_https_keystore_password_type_hint, $org_apache_felix_https_keystore_key, $org_apache_felix_https_keystore_key_type_hint, $org_apache_felix_https_keystore_key_password, $org_apache_felix_https_keystore_key_password_type_hint, $org_apache_felix_https_truststore, $org_apache_felix_https_truststore_type_hint, $org_apache_felix_https_truststore_password, $org_apache_felix_https_truststore_password_type_hint, $org_apache_felix_https_clientcertificate, $org_apache_felix_https_clientcertificate_type_hint, $org_apache_felix_https_enable, $org_apache_felix_https_enable_type_hint, $org_osgi_service_http_port_secure, $org_osgi_service_http_port_secure_type_hint);
    }

    /**
     * Operation postConfigApacheFelixJettyBasedHttpServiceWithHttpInfo
     *
     * @param  bool $org_apache_felix_https_nio (optional)
     * @param  string $org_apache_felix_https_nio_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore (optional)
     * @param  string $org_apache_felix_https_keystore_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_password (optional)
     * @param  string $org_apache_felix_https_keystore_password_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_key (optional)
     * @param  string $org_apache_felix_https_keystore_key_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_key_password (optional)
     * @param  string $org_apache_felix_https_keystore_key_password_type_hint (optional)
     * @param  string $org_apache_felix_https_truststore (optional)
     * @param  string $org_apache_felix_https_truststore_type_hint (optional)
     * @param  string $org_apache_felix_https_truststore_password (optional)
     * @param  string $org_apache_felix_https_truststore_password_type_hint (optional)
     * @param  string $org_apache_felix_https_clientcertificate (optional)
     * @param  string $org_apache_felix_https_clientcertificate_type_hint (optional)
     * @param  bool $org_apache_felix_https_enable (optional)
     * @param  string $org_apache_felix_https_enable_type_hint (optional)
     * @param  string $org_osgi_service_http_port_secure (optional)
     * @param  string $org_osgi_service_http_port_secure_type_hint (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postConfigApacheFelixJettyBasedHttpServiceWithHttpInfo($org_apache_felix_https_nio = null, $org_apache_felix_https_nio_type_hint = null, $org_apache_felix_https_keystore = null, $org_apache_felix_https_keystore_type_hint = null, $org_apache_felix_https_keystore_password = null, $org_apache_felix_https_keystore_password_type_hint = null, $org_apache_felix_https_keystore_key = null, $org_apache_felix_https_keystore_key_type_hint = null, $org_apache_felix_https_keystore_key_password = null, $org_apache_felix_https_keystore_key_password_type_hint = null, $org_apache_felix_https_truststore = null, $org_apache_felix_https_truststore_type_hint = null, $org_apache_felix_https_truststore_password = null, $org_apache_felix_https_truststore_password_type_hint = null, $org_apache_felix_https_clientcertificate = null, $org_apache_felix_https_clientcertificate_type_hint = null, $org_apache_felix_https_enable = null, $org_apache_felix_https_enable_type_hint = null, $org_osgi_service_http_port_secure = null, $org_osgi_service_http_port_secure_type_hint = null)
    {
        $request = $this->postConfigApacheFelixJettyBasedHttpServiceRequest($org_apache_felix_https_nio, $org_apache_felix_https_nio_type_hint, $org_apache_felix_https_keystore, $org_apache_felix_https_keystore_type_hint, $org_apache_felix_https_keystore_password, $org_apache_felix_https_keystore_password_type_hint, $org_apache_felix_https_keystore_key, $org_apache_felix_https_keystore_key_type_hint, $org_apache_felix_https_keystore_key_password, $org_apache_felix_https_keystore_key_password_type_hint, $org_apache_felix_https_truststore, $org_apache_felix_https_truststore_type_hint, $org_apache_felix_https_truststore_password, $org_apache_felix_https_truststore_password_type_hint, $org_apache_felix_https_clientcertificate, $org_apache_felix_https_clientcertificate_type_hint, $org_apache_felix_https_enable, $org_apache_felix_https_enable_type_hint, $org_osgi_service_http_port_secure, $org_osgi_service_http_port_secure_type_hint);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postConfigApacheFelixJettyBasedHttpServiceAsync
     *
     * 
     *
     * @param  bool $org_apache_felix_https_nio (optional)
     * @param  string $org_apache_felix_https_nio_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore (optional)
     * @param  string $org_apache_felix_https_keystore_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_password (optional)
     * @param  string $org_apache_felix_https_keystore_password_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_key (optional)
     * @param  string $org_apache_felix_https_keystore_key_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_key_password (optional)
     * @param  string $org_apache_felix_https_keystore_key_password_type_hint (optional)
     * @param  string $org_apache_felix_https_truststore (optional)
     * @param  string $org_apache_felix_https_truststore_type_hint (optional)
     * @param  string $org_apache_felix_https_truststore_password (optional)
     * @param  string $org_apache_felix_https_truststore_password_type_hint (optional)
     * @param  string $org_apache_felix_https_clientcertificate (optional)
     * @param  string $org_apache_felix_https_clientcertificate_type_hint (optional)
     * @param  bool $org_apache_felix_https_enable (optional)
     * @param  string $org_apache_felix_https_enable_type_hint (optional)
     * @param  string $org_osgi_service_http_port_secure (optional)
     * @param  string $org_osgi_service_http_port_secure_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postConfigApacheFelixJettyBasedHttpServiceAsync($org_apache_felix_https_nio = null, $org_apache_felix_https_nio_type_hint = null, $org_apache_felix_https_keystore = null, $org_apache_felix_https_keystore_type_hint = null, $org_apache_felix_https_keystore_password = null, $org_apache_felix_https_keystore_password_type_hint = null, $org_apache_felix_https_keystore_key = null, $org_apache_felix_https_keystore_key_type_hint = null, $org_apache_felix_https_keystore_key_password = null, $org_apache_felix_https_keystore_key_password_type_hint = null, $org_apache_felix_https_truststore = null, $org_apache_felix_https_truststore_type_hint = null, $org_apache_felix_https_truststore_password = null, $org_apache_felix_https_truststore_password_type_hint = null, $org_apache_felix_https_clientcertificate = null, $org_apache_felix_https_clientcertificate_type_hint = null, $org_apache_felix_https_enable = null, $org_apache_felix_https_enable_type_hint = null, $org_osgi_service_http_port_secure = null, $org_osgi_service_http_port_secure_type_hint = null)
    {
        return $this->postConfigApacheFelixJettyBasedHttpServiceAsyncWithHttpInfo($org_apache_felix_https_nio, $org_apache_felix_https_nio_type_hint, $org_apache_felix_https_keystore, $org_apache_felix_https_keystore_type_hint, $org_apache_felix_https_keystore_password, $org_apache_felix_https_keystore_password_type_hint, $org_apache_felix_https_keystore_key, $org_apache_felix_https_keystore_key_type_hint, $org_apache_felix_https_keystore_key_password, $org_apache_felix_https_keystore_key_password_type_hint, $org_apache_felix_https_truststore, $org_apache_felix_https_truststore_type_hint, $org_apache_felix_https_truststore_password, $org_apache_felix_https_truststore_password_type_hint, $org_apache_felix_https_clientcertificate, $org_apache_felix_https_clientcertificate_type_hint, $org_apache_felix_https_enable, $org_apache_felix_https_enable_type_hint, $org_osgi_service_http_port_secure, $org_osgi_service_http_port_secure_type_hint)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postConfigApacheFelixJettyBasedHttpServiceAsyncWithHttpInfo
     *
     * 
     *
     * @param  bool $org_apache_felix_https_nio (optional)
     * @param  string $org_apache_felix_https_nio_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore (optional)
     * @param  string $org_apache_felix_https_keystore_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_password (optional)
     * @param  string $org_apache_felix_https_keystore_password_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_key (optional)
     * @param  string $org_apache_felix_https_keystore_key_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_key_password (optional)
     * @param  string $org_apache_felix_https_keystore_key_password_type_hint (optional)
     * @param  string $org_apache_felix_https_truststore (optional)
     * @param  string $org_apache_felix_https_truststore_type_hint (optional)
     * @param  string $org_apache_felix_https_truststore_password (optional)
     * @param  string $org_apache_felix_https_truststore_password_type_hint (optional)
     * @param  string $org_apache_felix_https_clientcertificate (optional)
     * @param  string $org_apache_felix_https_clientcertificate_type_hint (optional)
     * @param  bool $org_apache_felix_https_enable (optional)
     * @param  string $org_apache_felix_https_enable_type_hint (optional)
     * @param  string $org_osgi_service_http_port_secure (optional)
     * @param  string $org_osgi_service_http_port_secure_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postConfigApacheFelixJettyBasedHttpServiceAsyncWithHttpInfo($org_apache_felix_https_nio = null, $org_apache_felix_https_nio_type_hint = null, $org_apache_felix_https_keystore = null, $org_apache_felix_https_keystore_type_hint = null, $org_apache_felix_https_keystore_password = null, $org_apache_felix_https_keystore_password_type_hint = null, $org_apache_felix_https_keystore_key = null, $org_apache_felix_https_keystore_key_type_hint = null, $org_apache_felix_https_keystore_key_password = null, $org_apache_felix_https_keystore_key_password_type_hint = null, $org_apache_felix_https_truststore = null, $org_apache_felix_https_truststore_type_hint = null, $org_apache_felix_https_truststore_password = null, $org_apache_felix_https_truststore_password_type_hint = null, $org_apache_felix_https_clientcertificate = null, $org_apache_felix_https_clientcertificate_type_hint = null, $org_apache_felix_https_enable = null, $org_apache_felix_https_enable_type_hint = null, $org_osgi_service_http_port_secure = null, $org_osgi_service_http_port_secure_type_hint = null)
    {
        $returnType = '';
        $request = $this->postConfigApacheFelixJettyBasedHttpServiceRequest($org_apache_felix_https_nio, $org_apache_felix_https_nio_type_hint, $org_apache_felix_https_keystore, $org_apache_felix_https_keystore_type_hint, $org_apache_felix_https_keystore_password, $org_apache_felix_https_keystore_password_type_hint, $org_apache_felix_https_keystore_key, $org_apache_felix_https_keystore_key_type_hint, $org_apache_felix_https_keystore_key_password, $org_apache_felix_https_keystore_key_password_type_hint, $org_apache_felix_https_truststore, $org_apache_felix_https_truststore_type_hint, $org_apache_felix_https_truststore_password, $org_apache_felix_https_truststore_password_type_hint, $org_apache_felix_https_clientcertificate, $org_apache_felix_https_clientcertificate_type_hint, $org_apache_felix_https_enable, $org_apache_felix_https_enable_type_hint, $org_osgi_service_http_port_secure, $org_osgi_service_http_port_secure_type_hint);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postConfigApacheFelixJettyBasedHttpService'
     *
     * @param  bool $org_apache_felix_https_nio (optional)
     * @param  string $org_apache_felix_https_nio_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore (optional)
     * @param  string $org_apache_felix_https_keystore_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_password (optional)
     * @param  string $org_apache_felix_https_keystore_password_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_key (optional)
     * @param  string $org_apache_felix_https_keystore_key_type_hint (optional)
     * @param  string $org_apache_felix_https_keystore_key_password (optional)
     * @param  string $org_apache_felix_https_keystore_key_password_type_hint (optional)
     * @param  string $org_apache_felix_https_truststore (optional)
     * @param  string $org_apache_felix_https_truststore_type_hint (optional)
     * @param  string $org_apache_felix_https_truststore_password (optional)
     * @param  string $org_apache_felix_https_truststore_password_type_hint (optional)
     * @param  string $org_apache_felix_https_clientcertificate (optional)
     * @param  string $org_apache_felix_https_clientcertificate_type_hint (optional)
     * @param  bool $org_apache_felix_https_enable (optional)
     * @param  string $org_apache_felix_https_enable_type_hint (optional)
     * @param  string $org_osgi_service_http_port_secure (optional)
     * @param  string $org_osgi_service_http_port_secure_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postConfigApacheFelixJettyBasedHttpServiceRequest($org_apache_felix_https_nio = null, $org_apache_felix_https_nio_type_hint = null, $org_apache_felix_https_keystore = null, $org_apache_felix_https_keystore_type_hint = null, $org_apache_felix_https_keystore_password = null, $org_apache_felix_https_keystore_password_type_hint = null, $org_apache_felix_https_keystore_key = null, $org_apache_felix_https_keystore_key_type_hint = null, $org_apache_felix_https_keystore_key_password = null, $org_apache_felix_https_keystore_key_password_type_hint = null, $org_apache_felix_https_truststore = null, $org_apache_felix_https_truststore_type_hint = null, $org_apache_felix_https_truststore_password = null, $org_apache_felix_https_truststore_password_type_hint = null, $org_apache_felix_https_clientcertificate = null, $org_apache_felix_https_clientcertificate_type_hint = null, $org_apache_felix_https_enable = null, $org_apache_felix_https_enable_type_hint = null, $org_osgi_service_http_port_secure = null, $org_osgi_service_http_port_secure_type_hint = null)
    {

        $resourcePath = '/apps/system/config/org.apache.felix.http';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($org_apache_felix_https_nio !== null) {
            $queryParams['org.apache.felix.https.nio'] = ObjectSerializer::toQueryValue($org_apache_felix_https_nio);
        }
        // query params
        if ($org_apache_felix_https_nio_type_hint !== null) {
            $queryParams['org.apache.felix.https.nio@TypeHint'] = ObjectSerializer::toQueryValue($org_apache_felix_https_nio_type_hint);
        }
        // query params
        if ($org_apache_felix_https_keystore !== null) {
            $queryParams['org.apache.felix.https.keystore'] = ObjectSerializer::toQueryValue($org_apache_felix_https_keystore);
        }
        // query params
        if ($org_apache_felix_https_keystore_type_hint !== null) {
            $queryParams['org.apache.felix.https.keystore@TypeHint'] = ObjectSerializer::toQueryValue($org_apache_felix_https_keystore_type_hint);
        }
        // query params
        if ($org_apache_felix_https_keystore_password !== null) {
            $queryParams['org.apache.felix.https.keystore.password'] = ObjectSerializer::toQueryValue($org_apache_felix_https_keystore_password);
        }
        // query params
        if ($org_apache_felix_https_keystore_password_type_hint !== null) {
            $queryParams['org.apache.felix.https.keystore.password@TypeHint'] = ObjectSerializer::toQueryValue($org_apache_felix_https_keystore_password_type_hint);
        }
        // query params
        if ($org_apache_felix_https_keystore_key !== null) {
            $queryParams['org.apache.felix.https.keystore.key'] = ObjectSerializer::toQueryValue($org_apache_felix_https_keystore_key);
        }
        // query params
        if ($org_apache_felix_https_keystore_key_type_hint !== null) {
            $queryParams['org.apache.felix.https.keystore.key@TypeHint'] = ObjectSerializer::toQueryValue($org_apache_felix_https_keystore_key_type_hint);
        }
        // query params
        if ($org_apache_felix_https_keystore_key_password !== null) {
            $queryParams['org.apache.felix.https.keystore.key.password'] = ObjectSerializer::toQueryValue($org_apache_felix_https_keystore_key_password);
        }
        // query params
        if ($org_apache_felix_https_keystore_key_password_type_hint !== null) {
            $queryParams['org.apache.felix.https.keystore.key.password@TypeHint'] = ObjectSerializer::toQueryValue($org_apache_felix_https_keystore_key_password_type_hint);
        }
        // query params
        if ($org_apache_felix_https_truststore !== null) {
            $queryParams['org.apache.felix.https.truststore'] = ObjectSerializer::toQueryValue($org_apache_felix_https_truststore);
        }
        // query params
        if ($org_apache_felix_https_truststore_type_hint !== null) {
            $queryParams['org.apache.felix.https.truststore@TypeHint'] = ObjectSerializer::toQueryValue($org_apache_felix_https_truststore_type_hint);
        }
        // query params
        if ($org_apache_felix_https_truststore_password !== null) {
            $queryParams['org.apache.felix.https.truststore.password'] = ObjectSerializer::toQueryValue($org_apache_felix_https_truststore_password);
        }
        // query params
        if ($org_apache_felix_https_truststore_password_type_hint !== null) {
            $queryParams['org.apache.felix.https.truststore.password@TypeHint'] = ObjectSerializer::toQueryValue($org_apache_felix_https_truststore_password_type_hint);
        }
        // query params
        if ($org_apache_felix_https_clientcertificate !== null) {
            $queryParams['org.apache.felix.https.clientcertificate'] = ObjectSerializer::toQueryValue($org_apache_felix_https_clientcertificate);
        }
        // query params
        if ($org_apache_felix_https_clientcertificate_type_hint !== null) {
            $queryParams['org.apache.felix.https.clientcertificate@TypeHint'] = ObjectSerializer::toQueryValue($org_apache_felix_https_clientcertificate_type_hint);
        }
        // query params
        if ($org_apache_felix_https_enable !== null) {
            $queryParams['org.apache.felix.https.enable'] = ObjectSerializer::toQueryValue($org_apache_felix_https_enable);
        }
        // query params
        if ($org_apache_felix_https_enable_type_hint !== null) {
            $queryParams['org.apache.felix.https.enable@TypeHint'] = ObjectSerializer::toQueryValue($org_apache_felix_https_enable_type_hint);
        }
        // query params
        if ($org_osgi_service_http_port_secure !== null) {
            $queryParams['org.osgi.service.http.port.secure'] = ObjectSerializer::toQueryValue($org_osgi_service_http_port_secure);
        }
        // query params
        if ($org_osgi_service_http_port_secure_type_hint !== null) {
            $queryParams['org.osgi.service.http.port.secure@TypeHint'] = ObjectSerializer::toQueryValue($org_osgi_service_http_port_secure_type_hint);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postConfigApacheHttpComponentsProxyConfiguration
     *
     * @param  string $proxy_host proxy_host (optional)
     * @param  string $proxy_host_type_hint proxy_host_type_hint (optional)
     * @param  int $proxy_port proxy_port (optional)
     * @param  string $proxy_port_type_hint proxy_port_type_hint (optional)
     * @param  string[] $proxy_exceptions proxy_exceptions (optional)
     * @param  string $proxy_exceptions_type_hint proxy_exceptions_type_hint (optional)
     * @param  bool $proxy_enabled proxy_enabled (optional)
     * @param  string $proxy_enabled_type_hint proxy_enabled_type_hint (optional)
     * @param  string $proxy_user proxy_user (optional)
     * @param  string $proxy_user_type_hint proxy_user_type_hint (optional)
     * @param  string $proxy_password proxy_password (optional)
     * @param  string $proxy_password_type_hint proxy_password_type_hint (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postConfigApacheHttpComponentsProxyConfiguration($proxy_host = null, $proxy_host_type_hint = null, $proxy_port = null, $proxy_port_type_hint = null, $proxy_exceptions = null, $proxy_exceptions_type_hint = null, $proxy_enabled = null, $proxy_enabled_type_hint = null, $proxy_user = null, $proxy_user_type_hint = null, $proxy_password = null, $proxy_password_type_hint = null)
    {
        $this->postConfigApacheHttpComponentsProxyConfigurationWithHttpInfo($proxy_host, $proxy_host_type_hint, $proxy_port, $proxy_port_type_hint, $proxy_exceptions, $proxy_exceptions_type_hint, $proxy_enabled, $proxy_enabled_type_hint, $proxy_user, $proxy_user_type_hint, $proxy_password, $proxy_password_type_hint);
    }

    /**
     * Operation postConfigApacheHttpComponentsProxyConfigurationWithHttpInfo
     *
     * @param  string $proxy_host (optional)
     * @param  string $proxy_host_type_hint (optional)
     * @param  int $proxy_port (optional)
     * @param  string $proxy_port_type_hint (optional)
     * @param  string[] $proxy_exceptions (optional)
     * @param  string $proxy_exceptions_type_hint (optional)
     * @param  bool $proxy_enabled (optional)
     * @param  string $proxy_enabled_type_hint (optional)
     * @param  string $proxy_user (optional)
     * @param  string $proxy_user_type_hint (optional)
     * @param  string $proxy_password (optional)
     * @param  string $proxy_password_type_hint (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postConfigApacheHttpComponentsProxyConfigurationWithHttpInfo($proxy_host = null, $proxy_host_type_hint = null, $proxy_port = null, $proxy_port_type_hint = null, $proxy_exceptions = null, $proxy_exceptions_type_hint = null, $proxy_enabled = null, $proxy_enabled_type_hint = null, $proxy_user = null, $proxy_user_type_hint = null, $proxy_password = null, $proxy_password_type_hint = null)
    {
        $request = $this->postConfigApacheHttpComponentsProxyConfigurationRequest($proxy_host, $proxy_host_type_hint, $proxy_port, $proxy_port_type_hint, $proxy_exceptions, $proxy_exceptions_type_hint, $proxy_enabled, $proxy_enabled_type_hint, $proxy_user, $proxy_user_type_hint, $proxy_password, $proxy_password_type_hint);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postConfigApacheHttpComponentsProxyConfigurationAsync
     *
     * 
     *
     * @param  string $proxy_host (optional)
     * @param  string $proxy_host_type_hint (optional)
     * @param  int $proxy_port (optional)
     * @param  string $proxy_port_type_hint (optional)
     * @param  string[] $proxy_exceptions (optional)
     * @param  string $proxy_exceptions_type_hint (optional)
     * @param  bool $proxy_enabled (optional)
     * @param  string $proxy_enabled_type_hint (optional)
     * @param  string $proxy_user (optional)
     * @param  string $proxy_user_type_hint (optional)
     * @param  string $proxy_password (optional)
     * @param  string $proxy_password_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postConfigApacheHttpComponentsProxyConfigurationAsync($proxy_host = null, $proxy_host_type_hint = null, $proxy_port = null, $proxy_port_type_hint = null, $proxy_exceptions = null, $proxy_exceptions_type_hint = null, $proxy_enabled = null, $proxy_enabled_type_hint = null, $proxy_user = null, $proxy_user_type_hint = null, $proxy_password = null, $proxy_password_type_hint = null)
    {
        return $this->postConfigApacheHttpComponentsProxyConfigurationAsyncWithHttpInfo($proxy_host, $proxy_host_type_hint, $proxy_port, $proxy_port_type_hint, $proxy_exceptions, $proxy_exceptions_type_hint, $proxy_enabled, $proxy_enabled_type_hint, $proxy_user, $proxy_user_type_hint, $proxy_password, $proxy_password_type_hint)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postConfigApacheHttpComponentsProxyConfigurationAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $proxy_host (optional)
     * @param  string $proxy_host_type_hint (optional)
     * @param  int $proxy_port (optional)
     * @param  string $proxy_port_type_hint (optional)
     * @param  string[] $proxy_exceptions (optional)
     * @param  string $proxy_exceptions_type_hint (optional)
     * @param  bool $proxy_enabled (optional)
     * @param  string $proxy_enabled_type_hint (optional)
     * @param  string $proxy_user (optional)
     * @param  string $proxy_user_type_hint (optional)
     * @param  string $proxy_password (optional)
     * @param  string $proxy_password_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postConfigApacheHttpComponentsProxyConfigurationAsyncWithHttpInfo($proxy_host = null, $proxy_host_type_hint = null, $proxy_port = null, $proxy_port_type_hint = null, $proxy_exceptions = null, $proxy_exceptions_type_hint = null, $proxy_enabled = null, $proxy_enabled_type_hint = null, $proxy_user = null, $proxy_user_type_hint = null, $proxy_password = null, $proxy_password_type_hint = null)
    {
        $returnType = '';
        $request = $this->postConfigApacheHttpComponentsProxyConfigurationRequest($proxy_host, $proxy_host_type_hint, $proxy_port, $proxy_port_type_hint, $proxy_exceptions, $proxy_exceptions_type_hint, $proxy_enabled, $proxy_enabled_type_hint, $proxy_user, $proxy_user_type_hint, $proxy_password, $proxy_password_type_hint);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postConfigApacheHttpComponentsProxyConfiguration'
     *
     * @param  string $proxy_host (optional)
     * @param  string $proxy_host_type_hint (optional)
     * @param  int $proxy_port (optional)
     * @param  string $proxy_port_type_hint (optional)
     * @param  string[] $proxy_exceptions (optional)
     * @param  string $proxy_exceptions_type_hint (optional)
     * @param  bool $proxy_enabled (optional)
     * @param  string $proxy_enabled_type_hint (optional)
     * @param  string $proxy_user (optional)
     * @param  string $proxy_user_type_hint (optional)
     * @param  string $proxy_password (optional)
     * @param  string $proxy_password_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postConfigApacheHttpComponentsProxyConfigurationRequest($proxy_host = null, $proxy_host_type_hint = null, $proxy_port = null, $proxy_port_type_hint = null, $proxy_exceptions = null, $proxy_exceptions_type_hint = null, $proxy_enabled = null, $proxy_enabled_type_hint = null, $proxy_user = null, $proxy_user_type_hint = null, $proxy_password = null, $proxy_password_type_hint = null)
    {

        $resourcePath = '/apps/system/config/org.apache.http.proxyconfigurator.config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($proxy_host !== null) {
            $queryParams['proxy.host'] = ObjectSerializer::toQueryValue($proxy_host);
        }
        // query params
        if ($proxy_host_type_hint !== null) {
            $queryParams['proxy.host@TypeHint'] = ObjectSerializer::toQueryValue($proxy_host_type_hint);
        }
        // query params
        if ($proxy_port !== null) {
            $queryParams['proxy.port'] = ObjectSerializer::toQueryValue($proxy_port);
        }
        // query params
        if ($proxy_port_type_hint !== null) {
            $queryParams['proxy.port@TypeHint'] = ObjectSerializer::toQueryValue($proxy_port_type_hint);
        }
        // query params
        if (is_array($proxy_exceptions)) {
            $proxy_exceptions = ObjectSerializer::serializeCollection($proxy_exceptions, 'multi', true);
        }
        if ($proxy_exceptions !== null) {
            $queryParams['proxy.exceptions'] = ObjectSerializer::toQueryValue($proxy_exceptions);
        }
        // query params
        if ($proxy_exceptions_type_hint !== null) {
            $queryParams['proxy.exceptions@TypeHint'] = ObjectSerializer::toQueryValue($proxy_exceptions_type_hint);
        }
        // query params
        if ($proxy_enabled !== null) {
            $queryParams['proxy.enabled'] = ObjectSerializer::toQueryValue($proxy_enabled);
        }
        // query params
        if ($proxy_enabled_type_hint !== null) {
            $queryParams['proxy.enabled@TypeHint'] = ObjectSerializer::toQueryValue($proxy_enabled_type_hint);
        }
        // query params
        if ($proxy_user !== null) {
            $queryParams['proxy.user'] = ObjectSerializer::toQueryValue($proxy_user);
        }
        // query params
        if ($proxy_user_type_hint !== null) {
            $queryParams['proxy.user@TypeHint'] = ObjectSerializer::toQueryValue($proxy_user_type_hint);
        }
        // query params
        if ($proxy_password !== null) {
            $queryParams['proxy.password'] = ObjectSerializer::toQueryValue($proxy_password);
        }
        // query params
        if ($proxy_password_type_hint !== null) {
            $queryParams['proxy.password@TypeHint'] = ObjectSerializer::toQueryValue($proxy_password_type_hint);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postConfigApacheSlingDavExServlet
     *
     * @param  string $alias alias (optional)
     * @param  string $alias_type_hint alias_type_hint (optional)
     * @param  bool $dav_create_absolute_uri dav_create_absolute_uri (optional)
     * @param  string $dav_create_absolute_uri_type_hint dav_create_absolute_uri_type_hint (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postConfigApacheSlingDavExServlet($alias = null, $alias_type_hint = null, $dav_create_absolute_uri = null, $dav_create_absolute_uri_type_hint = null)
    {
        $this->postConfigApacheSlingDavExServletWithHttpInfo($alias, $alias_type_hint, $dav_create_absolute_uri, $dav_create_absolute_uri_type_hint);
    }

    /**
     * Operation postConfigApacheSlingDavExServletWithHttpInfo
     *
     * @param  string $alias (optional)
     * @param  string $alias_type_hint (optional)
     * @param  bool $dav_create_absolute_uri (optional)
     * @param  string $dav_create_absolute_uri_type_hint (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postConfigApacheSlingDavExServletWithHttpInfo($alias = null, $alias_type_hint = null, $dav_create_absolute_uri = null, $dav_create_absolute_uri_type_hint = null)
    {
        $request = $this->postConfigApacheSlingDavExServletRequest($alias, $alias_type_hint, $dav_create_absolute_uri, $dav_create_absolute_uri_type_hint);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postConfigApacheSlingDavExServletAsync
     *
     * 
     *
     * @param  string $alias (optional)
     * @param  string $alias_type_hint (optional)
     * @param  bool $dav_create_absolute_uri (optional)
     * @param  string $dav_create_absolute_uri_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postConfigApacheSlingDavExServletAsync($alias = null, $alias_type_hint = null, $dav_create_absolute_uri = null, $dav_create_absolute_uri_type_hint = null)
    {
        return $this->postConfigApacheSlingDavExServletAsyncWithHttpInfo($alias, $alias_type_hint, $dav_create_absolute_uri, $dav_create_absolute_uri_type_hint)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postConfigApacheSlingDavExServletAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $alias (optional)
     * @param  string $alias_type_hint (optional)
     * @param  bool $dav_create_absolute_uri (optional)
     * @param  string $dav_create_absolute_uri_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postConfigApacheSlingDavExServletAsyncWithHttpInfo($alias = null, $alias_type_hint = null, $dav_create_absolute_uri = null, $dav_create_absolute_uri_type_hint = null)
    {
        $returnType = '';
        $request = $this->postConfigApacheSlingDavExServletRequest($alias, $alias_type_hint, $dav_create_absolute_uri, $dav_create_absolute_uri_type_hint);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postConfigApacheSlingDavExServlet'
     *
     * @param  string $alias (optional)
     * @param  string $alias_type_hint (optional)
     * @param  bool $dav_create_absolute_uri (optional)
     * @param  string $dav_create_absolute_uri_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postConfigApacheSlingDavExServletRequest($alias = null, $alias_type_hint = null, $dav_create_absolute_uri = null, $dav_create_absolute_uri_type_hint = null)
    {

        $resourcePath = '/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($alias !== null) {
            $queryParams['alias'] = ObjectSerializer::toQueryValue($alias);
        }
        // query params
        if ($alias_type_hint !== null) {
            $queryParams['alias@TypeHint'] = ObjectSerializer::toQueryValue($alias_type_hint);
        }
        // query params
        if ($dav_create_absolute_uri !== null) {
            $queryParams['dav.create-absolute-uri'] = ObjectSerializer::toQueryValue($dav_create_absolute_uri);
        }
        // query params
        if ($dav_create_absolute_uri_type_hint !== null) {
            $queryParams['dav.create-absolute-uri@TypeHint'] = ObjectSerializer::toQueryValue($dav_create_absolute_uri_type_hint);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postConfigApacheSlingGetServlet
     *
     * @param  string $json_maximumresults json_maximumresults (optional)
     * @param  string $json_maximumresults_type_hint json_maximumresults_type_hint (optional)
     * @param  bool $enable_html enable_html (optional)
     * @param  string $enable_html_type_hint enable_html_type_hint (optional)
     * @param  bool $enable_txt enable_txt (optional)
     * @param  string $enable_txt_type_hint enable_txt_type_hint (optional)
     * @param  bool $enable_xml enable_xml (optional)
     * @param  string $enable_xml_type_hint enable_xml_type_hint (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postConfigApacheSlingGetServlet($json_maximumresults = null, $json_maximumresults_type_hint = null, $enable_html = null, $enable_html_type_hint = null, $enable_txt = null, $enable_txt_type_hint = null, $enable_xml = null, $enable_xml_type_hint = null)
    {
        $this->postConfigApacheSlingGetServletWithHttpInfo($json_maximumresults, $json_maximumresults_type_hint, $enable_html, $enable_html_type_hint, $enable_txt, $enable_txt_type_hint, $enable_xml, $enable_xml_type_hint);
    }

    /**
     * Operation postConfigApacheSlingGetServletWithHttpInfo
     *
     * @param  string $json_maximumresults (optional)
     * @param  string $json_maximumresults_type_hint (optional)
     * @param  bool $enable_html (optional)
     * @param  string $enable_html_type_hint (optional)
     * @param  bool $enable_txt (optional)
     * @param  string $enable_txt_type_hint (optional)
     * @param  bool $enable_xml (optional)
     * @param  string $enable_xml_type_hint (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postConfigApacheSlingGetServletWithHttpInfo($json_maximumresults = null, $json_maximumresults_type_hint = null, $enable_html = null, $enable_html_type_hint = null, $enable_txt = null, $enable_txt_type_hint = null, $enable_xml = null, $enable_xml_type_hint = null)
    {
        $request = $this->postConfigApacheSlingGetServletRequest($json_maximumresults, $json_maximumresults_type_hint, $enable_html, $enable_html_type_hint, $enable_txt, $enable_txt_type_hint, $enable_xml, $enable_xml_type_hint);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postConfigApacheSlingGetServletAsync
     *
     * 
     *
     * @param  string $json_maximumresults (optional)
     * @param  string $json_maximumresults_type_hint (optional)
     * @param  bool $enable_html (optional)
     * @param  string $enable_html_type_hint (optional)
     * @param  bool $enable_txt (optional)
     * @param  string $enable_txt_type_hint (optional)
     * @param  bool $enable_xml (optional)
     * @param  string $enable_xml_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postConfigApacheSlingGetServletAsync($json_maximumresults = null, $json_maximumresults_type_hint = null, $enable_html = null, $enable_html_type_hint = null, $enable_txt = null, $enable_txt_type_hint = null, $enable_xml = null, $enable_xml_type_hint = null)
    {
        return $this->postConfigApacheSlingGetServletAsyncWithHttpInfo($json_maximumresults, $json_maximumresults_type_hint, $enable_html, $enable_html_type_hint, $enable_txt, $enable_txt_type_hint, $enable_xml, $enable_xml_type_hint)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postConfigApacheSlingGetServletAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $json_maximumresults (optional)
     * @param  string $json_maximumresults_type_hint (optional)
     * @param  bool $enable_html (optional)
     * @param  string $enable_html_type_hint (optional)
     * @param  bool $enable_txt (optional)
     * @param  string $enable_txt_type_hint (optional)
     * @param  bool $enable_xml (optional)
     * @param  string $enable_xml_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postConfigApacheSlingGetServletAsyncWithHttpInfo($json_maximumresults = null, $json_maximumresults_type_hint = null, $enable_html = null, $enable_html_type_hint = null, $enable_txt = null, $enable_txt_type_hint = null, $enable_xml = null, $enable_xml_type_hint = null)
    {
        $returnType = '';
        $request = $this->postConfigApacheSlingGetServletRequest($json_maximumresults, $json_maximumresults_type_hint, $enable_html, $enable_html_type_hint, $enable_txt, $enable_txt_type_hint, $enable_xml, $enable_xml_type_hint);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postConfigApacheSlingGetServlet'
     *
     * @param  string $json_maximumresults (optional)
     * @param  string $json_maximumresults_type_hint (optional)
     * @param  bool $enable_html (optional)
     * @param  string $enable_html_type_hint (optional)
     * @param  bool $enable_txt (optional)
     * @param  string $enable_txt_type_hint (optional)
     * @param  bool $enable_xml (optional)
     * @param  string $enable_xml_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postConfigApacheSlingGetServletRequest($json_maximumresults = null, $json_maximumresults_type_hint = null, $enable_html = null, $enable_html_type_hint = null, $enable_txt = null, $enable_txt_type_hint = null, $enable_xml = null, $enable_xml_type_hint = null)
    {

        $resourcePath = '/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($json_maximumresults !== null) {
            $queryParams['json.maximumresults'] = ObjectSerializer::toQueryValue($json_maximumresults);
        }
        // query params
        if ($json_maximumresults_type_hint !== null) {
            $queryParams['json.maximumresults@TypeHint'] = ObjectSerializer::toQueryValue($json_maximumresults_type_hint);
        }
        // query params
        if ($enable_html !== null) {
            $queryParams['enable.html'] = ObjectSerializer::toQueryValue($enable_html);
        }
        // query params
        if ($enable_html_type_hint !== null) {
            $queryParams['enable.html@TypeHint'] = ObjectSerializer::toQueryValue($enable_html_type_hint);
        }
        // query params
        if ($enable_txt !== null) {
            $queryParams['enable.txt'] = ObjectSerializer::toQueryValue($enable_txt);
        }
        // query params
        if ($enable_txt_type_hint !== null) {
            $queryParams['enable.txt@TypeHint'] = ObjectSerializer::toQueryValue($enable_txt_type_hint);
        }
        // query params
        if ($enable_xml !== null) {
            $queryParams['enable.xml'] = ObjectSerializer::toQueryValue($enable_xml);
        }
        // query params
        if ($enable_xml_type_hint !== null) {
            $queryParams['enable.xml@TypeHint'] = ObjectSerializer::toQueryValue($enable_xml_type_hint);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postConfigApacheSlingReferrerFilter
     *
     * @param  bool $allow_empty allow_empty (optional)
     * @param  string $allow_empty_type_hint allow_empty_type_hint (optional)
     * @param  string $allow_hosts allow_hosts (optional)
     * @param  string $allow_hosts_type_hint allow_hosts_type_hint (optional)
     * @param  string $allow_hosts_regexp allow_hosts_regexp (optional)
     * @param  string $allow_hosts_regexp_type_hint allow_hosts_regexp_type_hint (optional)
     * @param  string $filter_methods filter_methods (optional)
     * @param  string $filter_methods_type_hint filter_methods_type_hint (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postConfigApacheSlingReferrerFilter($allow_empty = null, $allow_empty_type_hint = null, $allow_hosts = null, $allow_hosts_type_hint = null, $allow_hosts_regexp = null, $allow_hosts_regexp_type_hint = null, $filter_methods = null, $filter_methods_type_hint = null)
    {
        $this->postConfigApacheSlingReferrerFilterWithHttpInfo($allow_empty, $allow_empty_type_hint, $allow_hosts, $allow_hosts_type_hint, $allow_hosts_regexp, $allow_hosts_regexp_type_hint, $filter_methods, $filter_methods_type_hint);
    }

    /**
     * Operation postConfigApacheSlingReferrerFilterWithHttpInfo
     *
     * @param  bool $allow_empty (optional)
     * @param  string $allow_empty_type_hint (optional)
     * @param  string $allow_hosts (optional)
     * @param  string $allow_hosts_type_hint (optional)
     * @param  string $allow_hosts_regexp (optional)
     * @param  string $allow_hosts_regexp_type_hint (optional)
     * @param  string $filter_methods (optional)
     * @param  string $filter_methods_type_hint (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postConfigApacheSlingReferrerFilterWithHttpInfo($allow_empty = null, $allow_empty_type_hint = null, $allow_hosts = null, $allow_hosts_type_hint = null, $allow_hosts_regexp = null, $allow_hosts_regexp_type_hint = null, $filter_methods = null, $filter_methods_type_hint = null)
    {
        $request = $this->postConfigApacheSlingReferrerFilterRequest($allow_empty, $allow_empty_type_hint, $allow_hosts, $allow_hosts_type_hint, $allow_hosts_regexp, $allow_hosts_regexp_type_hint, $filter_methods, $filter_methods_type_hint);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postConfigApacheSlingReferrerFilterAsync
     *
     * 
     *
     * @param  bool $allow_empty (optional)
     * @param  string $allow_empty_type_hint (optional)
     * @param  string $allow_hosts (optional)
     * @param  string $allow_hosts_type_hint (optional)
     * @param  string $allow_hosts_regexp (optional)
     * @param  string $allow_hosts_regexp_type_hint (optional)
     * @param  string $filter_methods (optional)
     * @param  string $filter_methods_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postConfigApacheSlingReferrerFilterAsync($allow_empty = null, $allow_empty_type_hint = null, $allow_hosts = null, $allow_hosts_type_hint = null, $allow_hosts_regexp = null, $allow_hosts_regexp_type_hint = null, $filter_methods = null, $filter_methods_type_hint = null)
    {
        return $this->postConfigApacheSlingReferrerFilterAsyncWithHttpInfo($allow_empty, $allow_empty_type_hint, $allow_hosts, $allow_hosts_type_hint, $allow_hosts_regexp, $allow_hosts_regexp_type_hint, $filter_methods, $filter_methods_type_hint)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postConfigApacheSlingReferrerFilterAsyncWithHttpInfo
     *
     * 
     *
     * @param  bool $allow_empty (optional)
     * @param  string $allow_empty_type_hint (optional)
     * @param  string $allow_hosts (optional)
     * @param  string $allow_hosts_type_hint (optional)
     * @param  string $allow_hosts_regexp (optional)
     * @param  string $allow_hosts_regexp_type_hint (optional)
     * @param  string $filter_methods (optional)
     * @param  string $filter_methods_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postConfigApacheSlingReferrerFilterAsyncWithHttpInfo($allow_empty = null, $allow_empty_type_hint = null, $allow_hosts = null, $allow_hosts_type_hint = null, $allow_hosts_regexp = null, $allow_hosts_regexp_type_hint = null, $filter_methods = null, $filter_methods_type_hint = null)
    {
        $returnType = '';
        $request = $this->postConfigApacheSlingReferrerFilterRequest($allow_empty, $allow_empty_type_hint, $allow_hosts, $allow_hosts_type_hint, $allow_hosts_regexp, $allow_hosts_regexp_type_hint, $filter_methods, $filter_methods_type_hint);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postConfigApacheSlingReferrerFilter'
     *
     * @param  bool $allow_empty (optional)
     * @param  string $allow_empty_type_hint (optional)
     * @param  string $allow_hosts (optional)
     * @param  string $allow_hosts_type_hint (optional)
     * @param  string $allow_hosts_regexp (optional)
     * @param  string $allow_hosts_regexp_type_hint (optional)
     * @param  string $filter_methods (optional)
     * @param  string $filter_methods_type_hint (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postConfigApacheSlingReferrerFilterRequest($allow_empty = null, $allow_empty_type_hint = null, $allow_hosts = null, $allow_hosts_type_hint = null, $allow_hosts_regexp = null, $allow_hosts_regexp_type_hint = null, $filter_methods = null, $filter_methods_type_hint = null)
    {

        $resourcePath = '/apps/system/config/org.apache.sling.security.impl.ReferrerFilter';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($allow_empty !== null) {
            $queryParams['allow.empty'] = ObjectSerializer::toQueryValue($allow_empty);
        }
        // query params
        if ($allow_empty_type_hint !== null) {
            $queryParams['allow.empty@TypeHint'] = ObjectSerializer::toQueryValue($allow_empty_type_hint);
        }
        // query params
        if ($allow_hosts !== null) {
            $queryParams['allow.hosts'] = ObjectSerializer::toQueryValue($allow_hosts);
        }
        // query params
        if ($allow_hosts_type_hint !== null) {
            $queryParams['allow.hosts@TypeHint'] = ObjectSerializer::toQueryValue($allow_hosts_type_hint);
        }
        // query params
        if ($allow_hosts_regexp !== null) {
            $queryParams['allow.hosts.regexp'] = ObjectSerializer::toQueryValue($allow_hosts_regexp);
        }
        // query params
        if ($allow_hosts_regexp_type_hint !== null) {
            $queryParams['allow.hosts.regexp@TypeHint'] = ObjectSerializer::toQueryValue($allow_hosts_regexp_type_hint);
        }
        // query params
        if ($filter_methods !== null) {
            $queryParams['filter.methods'] = ObjectSerializer::toQueryValue($filter_methods);
        }
        // query params
        if ($filter_methods_type_hint !== null) {
            $queryParams['filter.methods@TypeHint'] = ObjectSerializer::toQueryValue($filter_methods_type_hint);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postNode
     *
     * @param  string $path path (required)
     * @param  string $name name (required)
     * @param  string $operation operation (optional)
     * @param  string $delete_authorizable delete_authorizable (optional)
     * @param  \SplFileObject $file file (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postNode($path, $name, $operation = null, $delete_authorizable = null, $file = null)
    {
        $this->postNodeWithHttpInfo($path, $name, $operation, $delete_authorizable, $file);
    }

    /**
     * Operation postNodeWithHttpInfo
     *
     * @param  string $path (required)
     * @param  string $name (required)
     * @param  string $operation (optional)
     * @param  string $delete_authorizable (optional)
     * @param  \SplFileObject $file (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postNodeWithHttpInfo($path, $name, $operation = null, $delete_authorizable = null, $file = null)
    {
        $request = $this->postNodeRequest($path, $name, $operation, $delete_authorizable, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postNodeAsync
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $name (required)
     * @param  string $operation (optional)
     * @param  string $delete_authorizable (optional)
     * @param  \SplFileObject $file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postNodeAsync($path, $name, $operation = null, $delete_authorizable = null, $file = null)
    {
        return $this->postNodeAsyncWithHttpInfo($path, $name, $operation, $delete_authorizable, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postNodeAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $name (required)
     * @param  string $operation (optional)
     * @param  string $delete_authorizable (optional)
     * @param  \SplFileObject $file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postNodeAsyncWithHttpInfo($path, $name, $operation = null, $delete_authorizable = null, $file = null)
    {
        $returnType = '';
        $request = $this->postNodeRequest($path, $name, $operation, $delete_authorizable, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postNode'
     *
     * @param  string $path (required)
     * @param  string $name (required)
     * @param  string $operation (optional)
     * @param  string $delete_authorizable (optional)
     * @param  \SplFileObject $file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postNodeRequest($path, $name, $operation = null, $delete_authorizable = null, $file = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling postNode'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postNode'
            );
        }

        $resourcePath = '/{path}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($operation !== null) {
            $queryParams[':operation'] = ObjectSerializer::toQueryValue($operation);
        }
        // query params
        if ($delete_authorizable !== null) {
            $queryParams['deleteAuthorizable'] = ObjectSerializer::toQueryValue($delete_authorizable);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postNodeRw
     *
     * @param  string $path path (required)
     * @param  string $name name (required)
     * @param  string $add_members add_members (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postNodeRw($path, $name, $add_members = null)
    {
        $this->postNodeRwWithHttpInfo($path, $name, $add_members);
    }

    /**
     * Operation postNodeRwWithHttpInfo
     *
     * @param  string $path (required)
     * @param  string $name (required)
     * @param  string $add_members (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postNodeRwWithHttpInfo($path, $name, $add_members = null)
    {
        $request = $this->postNodeRwRequest($path, $name, $add_members);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postNodeRwAsync
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $name (required)
     * @param  string $add_members (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postNodeRwAsync($path, $name, $add_members = null)
    {
        return $this->postNodeRwAsyncWithHttpInfo($path, $name, $add_members)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postNodeRwAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $name (required)
     * @param  string $add_members (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postNodeRwAsyncWithHttpInfo($path, $name, $add_members = null)
    {
        $returnType = '';
        $request = $this->postNodeRwRequest($path, $name, $add_members);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postNodeRw'
     *
     * @param  string $path (required)
     * @param  string $name (required)
     * @param  string $add_members (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postNodeRwRequest($path, $name, $add_members = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling postNodeRw'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postNodeRw'
            );
        }

        $resourcePath = '/{path}/{name}.rw.html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($add_members !== null) {
            $queryParams['addMembers'] = ObjectSerializer::toQueryValue($add_members);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPath
     *
     * @param  string $path path (required)
     * @param  string $jcrprimary_type jcrprimary_type (required)
     * @param  string $name name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postPath($path, $jcrprimary_type, $name)
    {
        $this->postPathWithHttpInfo($path, $jcrprimary_type, $name);
    }

    /**
     * Operation postPathWithHttpInfo
     *
     * @param  string $path (required)
     * @param  string $jcrprimary_type (required)
     * @param  string $name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPathWithHttpInfo($path, $jcrprimary_type, $name)
    {
        $request = $this->postPathRequest($path, $jcrprimary_type, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postPathAsync
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $jcrprimary_type (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPathAsync($path, $jcrprimary_type, $name)
    {
        return $this->postPathAsyncWithHttpInfo($path, $jcrprimary_type, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPathAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path (required)
     * @param  string $jcrprimary_type (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPathAsyncWithHttpInfo($path, $jcrprimary_type, $name)
    {
        $returnType = '';
        $request = $this->postPathRequest($path, $jcrprimary_type, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPath'
     *
     * @param  string $path (required)
     * @param  string $jcrprimary_type (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPathRequest($path, $jcrprimary_type, $name)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling postPath'
            );
        }
        // verify the required parameter 'jcrprimary_type' is set
        if ($jcrprimary_type === null || (is_array($jcrprimary_type) && count($jcrprimary_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $jcrprimary_type when calling postPath'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPath'
            );
        }

        $resourcePath = '/{path}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($jcrprimary_type !== null) {
            $queryParams['jcr:primaryType'] = ObjectSerializer::toQueryValue($jcrprimary_type);
        }
        // query params
        if ($name !== null) {
            $queryParams[':name'] = ObjectSerializer::toQueryValue($name);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postQuery
     *
     * @param  string $path path (required)
     * @param  float $p_limit p_limit (required)
     * @param  string $_1_property _1_property (required)
     * @param  string $_1_property_value _1_property_value (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function postQuery($path, $p_limit, $_1_property, $_1_property_value)
    {
        list($response) = $this->postQueryWithHttpInfo($path, $p_limit, $_1_property, $_1_property_value);
        return $response;
    }

    /**
     * Operation postQueryWithHttpInfo
     *
     * @param  string $path (required)
     * @param  float $p_limit (required)
     * @param  string $_1_property (required)
     * @param  string $_1_property_value (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function postQueryWithHttpInfo($path, $p_limit, $_1_property, $_1_property_value)
    {
        $request = $this->postQueryRequest($path, $p_limit, $_1_property, $_1_property_value);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                default:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postQueryAsync
     *
     * 
     *
     * @param  string $path (required)
     * @param  float $p_limit (required)
     * @param  string $_1_property (required)
     * @param  string $_1_property_value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postQueryAsync($path, $p_limit, $_1_property, $_1_property_value)
    {
        return $this->postQueryAsyncWithHttpInfo($path, $p_limit, $_1_property, $_1_property_value)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postQueryAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path (required)
     * @param  float $p_limit (required)
     * @param  string $_1_property (required)
     * @param  string $_1_property_value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postQueryAsyncWithHttpInfo($path, $p_limit, $_1_property, $_1_property_value)
    {
        $returnType = 'string';
        $request = $this->postQueryRequest($path, $p_limit, $_1_property, $_1_property_value);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postQuery'
     *
     * @param  string $path (required)
     * @param  float $p_limit (required)
     * @param  string $_1_property (required)
     * @param  string $_1_property_value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postQueryRequest($path, $p_limit, $_1_property, $_1_property_value)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling postQuery'
            );
        }
        // verify the required parameter 'p_limit' is set
        if ($p_limit === null || (is_array($p_limit) && count($p_limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $p_limit when calling postQuery'
            );
        }
        // verify the required parameter '_1_property' is set
        if ($_1_property === null || (is_array($_1_property) && count($_1_property) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $_1_property when calling postQuery'
            );
        }
        // verify the required parameter '_1_property_value' is set
        if ($_1_property_value === null || (is_array($_1_property_value) && count($_1_property_value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $_1_property_value when calling postQuery'
            );
        }

        $resourcePath = '/bin/querybuilder.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($p_limit !== null) {
            $queryParams['p.limit'] = ObjectSerializer::toQueryValue($p_limit);
        }
        // query params
        if ($_1_property !== null) {
            $queryParams['1_property'] = ObjectSerializer::toQueryValue($_1_property);
        }
        // query params
        if ($_1_property_value !== null) {
            $queryParams['1_property.value'] = ObjectSerializer::toQueryValue($_1_property_value);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTreeActivation
     *
     * @param  bool $ignoredeactivated ignoredeactivated (required)
     * @param  bool $onlymodified onlymodified (required)
     * @param  string $path path (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postTreeActivation($ignoredeactivated, $onlymodified, $path)
    {
        $this->postTreeActivationWithHttpInfo($ignoredeactivated, $onlymodified, $path);
    }

    /**
     * Operation postTreeActivationWithHttpInfo
     *
     * @param  bool $ignoredeactivated (required)
     * @param  bool $onlymodified (required)
     * @param  string $path (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTreeActivationWithHttpInfo($ignoredeactivated, $onlymodified, $path)
    {
        $request = $this->postTreeActivationRequest($ignoredeactivated, $onlymodified, $path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postTreeActivationAsync
     *
     * 
     *
     * @param  bool $ignoredeactivated (required)
     * @param  bool $onlymodified (required)
     * @param  string $path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTreeActivationAsync($ignoredeactivated, $onlymodified, $path)
    {
        return $this->postTreeActivationAsyncWithHttpInfo($ignoredeactivated, $onlymodified, $path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTreeActivationAsyncWithHttpInfo
     *
     * 
     *
     * @param  bool $ignoredeactivated (required)
     * @param  bool $onlymodified (required)
     * @param  string $path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTreeActivationAsyncWithHttpInfo($ignoredeactivated, $onlymodified, $path)
    {
        $returnType = '';
        $request = $this->postTreeActivationRequest($ignoredeactivated, $onlymodified, $path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTreeActivation'
     *
     * @param  bool $ignoredeactivated (required)
     * @param  bool $onlymodified (required)
     * @param  string $path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTreeActivationRequest($ignoredeactivated, $onlymodified, $path)
    {
        // verify the required parameter 'ignoredeactivated' is set
        if ($ignoredeactivated === null || (is_array($ignoredeactivated) && count($ignoredeactivated) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ignoredeactivated when calling postTreeActivation'
            );
        }
        // verify the required parameter 'onlymodified' is set
        if ($onlymodified === null || (is_array($onlymodified) && count($onlymodified) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $onlymodified when calling postTreeActivation'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling postTreeActivation'
            );
        }

        $resourcePath = '/etc/replication/treeactivation.html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ignoredeactivated !== null) {
            $queryParams['ignoredeactivated'] = ObjectSerializer::toQueryValue($ignoredeactivated);
        }
        // query params
        if ($onlymodified !== null) {
            $queryParams['onlymodified'] = ObjectSerializer::toQueryValue($onlymodified);
        }
        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTruststore
     *
     * @param  string $operation operation (optional)
     * @param  string $new_password new_password (optional)
     * @param  string $re_password re_password (optional)
     * @param  string $key_store_type key_store_type (optional)
     * @param  string $remove_alias remove_alias (optional)
     * @param  \SplFileObject $certificate certificate (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function postTruststore($operation = null, $new_password = null, $re_password = null, $key_store_type = null, $remove_alias = null, $certificate = null)
    {
        list($response) = $this->postTruststoreWithHttpInfo($operation, $new_password, $re_password, $key_store_type, $remove_alias, $certificate);
        return $response;
    }

    /**
     * Operation postTruststoreWithHttpInfo
     *
     * @param  string $operation (optional)
     * @param  string $new_password (optional)
     * @param  string $re_password (optional)
     * @param  string $key_store_type (optional)
     * @param  string $remove_alias (optional)
     * @param  \SplFileObject $certificate (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTruststoreWithHttpInfo($operation = null, $new_password = null, $re_password = null, $key_store_type = null, $remove_alias = null, $certificate = null)
    {
        $request = $this->postTruststoreRequest($operation, $new_password, $re_password, $key_store_type, $remove_alias, $certificate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                default:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postTruststoreAsync
     *
     * 
     *
     * @param  string $operation (optional)
     * @param  string $new_password (optional)
     * @param  string $re_password (optional)
     * @param  string $key_store_type (optional)
     * @param  string $remove_alias (optional)
     * @param  \SplFileObject $certificate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTruststoreAsync($operation = null, $new_password = null, $re_password = null, $key_store_type = null, $remove_alias = null, $certificate = null)
    {
        return $this->postTruststoreAsyncWithHttpInfo($operation, $new_password, $re_password, $key_store_type, $remove_alias, $certificate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTruststoreAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $operation (optional)
     * @param  string $new_password (optional)
     * @param  string $re_password (optional)
     * @param  string $key_store_type (optional)
     * @param  string $remove_alias (optional)
     * @param  \SplFileObject $certificate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTruststoreAsyncWithHttpInfo($operation = null, $new_password = null, $re_password = null, $key_store_type = null, $remove_alias = null, $certificate = null)
    {
        $returnType = 'string';
        $request = $this->postTruststoreRequest($operation, $new_password, $re_password, $key_store_type, $remove_alias, $certificate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTruststore'
     *
     * @param  string $operation (optional)
     * @param  string $new_password (optional)
     * @param  string $re_password (optional)
     * @param  string $key_store_type (optional)
     * @param  string $remove_alias (optional)
     * @param  \SplFileObject $certificate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTruststoreRequest($operation = null, $new_password = null, $re_password = null, $key_store_type = null, $remove_alias = null, $certificate = null)
    {

        $resourcePath = '/libs/granite/security/post/truststore';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($operation !== null) {
            $queryParams[':operation'] = ObjectSerializer::toQueryValue($operation);
        }
        // query params
        if ($new_password !== null) {
            $queryParams['newPassword'] = ObjectSerializer::toQueryValue($new_password);
        }
        // query params
        if ($re_password !== null) {
            $queryParams['rePassword'] = ObjectSerializer::toQueryValue($re_password);
        }
        // query params
        if ($key_store_type !== null) {
            $queryParams['keyStoreType'] = ObjectSerializer::toQueryValue($key_store_type);
        }
        // query params
        if ($remove_alias !== null) {
            $queryParams['removeAlias'] = ObjectSerializer::toQueryValue($remove_alias);
        }


        // form params
        if ($certificate !== null) {
            $multipart = true;
            $formParams['certificate'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($certificate), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTruststorePKCS12
     *
     * @param  \SplFileObject $truststore_p12 truststore_p12 (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function postTruststorePKCS12($truststore_p12 = null)
    {
        list($response) = $this->postTruststorePKCS12WithHttpInfo($truststore_p12);
        return $response;
    }

    /**
     * Operation postTruststorePKCS12WithHttpInfo
     *
     * @param  \SplFileObject $truststore_p12 (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTruststorePKCS12WithHttpInfo($truststore_p12 = null)
    {
        $request = $this->postTruststorePKCS12Request($truststore_p12);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                default:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postTruststorePKCS12Async
     *
     * 
     *
     * @param  \SplFileObject $truststore_p12 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTruststorePKCS12Async($truststore_p12 = null)
    {
        return $this->postTruststorePKCS12AsyncWithHttpInfo($truststore_p12)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTruststorePKCS12AsyncWithHttpInfo
     *
     * 
     *
     * @param  \SplFileObject $truststore_p12 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTruststorePKCS12AsyncWithHttpInfo($truststore_p12 = null)
    {
        $returnType = 'string';
        $request = $this->postTruststorePKCS12Request($truststore_p12);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTruststorePKCS12'
     *
     * @param  \SplFileObject $truststore_p12 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTruststorePKCS12Request($truststore_p12 = null)
    {

        $resourcePath = '/etc/truststore';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($truststore_p12 !== null) {
            $multipart = true;
            $formParams['truststore.p12'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($truststore_p12), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
