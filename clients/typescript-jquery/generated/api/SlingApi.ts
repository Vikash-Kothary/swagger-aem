/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * OpenAPI spec version: 3.2.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as $ from 'jquery';
import * as models from '../model/models';
import { COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


export class SlingApi {
    protected basePath = 'http://localhost';
    public defaultHeaders: Array<string> = [];
    public defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings = null;
    public configuration: Configuration = new Configuration();

    constructor(basePath?: string, configuration?: Configuration, defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
        if (defaultExtraJQueryAjaxSettings) {
            this.defaultExtraJQueryAjaxSettings = defaultExtraJQueryAjaxSettings;
        }
    }

    private extendObj<T1, T2 extends T1>(objA: T2, objB: T2): T1|T2 {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return objA;
    }

    /**
     * 
     * @param runmode 
     * @param name 
     */
    public deleteAgent(runmode: string, name: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'.replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode))).replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling deleteAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteAgent.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'DELETE',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param path 
     * @param name 
     */
    public deleteNode(path: string, name: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{path}/{name}'.replace('{' + 'path' + '}', encodeURIComponent(String(path))).replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling deleteNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNode.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'DELETE',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param runmode 
     * @param name 
     */
    public getAgent(runmode: string, name: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'.replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode))).replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling getAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getAgent.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param runmode 
     */
    public getAgents(runmode: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: string;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/replication/agents.{runmode}.-1.json'.replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling getAgents.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: string;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: string, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     */
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.KeystoreInfo;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}.ks.json'.replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath))).replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling getAuthorizableKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling getAuthorizableKeystore.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.KeystoreInfo;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.KeystoreInfo, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     */
    public getKeystore(intermediatePath: string, authorizableId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}/keystore/store.p12'.replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath))).replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling getKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling getKeystore.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/octet-stream'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param path 
     * @param name 
     */
    public getNode(path: string, name: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{path}/{name}'.replace('{' + 'path' + '}', encodeURIComponent(String(path))).replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getNode.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param group 
     * @param name 
     * @param version 
     */
    public getPackage(group: string, name: string, version: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/packages/{group}/{name}-{version}.zip'.replace('{' + 'group' + '}', encodeURIComponent(String(group))).replace('{' + 'name' + '}', encodeURIComponent(String(name))).replace('{' + 'version' + '}', encodeURIComponent(String(version)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getPackage.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getPackage.');
        }

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getPackage.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/octet-stream'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param group 
     * @param name 
     * @param version 
     */
    public getPackageFilter(group: string, name: string, version: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: string;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json'.replace('{' + 'group' + '}', encodeURIComponent(String(group))).replace('{' + 'name' + '}', encodeURIComponent(String(name))).replace('{' + 'version' + '}', encodeURIComponent(String(version)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getPackageFilter.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getPackageFilter.');
        }

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getPackageFilter.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: string;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: string, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     */
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: string;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/bin/querybuilder.json';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getQuery.');
        }

        // verify required parameter 'pLimit' is not null or undefined
        if (pLimit === null || pLimit === undefined) {
            throw new Error('Required parameter pLimit was null or undefined when calling getQuery.');
        }

        // verify required parameter '_1property' is not null or undefined
        if (_1property === null || _1property === undefined) {
            throw new Error('Required parameter _1property was null or undefined when calling getQuery.');
        }

        // verify required parameter '_1propertyValue' is not null or undefined
        if (_1propertyValue === null || _1propertyValue === undefined) {
            throw new Error('Required parameter _1propertyValue was null or undefined when calling getQuery.');
        }

        if (path !== null && path !== undefined) {
            queryParameters['path'] = <string><any>path;
        }
        if (pLimit !== null && pLimit !== undefined) {
            queryParameters['p.limit'] = <string><any>pLimit;
        }
        if (_1property !== null && _1property !== undefined) {
            queryParameters['1_property'] = <string><any>_1property;
        }
        if (_1propertyValue !== null && _1propertyValue !== undefined) {
            queryParameters['1_property.value'] = <string><any>_1propertyValue;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: string;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: string, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     */
    public getTruststore(extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/truststore/truststore.p12';

        let queryParameters: any = {};
        let headerParams: any = {};

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/octet-stream'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     */
    public getTruststoreInfo(extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.TruststoreInfo;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/libs/granite/security/truststore.json';

        let queryParameters: any = {};
        let headerParams: any = {};

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.TruststoreInfo;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.TruststoreInfo, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param runmode 
     * @param name 
     * @param jcr:contentCq:distribute 
     * @param jcr:contentCq:distribute@TypeHint 
     * @param jcr:contentCq:name 
     * @param jcr:contentCq:template 
     * @param jcr:contentEnabled 
     * @param jcr:contentJcr:description 
     * @param jcr:contentJcr:lastModified 
     * @param jcr:contentJcr:lastModifiedBy 
     * @param jcr:contentJcr:mixinTypes 
     * @param jcr:contentJcr:title 
     * @param jcr:contentLogLevel 
     * @param jcr:contentNoStatusUpdate 
     * @param jcr:contentNoVersioning 
     * @param jcr:contentProtocolConnectTimeout 
     * @param jcr:contentProtocolHTTPConnectionClosed 
     * @param jcr:contentProtocolHTTPExpired 
     * @param jcr:contentProtocolHTTPHeaders 
     * @param jcr:contentProtocolHTTPHeaders@TypeHint 
     * @param jcr:contentProtocolHTTPMethod 
     * @param jcr:contentProtocolHTTPSRelaxed 
     * @param jcr:contentProtocolInterface 
     * @param jcr:contentProtocolSocketTimeout 
     * @param jcr:contentProtocolVersion 
     * @param jcr:contentProxyNTLMDomain 
     * @param jcr:contentProxyNTLMHost 
     * @param jcr:contentProxyHost 
     * @param jcr:contentProxyPassword 
     * @param jcr:contentProxyPort 
     * @param jcr:contentProxyUser 
     * @param jcr:contentQueueBatchMaxSize 
     * @param jcr:contentQueueBatchMode 
     * @param jcr:contentQueueBatchWaitTime 
     * @param jcr:contentRetryDelay 
     * @param jcr:contentReverseReplication 
     * @param jcr:contentSerializationType 
     * @param jcr:contentSling:resourceType 
     * @param jcr:contentSsl 
     * @param jcr:contentTransportNTLMDomain 
     * @param jcr:contentTransportNTLMHost 
     * @param jcr:contentTransportPassword 
     * @param jcr:contentTransportUri 
     * @param jcr:contentTransportUser 
     * @param jcr:contentTriggerDistribute 
     * @param jcr:contentTriggerModified 
     * @param jcr:contentTriggerOnOffTime 
     * @param jcr:contentTriggerReceive 
     * @param jcr:contentTriggerSpecific 
     * @param jcr:contentUserId 
     * @param jcr:primaryType 
     * @param :operation 
     */
    public postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'.replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode))).replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling postAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postAgent.');
        }

        if (jcr:contentCq:distribute !== null && jcr:contentCq:distribute !== undefined) {
            queryParameters['jcr:content/cq:distribute'] = <string><any>jcr:contentCq:distribute;
        }
        if (jcr:contentCq:distribute@TypeHint !== null && jcr:contentCq:distribute@TypeHint !== undefined) {
            queryParameters['jcr:content/cq:distribute@TypeHint'] = <string><any>jcr:contentCq:distribute@TypeHint;
        }
        if (jcr:contentCq:name !== null && jcr:contentCq:name !== undefined) {
            queryParameters['jcr:content/cq:name'] = <string><any>jcr:contentCq:name;
        }
        if (jcr:contentCq:template !== null && jcr:contentCq:template !== undefined) {
            queryParameters['jcr:content/cq:template'] = <string><any>jcr:contentCq:template;
        }
        if (jcr:contentEnabled !== null && jcr:contentEnabled !== undefined) {
            queryParameters['jcr:content/enabled'] = <string><any>jcr:contentEnabled;
        }
        if (jcr:contentJcr:description !== null && jcr:contentJcr:description !== undefined) {
            queryParameters['jcr:content/jcr:description'] = <string><any>jcr:contentJcr:description;
        }
        if (jcr:contentJcr:lastModified !== null && jcr:contentJcr:lastModified !== undefined) {
            queryParameters['jcr:content/jcr:lastModified'] = <string><any>jcr:contentJcr:lastModified;
        }
        if (jcr:contentJcr:lastModifiedBy !== null && jcr:contentJcr:lastModifiedBy !== undefined) {
            queryParameters['jcr:content/jcr:lastModifiedBy'] = <string><any>jcr:contentJcr:lastModifiedBy;
        }
        if (jcr:contentJcr:mixinTypes !== null && jcr:contentJcr:mixinTypes !== undefined) {
            queryParameters['jcr:content/jcr:mixinTypes'] = <string><any>jcr:contentJcr:mixinTypes;
        }
        if (jcr:contentJcr:title !== null && jcr:contentJcr:title !== undefined) {
            queryParameters['jcr:content/jcr:title'] = <string><any>jcr:contentJcr:title;
        }
        if (jcr:contentLogLevel !== null && jcr:contentLogLevel !== undefined) {
            queryParameters['jcr:content/logLevel'] = <string><any>jcr:contentLogLevel;
        }
        if (jcr:contentNoStatusUpdate !== null && jcr:contentNoStatusUpdate !== undefined) {
            queryParameters['jcr:content/noStatusUpdate'] = <string><any>jcr:contentNoStatusUpdate;
        }
        if (jcr:contentNoVersioning !== null && jcr:contentNoVersioning !== undefined) {
            queryParameters['jcr:content/noVersioning'] = <string><any>jcr:contentNoVersioning;
        }
        if (jcr:contentProtocolConnectTimeout !== null && jcr:contentProtocolConnectTimeout !== undefined) {
            queryParameters['jcr:content/protocolConnectTimeout'] = <string><any>jcr:contentProtocolConnectTimeout;
        }
        if (jcr:contentProtocolHTTPConnectionClosed !== null && jcr:contentProtocolHTTPConnectionClosed !== undefined) {
            queryParameters['jcr:content/protocolHTTPConnectionClosed'] = <string><any>jcr:contentProtocolHTTPConnectionClosed;
        }
        if (jcr:contentProtocolHTTPExpired !== null && jcr:contentProtocolHTTPExpired !== undefined) {
            queryParameters['jcr:content/protocolHTTPExpired'] = <string><any>jcr:contentProtocolHTTPExpired;
        }
        if (jcr:contentProtocolHTTPHeaders) {
            jcr:contentProtocolHTTPHeaders.forEach((element: any) => {
                queryParameters['jcr:content/protocolHTTPHeaders'].push(element);
            });
        }
        if (jcr:contentProtocolHTTPHeaders@TypeHint !== null && jcr:contentProtocolHTTPHeaders@TypeHint !== undefined) {
            queryParameters['jcr:content/protocolHTTPHeaders@TypeHint'] = <string><any>jcr:contentProtocolHTTPHeaders@TypeHint;
        }
        if (jcr:contentProtocolHTTPMethod !== null && jcr:contentProtocolHTTPMethod !== undefined) {
            queryParameters['jcr:content/protocolHTTPMethod'] = <string><any>jcr:contentProtocolHTTPMethod;
        }
        if (jcr:contentProtocolHTTPSRelaxed !== null && jcr:contentProtocolHTTPSRelaxed !== undefined) {
            queryParameters['jcr:content/protocolHTTPSRelaxed'] = <string><any>jcr:contentProtocolHTTPSRelaxed;
        }
        if (jcr:contentProtocolInterface !== null && jcr:contentProtocolInterface !== undefined) {
            queryParameters['jcr:content/protocolInterface'] = <string><any>jcr:contentProtocolInterface;
        }
        if (jcr:contentProtocolSocketTimeout !== null && jcr:contentProtocolSocketTimeout !== undefined) {
            queryParameters['jcr:content/protocolSocketTimeout'] = <string><any>jcr:contentProtocolSocketTimeout;
        }
        if (jcr:contentProtocolVersion !== null && jcr:contentProtocolVersion !== undefined) {
            queryParameters['jcr:content/protocolVersion'] = <string><any>jcr:contentProtocolVersion;
        }
        if (jcr:contentProxyNTLMDomain !== null && jcr:contentProxyNTLMDomain !== undefined) {
            queryParameters['jcr:content/proxyNTLMDomain'] = <string><any>jcr:contentProxyNTLMDomain;
        }
        if (jcr:contentProxyNTLMHost !== null && jcr:contentProxyNTLMHost !== undefined) {
            queryParameters['jcr:content/proxyNTLMHost'] = <string><any>jcr:contentProxyNTLMHost;
        }
        if (jcr:contentProxyHost !== null && jcr:contentProxyHost !== undefined) {
            queryParameters['jcr:content/proxyHost'] = <string><any>jcr:contentProxyHost;
        }
        if (jcr:contentProxyPassword !== null && jcr:contentProxyPassword !== undefined) {
            queryParameters['jcr:content/proxyPassword'] = <string><any>jcr:contentProxyPassword;
        }
        if (jcr:contentProxyPort !== null && jcr:contentProxyPort !== undefined) {
            queryParameters['jcr:content/proxyPort'] = <string><any>jcr:contentProxyPort;
        }
        if (jcr:contentProxyUser !== null && jcr:contentProxyUser !== undefined) {
            queryParameters['jcr:content/proxyUser'] = <string><any>jcr:contentProxyUser;
        }
        if (jcr:contentQueueBatchMaxSize !== null && jcr:contentQueueBatchMaxSize !== undefined) {
            queryParameters['jcr:content/queueBatchMaxSize'] = <string><any>jcr:contentQueueBatchMaxSize;
        }
        if (jcr:contentQueueBatchMode !== null && jcr:contentQueueBatchMode !== undefined) {
            queryParameters['jcr:content/queueBatchMode'] = <string><any>jcr:contentQueueBatchMode;
        }
        if (jcr:contentQueueBatchWaitTime !== null && jcr:contentQueueBatchWaitTime !== undefined) {
            queryParameters['jcr:content/queueBatchWaitTime'] = <string><any>jcr:contentQueueBatchWaitTime;
        }
        if (jcr:contentRetryDelay !== null && jcr:contentRetryDelay !== undefined) {
            queryParameters['jcr:content/retryDelay'] = <string><any>jcr:contentRetryDelay;
        }
        if (jcr:contentReverseReplication !== null && jcr:contentReverseReplication !== undefined) {
            queryParameters['jcr:content/reverseReplication'] = <string><any>jcr:contentReverseReplication;
        }
        if (jcr:contentSerializationType !== null && jcr:contentSerializationType !== undefined) {
            queryParameters['jcr:content/serializationType'] = <string><any>jcr:contentSerializationType;
        }
        if (jcr:contentSling:resourceType !== null && jcr:contentSling:resourceType !== undefined) {
            queryParameters['jcr:content/sling:resourceType'] = <string><any>jcr:contentSling:resourceType;
        }
        if (jcr:contentSsl !== null && jcr:contentSsl !== undefined) {
            queryParameters['jcr:content/ssl'] = <string><any>jcr:contentSsl;
        }
        if (jcr:contentTransportNTLMDomain !== null && jcr:contentTransportNTLMDomain !== undefined) {
            queryParameters['jcr:content/transportNTLMDomain'] = <string><any>jcr:contentTransportNTLMDomain;
        }
        if (jcr:contentTransportNTLMHost !== null && jcr:contentTransportNTLMHost !== undefined) {
            queryParameters['jcr:content/transportNTLMHost'] = <string><any>jcr:contentTransportNTLMHost;
        }
        if (jcr:contentTransportPassword !== null && jcr:contentTransportPassword !== undefined) {
            queryParameters['jcr:content/transportPassword'] = <string><any>jcr:contentTransportPassword;
        }
        if (jcr:contentTransportUri !== null && jcr:contentTransportUri !== undefined) {
            queryParameters['jcr:content/transportUri'] = <string><any>jcr:contentTransportUri;
        }
        if (jcr:contentTransportUser !== null && jcr:contentTransportUser !== undefined) {
            queryParameters['jcr:content/transportUser'] = <string><any>jcr:contentTransportUser;
        }
        if (jcr:contentTriggerDistribute !== null && jcr:contentTriggerDistribute !== undefined) {
            queryParameters['jcr:content/triggerDistribute'] = <string><any>jcr:contentTriggerDistribute;
        }
        if (jcr:contentTriggerModified !== null && jcr:contentTriggerModified !== undefined) {
            queryParameters['jcr:content/triggerModified'] = <string><any>jcr:contentTriggerModified;
        }
        if (jcr:contentTriggerOnOffTime !== null && jcr:contentTriggerOnOffTime !== undefined) {
            queryParameters['jcr:content/triggerOnOffTime'] = <string><any>jcr:contentTriggerOnOffTime;
        }
        if (jcr:contentTriggerReceive !== null && jcr:contentTriggerReceive !== undefined) {
            queryParameters['jcr:content/triggerReceive'] = <string><any>jcr:contentTriggerReceive;
        }
        if (jcr:contentTriggerSpecific !== null && jcr:contentTriggerSpecific !== undefined) {
            queryParameters['jcr:content/triggerSpecific'] = <string><any>jcr:contentTriggerSpecific;
        }
        if (jcr:contentUserId !== null && jcr:contentUserId !== undefined) {
            queryParameters['jcr:content/userId'] = <string><any>jcr:contentUserId;
        }
        if (jcr:primaryType !== null && jcr:primaryType !== undefined) {
            queryParameters['jcr:primaryType'] = <string><any>jcr:primaryType;
        }
        if (:operation !== null && :operation !== undefined) {
            queryParameters[':operation'] = <string><any>:operation;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     * @param :operation 
     * @param currentPassword 
     * @param newPassword 
     * @param rePassword 
     * @param keyPassword 
     * @param keyStorePass 
     * @param alias 
     * @param newAlias 
     * @param removeAlias 
     * @param certChain 
     * @param pk 
     * @param keyStore 
     */
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: any, pk?: any, keyStore?: any, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.KeystoreInfo;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}.ks.html'.replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath))).replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        let formParams = new FormData();
        let reqHasFile = false;

        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizableKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizableKeystore.');
        }

        if (:operation !== null && :operation !== undefined) {
            queryParameters[':operation'] = <string><any>:operation;
        }
        if (currentPassword !== null && currentPassword !== undefined) {
            queryParameters['currentPassword'] = <string><any>currentPassword;
        }
        if (newPassword !== null && newPassword !== undefined) {
            queryParameters['newPassword'] = <string><any>newPassword;
        }
        if (rePassword !== null && rePassword !== undefined) {
            queryParameters['rePassword'] = <string><any>rePassword;
        }
        if (keyPassword !== null && keyPassword !== undefined) {
            queryParameters['keyPassword'] = <string><any>keyPassword;
        }
        if (keyStorePass !== null && keyStorePass !== undefined) {
            queryParameters['keyStorePass'] = <string><any>keyStorePass;
        }
        if (alias !== null && alias !== undefined) {
            queryParameters['alias'] = <string><any>alias;
        }
        if (newAlias !== null && newAlias !== undefined) {
            queryParameters['newAlias'] = <string><any>newAlias;
        }
        if (removeAlias !== null && removeAlias !== undefined) {
            queryParameters['removeAlias'] = <string><any>removeAlias;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        reqHasFile = true;
        formParams.append("cert-chain", certChain);
        reqHasFile = true;
        formParams.append("pk", pk);
        reqHasFile = true;
        formParams.append("keyStore", keyStore);
        // to determine the Content-Type header
        let consumes: string[] = [
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        if (!reqHasFile) {
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }
        requestOptions.data = formParams;
        if (reqHasFile) {
            requestOptions.contentType = false;
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.KeystoreInfo;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.KeystoreInfo, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param authorizableId 
     * @param intermediatePath 
     * @param createUser 
     * @param createGroup 
     * @param rep:password 
     * @param profileGivenName 
     */
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: string;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/libs/granite/security/post/authorizables';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizables.');
        }

        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizables.');
        }

        if (authorizableId !== null && authorizableId !== undefined) {
            queryParameters['authorizableId'] = <string><any>authorizableId;
        }
        if (intermediatePath !== null && intermediatePath !== undefined) {
            queryParameters['intermediatePath'] = <string><any>intermediatePath;
        }
        if (createUser !== null && createUser !== undefined) {
            queryParameters['createUser'] = <string><any>createUser;
        }
        if (createGroup !== null && createGroup !== undefined) {
            queryParameters['createGroup'] = <string><any>createGroup;
        }
        if (rep:password !== null && rep:password !== undefined) {
            queryParameters['rep:password'] = <string><any>rep:password;
        }
        if (profileGivenName !== null && profileGivenName !== undefined) {
            queryParameters['profile/givenName'] = <string><any>profileGivenName;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/html'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: string;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: string, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param keyStorePassword 
     * @param keyStorePassword@TypeHint 
     * @param serviceRanking 
     * @param serviceRanking@TypeHint 
     * @param idpHttpRedirect 
     * @param idpHttpRedirect@TypeHint 
     * @param createUser 
     * @param createUser@TypeHint 
     * @param defaultRedirectUrl 
     * @param defaultRedirectUrl@TypeHint 
     * @param userIDAttribute 
     * @param userIDAttribute@TypeHint 
     * @param defaultGroups 
     * @param defaultGroups@TypeHint 
     * @param idpCertAlias 
     * @param idpCertAlias@TypeHint 
     * @param addGroupMemberships 
     * @param addGroupMemberships@TypeHint 
     * @param path 
     * @param path@TypeHint 
     * @param synchronizeAttributes 
     * @param synchronizeAttributes@TypeHint 
     * @param clockTolerance 
     * @param clockTolerance@TypeHint 
     * @param groupMembershipAttribute 
     * @param groupMembershipAttribute@TypeHint 
     * @param idpUrl 
     * @param idpUrl@TypeHint 
     * @param logoutUrl 
     * @param logoutUrl@TypeHint 
     * @param serviceProviderEntityId 
     * @param serviceProviderEntityId@TypeHint 
     * @param assertionConsumerServiceURL 
     * @param assertionConsumerServiceURL@TypeHint 
     * @param handleLogout 
     * @param handleLogout@TypeHint 
     * @param spPrivateKeyAlias 
     * @param spPrivateKeyAlias@TypeHint 
     * @param useEncryption 
     * @param useEncryption@TypeHint 
     * @param nameIdFormat 
     * @param nameIdFormat@TypeHint 
     * @param digestMethod 
     * @param digestMethod@TypeHint 
     * @param signatureMethod 
     * @param signatureMethod@TypeHint 
     * @param userIntermediatePath 
     * @param userIntermediatePath@TypeHint 
     */
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (keyStorePassword !== null && keyStorePassword !== undefined) {
            queryParameters['keyStorePassword'] = <string><any>keyStorePassword;
        }
        if (keyStorePassword@TypeHint !== null && keyStorePassword@TypeHint !== undefined) {
            queryParameters['keyStorePassword@TypeHint'] = <string><any>keyStorePassword@TypeHint;
        }
        if (serviceRanking !== null && serviceRanking !== undefined) {
            queryParameters['service.ranking'] = <string><any>serviceRanking;
        }
        if (serviceRanking@TypeHint !== null && serviceRanking@TypeHint !== undefined) {
            queryParameters['service.ranking@TypeHint'] = <string><any>serviceRanking@TypeHint;
        }
        if (idpHttpRedirect !== null && idpHttpRedirect !== undefined) {
            queryParameters['idpHttpRedirect'] = <string><any>idpHttpRedirect;
        }
        if (idpHttpRedirect@TypeHint !== null && idpHttpRedirect@TypeHint !== undefined) {
            queryParameters['idpHttpRedirect@TypeHint'] = <string><any>idpHttpRedirect@TypeHint;
        }
        if (createUser !== null && createUser !== undefined) {
            queryParameters['createUser'] = <string><any>createUser;
        }
        if (createUser@TypeHint !== null && createUser@TypeHint !== undefined) {
            queryParameters['createUser@TypeHint'] = <string><any>createUser@TypeHint;
        }
        if (defaultRedirectUrl !== null && defaultRedirectUrl !== undefined) {
            queryParameters['defaultRedirectUrl'] = <string><any>defaultRedirectUrl;
        }
        if (defaultRedirectUrl@TypeHint !== null && defaultRedirectUrl@TypeHint !== undefined) {
            queryParameters['defaultRedirectUrl@TypeHint'] = <string><any>defaultRedirectUrl@TypeHint;
        }
        if (userIDAttribute !== null && userIDAttribute !== undefined) {
            queryParameters['userIDAttribute'] = <string><any>userIDAttribute;
        }
        if (userIDAttribute@TypeHint !== null && userIDAttribute@TypeHint !== undefined) {
            queryParameters['userIDAttribute@TypeHint'] = <string><any>userIDAttribute@TypeHint;
        }
        if (defaultGroups) {
            defaultGroups.forEach((element: any) => {
                queryParameters['defaultGroups'].push(element);
            });
        }
        if (defaultGroups@TypeHint !== null && defaultGroups@TypeHint !== undefined) {
            queryParameters['defaultGroups@TypeHint'] = <string><any>defaultGroups@TypeHint;
        }
        if (idpCertAlias !== null && idpCertAlias !== undefined) {
            queryParameters['idpCertAlias'] = <string><any>idpCertAlias;
        }
        if (idpCertAlias@TypeHint !== null && idpCertAlias@TypeHint !== undefined) {
            queryParameters['idpCertAlias@TypeHint'] = <string><any>idpCertAlias@TypeHint;
        }
        if (addGroupMemberships !== null && addGroupMemberships !== undefined) {
            queryParameters['addGroupMemberships'] = <string><any>addGroupMemberships;
        }
        if (addGroupMemberships@TypeHint !== null && addGroupMemberships@TypeHint !== undefined) {
            queryParameters['addGroupMemberships@TypeHint'] = <string><any>addGroupMemberships@TypeHint;
        }
        if (path) {
            path.forEach((element: any) => {
                queryParameters['path'].push(element);
            });
        }
        if (path@TypeHint !== null && path@TypeHint !== undefined) {
            queryParameters['path@TypeHint'] = <string><any>path@TypeHint;
        }
        if (synchronizeAttributes) {
            synchronizeAttributes.forEach((element: any) => {
                queryParameters['synchronizeAttributes'].push(element);
            });
        }
        if (synchronizeAttributes@TypeHint !== null && synchronizeAttributes@TypeHint !== undefined) {
            queryParameters['synchronizeAttributes@TypeHint'] = <string><any>synchronizeAttributes@TypeHint;
        }
        if (clockTolerance !== null && clockTolerance !== undefined) {
            queryParameters['clockTolerance'] = <string><any>clockTolerance;
        }
        if (clockTolerance@TypeHint !== null && clockTolerance@TypeHint !== undefined) {
            queryParameters['clockTolerance@TypeHint'] = <string><any>clockTolerance@TypeHint;
        }
        if (groupMembershipAttribute !== null && groupMembershipAttribute !== undefined) {
            queryParameters['groupMembershipAttribute'] = <string><any>groupMembershipAttribute;
        }
        if (groupMembershipAttribute@TypeHint !== null && groupMembershipAttribute@TypeHint !== undefined) {
            queryParameters['groupMembershipAttribute@TypeHint'] = <string><any>groupMembershipAttribute@TypeHint;
        }
        if (idpUrl !== null && idpUrl !== undefined) {
            queryParameters['idpUrl'] = <string><any>idpUrl;
        }
        if (idpUrl@TypeHint !== null && idpUrl@TypeHint !== undefined) {
            queryParameters['idpUrl@TypeHint'] = <string><any>idpUrl@TypeHint;
        }
        if (logoutUrl !== null && logoutUrl !== undefined) {
            queryParameters['logoutUrl'] = <string><any>logoutUrl;
        }
        if (logoutUrl@TypeHint !== null && logoutUrl@TypeHint !== undefined) {
            queryParameters['logoutUrl@TypeHint'] = <string><any>logoutUrl@TypeHint;
        }
        if (serviceProviderEntityId !== null && serviceProviderEntityId !== undefined) {
            queryParameters['serviceProviderEntityId'] = <string><any>serviceProviderEntityId;
        }
        if (serviceProviderEntityId@TypeHint !== null && serviceProviderEntityId@TypeHint !== undefined) {
            queryParameters['serviceProviderEntityId@TypeHint'] = <string><any>serviceProviderEntityId@TypeHint;
        }
        if (assertionConsumerServiceURL !== null && assertionConsumerServiceURL !== undefined) {
            queryParameters['assertionConsumerServiceURL'] = <string><any>assertionConsumerServiceURL;
        }
        if (assertionConsumerServiceURL@TypeHint !== null && assertionConsumerServiceURL@TypeHint !== undefined) {
            queryParameters['assertionConsumerServiceURL@TypeHint'] = <string><any>assertionConsumerServiceURL@TypeHint;
        }
        if (handleLogout !== null && handleLogout !== undefined) {
            queryParameters['handleLogout'] = <string><any>handleLogout;
        }
        if (handleLogout@TypeHint !== null && handleLogout@TypeHint !== undefined) {
            queryParameters['handleLogout@TypeHint'] = <string><any>handleLogout@TypeHint;
        }
        if (spPrivateKeyAlias !== null && spPrivateKeyAlias !== undefined) {
            queryParameters['spPrivateKeyAlias'] = <string><any>spPrivateKeyAlias;
        }
        if (spPrivateKeyAlias@TypeHint !== null && spPrivateKeyAlias@TypeHint !== undefined) {
            queryParameters['spPrivateKeyAlias@TypeHint'] = <string><any>spPrivateKeyAlias@TypeHint;
        }
        if (useEncryption !== null && useEncryption !== undefined) {
            queryParameters['useEncryption'] = <string><any>useEncryption;
        }
        if (useEncryption@TypeHint !== null && useEncryption@TypeHint !== undefined) {
            queryParameters['useEncryption@TypeHint'] = <string><any>useEncryption@TypeHint;
        }
        if (nameIdFormat !== null && nameIdFormat !== undefined) {
            queryParameters['nameIdFormat'] = <string><any>nameIdFormat;
        }
        if (nameIdFormat@TypeHint !== null && nameIdFormat@TypeHint !== undefined) {
            queryParameters['nameIdFormat@TypeHint'] = <string><any>nameIdFormat@TypeHint;
        }
        if (digestMethod !== null && digestMethod !== undefined) {
            queryParameters['digestMethod'] = <string><any>digestMethod;
        }
        if (digestMethod@TypeHint !== null && digestMethod@TypeHint !== undefined) {
            queryParameters['digestMethod@TypeHint'] = <string><any>digestMethod@TypeHint;
        }
        if (signatureMethod !== null && signatureMethod !== undefined) {
            queryParameters['signatureMethod'] = <string><any>signatureMethod;
        }
        if (signatureMethod@TypeHint !== null && signatureMethod@TypeHint !== undefined) {
            queryParameters['signatureMethod@TypeHint'] = <string><any>signatureMethod@TypeHint;
        }
        if (userIntermediatePath !== null && userIntermediatePath !== undefined) {
            queryParameters['userIntermediatePath'] = <string><any>userIntermediatePath;
        }
        if (userIntermediatePath@TypeHint !== null && userIntermediatePath@TypeHint !== undefined) {
            queryParameters['userIntermediatePath@TypeHint'] = <string><any>userIntermediatePath@TypeHint;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param orgApacheFelixHttpsNio 
     * @param orgApacheFelixHttpsNio@TypeHint 
     * @param orgApacheFelixHttpsKeystore 
     * @param orgApacheFelixHttpsKeystore@TypeHint 
     * @param orgApacheFelixHttpsKeystorePassword 
     * @param orgApacheFelixHttpsKeystorePassword@TypeHint 
     * @param orgApacheFelixHttpsKeystoreKey 
     * @param orgApacheFelixHttpsKeystoreKey@TypeHint 
     * @param orgApacheFelixHttpsKeystoreKeyPassword 
     * @param orgApacheFelixHttpsKeystoreKeyPassword@TypeHint 
     * @param orgApacheFelixHttpsTruststore 
     * @param orgApacheFelixHttpsTruststore@TypeHint 
     * @param orgApacheFelixHttpsTruststorePassword 
     * @param orgApacheFelixHttpsTruststorePassword@TypeHint 
     * @param orgApacheFelixHttpsClientcertificate 
     * @param orgApacheFelixHttpsClientcertificate@TypeHint 
     * @param orgApacheFelixHttpsEnable 
     * @param orgApacheFelixHttpsEnable@TypeHint 
     * @param orgOsgiServiceHttpPortSecure 
     * @param orgOsgiServiceHttpPortSecure@TypeHint 
     */
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/apps/system/config/org.apache.felix.http';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (orgApacheFelixHttpsNio !== null && orgApacheFelixHttpsNio !== undefined) {
            queryParameters['org.apache.felix.https.nio'] = <string><any>orgApacheFelixHttpsNio;
        }
        if (orgApacheFelixHttpsNio@TypeHint !== null && orgApacheFelixHttpsNio@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.nio@TypeHint'] = <string><any>orgApacheFelixHttpsNio@TypeHint;
        }
        if (orgApacheFelixHttpsKeystore !== null && orgApacheFelixHttpsKeystore !== undefined) {
            queryParameters['org.apache.felix.https.keystore'] = <string><any>orgApacheFelixHttpsKeystore;
        }
        if (orgApacheFelixHttpsKeystore@TypeHint !== null && orgApacheFelixHttpsKeystore@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore@TypeHint'] = <string><any>orgApacheFelixHttpsKeystore@TypeHint;
        }
        if (orgApacheFelixHttpsKeystorePassword !== null && orgApacheFelixHttpsKeystorePassword !== undefined) {
            queryParameters['org.apache.felix.https.keystore.password'] = <string><any>orgApacheFelixHttpsKeystorePassword;
        }
        if (orgApacheFelixHttpsKeystorePassword@TypeHint !== null && orgApacheFelixHttpsKeystorePassword@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore.password@TypeHint'] = <string><any>orgApacheFelixHttpsKeystorePassword@TypeHint;
        }
        if (orgApacheFelixHttpsKeystoreKey !== null && orgApacheFelixHttpsKeystoreKey !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key'] = <string><any>orgApacheFelixHttpsKeystoreKey;
        }
        if (orgApacheFelixHttpsKeystoreKey@TypeHint !== null && orgApacheFelixHttpsKeystoreKey@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key@TypeHint'] = <string><any>orgApacheFelixHttpsKeystoreKey@TypeHint;
        }
        if (orgApacheFelixHttpsKeystoreKeyPassword !== null && orgApacheFelixHttpsKeystoreKeyPassword !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key.password'] = <string><any>orgApacheFelixHttpsKeystoreKeyPassword;
        }
        if (orgApacheFelixHttpsKeystoreKeyPassword@TypeHint !== null && orgApacheFelixHttpsKeystoreKeyPassword@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key.password@TypeHint'] = <string><any>orgApacheFelixHttpsKeystoreKeyPassword@TypeHint;
        }
        if (orgApacheFelixHttpsTruststore !== null && orgApacheFelixHttpsTruststore !== undefined) {
            queryParameters['org.apache.felix.https.truststore'] = <string><any>orgApacheFelixHttpsTruststore;
        }
        if (orgApacheFelixHttpsTruststore@TypeHint !== null && orgApacheFelixHttpsTruststore@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.truststore@TypeHint'] = <string><any>orgApacheFelixHttpsTruststore@TypeHint;
        }
        if (orgApacheFelixHttpsTruststorePassword !== null && orgApacheFelixHttpsTruststorePassword !== undefined) {
            queryParameters['org.apache.felix.https.truststore.password'] = <string><any>orgApacheFelixHttpsTruststorePassword;
        }
        if (orgApacheFelixHttpsTruststorePassword@TypeHint !== null && orgApacheFelixHttpsTruststorePassword@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.truststore.password@TypeHint'] = <string><any>orgApacheFelixHttpsTruststorePassword@TypeHint;
        }
        if (orgApacheFelixHttpsClientcertificate !== null && orgApacheFelixHttpsClientcertificate !== undefined) {
            queryParameters['org.apache.felix.https.clientcertificate'] = <string><any>orgApacheFelixHttpsClientcertificate;
        }
        if (orgApacheFelixHttpsClientcertificate@TypeHint !== null && orgApacheFelixHttpsClientcertificate@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.clientcertificate@TypeHint'] = <string><any>orgApacheFelixHttpsClientcertificate@TypeHint;
        }
        if (orgApacheFelixHttpsEnable !== null && orgApacheFelixHttpsEnable !== undefined) {
            queryParameters['org.apache.felix.https.enable'] = <string><any>orgApacheFelixHttpsEnable;
        }
        if (orgApacheFelixHttpsEnable@TypeHint !== null && orgApacheFelixHttpsEnable@TypeHint !== undefined) {
            queryParameters['org.apache.felix.https.enable@TypeHint'] = <string><any>orgApacheFelixHttpsEnable@TypeHint;
        }
        if (orgOsgiServiceHttpPortSecure !== null && orgOsgiServiceHttpPortSecure !== undefined) {
            queryParameters['org.osgi.service.http.port.secure'] = <string><any>orgOsgiServiceHttpPortSecure;
        }
        if (orgOsgiServiceHttpPortSecure@TypeHint !== null && orgOsgiServiceHttpPortSecure@TypeHint !== undefined) {
            queryParameters['org.osgi.service.http.port.secure@TypeHint'] = <string><any>orgOsgiServiceHttpPortSecure@TypeHint;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param proxyHost 
     * @param proxyHost@TypeHint 
     * @param proxyPort 
     * @param proxyPort@TypeHint 
     * @param proxyExceptions 
     * @param proxyExceptions@TypeHint 
     * @param proxyEnabled 
     * @param proxyEnabled@TypeHint 
     * @param proxyUser 
     * @param proxyUser@TypeHint 
     * @param proxyPassword 
     * @param proxyPassword@TypeHint 
     */
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/apps/system/config/org.apache.http.proxyconfigurator.config';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (proxyHost !== null && proxyHost !== undefined) {
            queryParameters['proxy.host'] = <string><any>proxyHost;
        }
        if (proxyHost@TypeHint !== null && proxyHost@TypeHint !== undefined) {
            queryParameters['proxy.host@TypeHint'] = <string><any>proxyHost@TypeHint;
        }
        if (proxyPort !== null && proxyPort !== undefined) {
            queryParameters['proxy.port'] = <string><any>proxyPort;
        }
        if (proxyPort@TypeHint !== null && proxyPort@TypeHint !== undefined) {
            queryParameters['proxy.port@TypeHint'] = <string><any>proxyPort@TypeHint;
        }
        if (proxyExceptions) {
            proxyExceptions.forEach((element: any) => {
                queryParameters['proxy.exceptions'].push(element);
            });
        }
        if (proxyExceptions@TypeHint !== null && proxyExceptions@TypeHint !== undefined) {
            queryParameters['proxy.exceptions@TypeHint'] = <string><any>proxyExceptions@TypeHint;
        }
        if (proxyEnabled !== null && proxyEnabled !== undefined) {
            queryParameters['proxy.enabled'] = <string><any>proxyEnabled;
        }
        if (proxyEnabled@TypeHint !== null && proxyEnabled@TypeHint !== undefined) {
            queryParameters['proxy.enabled@TypeHint'] = <string><any>proxyEnabled@TypeHint;
        }
        if (proxyUser !== null && proxyUser !== undefined) {
            queryParameters['proxy.user'] = <string><any>proxyUser;
        }
        if (proxyUser@TypeHint !== null && proxyUser@TypeHint !== undefined) {
            queryParameters['proxy.user@TypeHint'] = <string><any>proxyUser@TypeHint;
        }
        if (proxyPassword !== null && proxyPassword !== undefined) {
            queryParameters['proxy.password'] = <string><any>proxyPassword;
        }
        if (proxyPassword@TypeHint !== null && proxyPassword@TypeHint !== undefined) {
            queryParameters['proxy.password@TypeHint'] = <string><any>proxyPassword@TypeHint;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param alias 
     * @param alias@TypeHint 
     * @param davCreateAbsoluteUri 
     * @param davCreateAbsoluteUri@TypeHint 
     */
    public postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (alias !== null && alias !== undefined) {
            queryParameters['alias'] = <string><any>alias;
        }
        if (alias@TypeHint !== null && alias@TypeHint !== undefined) {
            queryParameters['alias@TypeHint'] = <string><any>alias@TypeHint;
        }
        if (davCreateAbsoluteUri !== null && davCreateAbsoluteUri !== undefined) {
            queryParameters['dav.create-absolute-uri'] = <string><any>davCreateAbsoluteUri;
        }
        if (davCreateAbsoluteUri@TypeHint !== null && davCreateAbsoluteUri@TypeHint !== undefined) {
            queryParameters['dav.create-absolute-uri@TypeHint'] = <string><any>davCreateAbsoluteUri@TypeHint;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param jsonMaximumresults 
     * @param jsonMaximumresults@TypeHint 
     * @param enableHtml 
     * @param enableHtml@TypeHint 
     * @param enableTxt 
     * @param enableTxt@TypeHint 
     * @param enableXml 
     * @param enableXml@TypeHint 
     */
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (jsonMaximumresults !== null && jsonMaximumresults !== undefined) {
            queryParameters['json.maximumresults'] = <string><any>jsonMaximumresults;
        }
        if (jsonMaximumresults@TypeHint !== null && jsonMaximumresults@TypeHint !== undefined) {
            queryParameters['json.maximumresults@TypeHint'] = <string><any>jsonMaximumresults@TypeHint;
        }
        if (enableHtml !== null && enableHtml !== undefined) {
            queryParameters['enable.html'] = <string><any>enableHtml;
        }
        if (enableHtml@TypeHint !== null && enableHtml@TypeHint !== undefined) {
            queryParameters['enable.html@TypeHint'] = <string><any>enableHtml@TypeHint;
        }
        if (enableTxt !== null && enableTxt !== undefined) {
            queryParameters['enable.txt'] = <string><any>enableTxt;
        }
        if (enableTxt@TypeHint !== null && enableTxt@TypeHint !== undefined) {
            queryParameters['enable.txt@TypeHint'] = <string><any>enableTxt@TypeHint;
        }
        if (enableXml !== null && enableXml !== undefined) {
            queryParameters['enable.xml'] = <string><any>enableXml;
        }
        if (enableXml@TypeHint !== null && enableXml@TypeHint !== undefined) {
            queryParameters['enable.xml@TypeHint'] = <string><any>enableXml@TypeHint;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param allowEmpty 
     * @param allowEmpty@TypeHint 
     * @param allowHosts 
     * @param allowHosts@TypeHint 
     * @param allowHostsRegexp 
     * @param allowHostsRegexp@TypeHint 
     * @param filterMethods 
     * @param filterMethods@TypeHint 
     */
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/apps/system/config/org.apache.sling.security.impl.ReferrerFilter';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (allowEmpty !== null && allowEmpty !== undefined) {
            queryParameters['allow.empty'] = <string><any>allowEmpty;
        }
        if (allowEmpty@TypeHint !== null && allowEmpty@TypeHint !== undefined) {
            queryParameters['allow.empty@TypeHint'] = <string><any>allowEmpty@TypeHint;
        }
        if (allowHosts !== null && allowHosts !== undefined) {
            queryParameters['allow.hosts'] = <string><any>allowHosts;
        }
        if (allowHosts@TypeHint !== null && allowHosts@TypeHint !== undefined) {
            queryParameters['allow.hosts@TypeHint'] = <string><any>allowHosts@TypeHint;
        }
        if (allowHostsRegexp !== null && allowHostsRegexp !== undefined) {
            queryParameters['allow.hosts.regexp'] = <string><any>allowHostsRegexp;
        }
        if (allowHostsRegexp@TypeHint !== null && allowHostsRegexp@TypeHint !== undefined) {
            queryParameters['allow.hosts.regexp@TypeHint'] = <string><any>allowHostsRegexp@TypeHint;
        }
        if (filterMethods !== null && filterMethods !== undefined) {
            queryParameters['filter.methods'] = <string><any>filterMethods;
        }
        if (filterMethods@TypeHint !== null && filterMethods@TypeHint !== undefined) {
            queryParameters['filter.methods@TypeHint'] = <string><any>filterMethods@TypeHint;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param path 
     * @param name 
     * @param :operation 
     * @param deleteAuthorizable 
     * @param file 
     */
    public postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: any, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{path}/{name}'.replace('{' + 'path' + '}', encodeURIComponent(String(path))).replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = {};
        let formParams = new FormData();
        let reqHasFile = false;

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postNode.');
        }

        if (:operation !== null && :operation !== undefined) {
            queryParameters[':operation'] = <string><any>:operation;
        }
        if (deleteAuthorizable !== null && deleteAuthorizable !== undefined) {
            queryParameters['deleteAuthorizable'] = <string><any>deleteAuthorizable;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        reqHasFile = true;
        formParams.append("file", file);
        // to determine the Content-Type header
        let consumes: string[] = [
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        if (!reqHasFile) {
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }
        requestOptions.data = formParams;
        if (reqHasFile) {
            requestOptions.contentType = false;
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param path 
     * @param name 
     * @param addMembers 
     */
    public postNodeRw(path: string, name: string, addMembers?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{path}/{name}.rw.html'.replace('{' + 'path' + '}', encodeURIComponent(String(path))).replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postNodeRw.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postNodeRw.');
        }

        if (addMembers !== null && addMembers !== undefined) {
            queryParameters['addMembers'] = <string><any>addMembers;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param path 
     * @param jcr:primaryType 
     * @param :name 
     */
    public postPath(path: string, jcr:primaryType: string, :name: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{path}/'.replace('{' + 'path' + '}', encodeURIComponent(String(path)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postPath.');
        }

        // verify required parameter 'jcr:primaryType' is not null or undefined
        if (jcr:primaryType === null || jcr:primaryType === undefined) {
            throw new Error('Required parameter jcr:primaryType was null or undefined when calling postPath.');
        }

        // verify required parameter ':name' is not null or undefined
        if (:name === null || :name === undefined) {
            throw new Error('Required parameter :name was null or undefined when calling postPath.');
        }

        if (jcr:primaryType !== null && jcr:primaryType !== undefined) {
            queryParameters['jcr:primaryType'] = <string><any>jcr:primaryType;
        }
        if (:name !== null && :name !== undefined) {
            queryParameters[':name'] = <string><any>:name;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     */
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: string;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/bin/querybuilder.json';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postQuery.');
        }

        // verify required parameter 'pLimit' is not null or undefined
        if (pLimit === null || pLimit === undefined) {
            throw new Error('Required parameter pLimit was null or undefined when calling postQuery.');
        }

        // verify required parameter '_1property' is not null or undefined
        if (_1property === null || _1property === undefined) {
            throw new Error('Required parameter _1property was null or undefined when calling postQuery.');
        }

        // verify required parameter '_1propertyValue' is not null or undefined
        if (_1propertyValue === null || _1propertyValue === undefined) {
            throw new Error('Required parameter _1propertyValue was null or undefined when calling postQuery.');
        }

        if (path !== null && path !== undefined) {
            queryParameters['path'] = <string><any>path;
        }
        if (pLimit !== null && pLimit !== undefined) {
            queryParameters['p.limit'] = <string><any>pLimit;
        }
        if (_1property !== null && _1property !== undefined) {
            queryParameters['1_property'] = <string><any>_1property;
        }
        if (_1propertyValue !== null && _1propertyValue !== undefined) {
            queryParameters['1_property.value'] = <string><any>_1propertyValue;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: string;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: string, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param ignoredeactivated 
     * @param onlymodified 
     * @param path 
     */
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/replication/treeactivation.html';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'ignoredeactivated' is not null or undefined
        if (ignoredeactivated === null || ignoredeactivated === undefined) {
            throw new Error('Required parameter ignoredeactivated was null or undefined when calling postTreeActivation.');
        }

        // verify required parameter 'onlymodified' is not null or undefined
        if (onlymodified === null || onlymodified === undefined) {
            throw new Error('Required parameter onlymodified was null or undefined when calling postTreeActivation.');
        }

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postTreeActivation.');
        }

        if (ignoredeactivated !== null && ignoredeactivated !== undefined) {
            queryParameters['ignoredeactivated'] = <string><any>ignoredeactivated;
        }
        if (onlymodified !== null && onlymodified !== undefined) {
            queryParameters['onlymodified'] = <string><any>onlymodified;
        }
        if (path !== null && path !== undefined) {
            queryParameters['path'] = <string><any>path;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param :operation 
     * @param newPassword 
     * @param rePassword 
     * @param keyStoreType 
     * @param removeAlias 
     * @param certificate 
     */
    public postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: any, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: string;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/libs/granite/security/post/truststore';

        let queryParameters: any = {};
        let headerParams: any = {};
        let formParams = new FormData();
        let reqHasFile = false;

        if (:operation !== null && :operation !== undefined) {
            queryParameters[':operation'] = <string><any>:operation;
        }
        if (newPassword !== null && newPassword !== undefined) {
            queryParameters['newPassword'] = <string><any>newPassword;
        }
        if (rePassword !== null && rePassword !== undefined) {
            queryParameters['rePassword'] = <string><any>rePassword;
        }
        if (keyStoreType !== null && keyStoreType !== undefined) {
            queryParameters['keyStoreType'] = <string><any>keyStoreType;
        }
        if (removeAlias !== null && removeAlias !== undefined) {
            queryParameters['removeAlias'] = <string><any>removeAlias;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        reqHasFile = true;
        formParams.append("certificate", certificate);
        // to determine the Content-Type header
        let consumes: string[] = [
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        if (!reqHasFile) {
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }
        requestOptions.data = formParams;
        if (reqHasFile) {
            requestOptions.contentType = false;
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: string;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: string, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param truststoreP12 
     */
    public postTruststorePKCS12(truststoreP12?: any, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: string;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/truststore';

        let queryParameters: any = {};
        let headerParams: any = {};
        let formParams = new FormData();
        let reqHasFile = false;


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        reqHasFile = true;
        formParams.append("truststore.p12", truststoreP12);
        // to determine the Content-Type header
        let consumes: string[] = [
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        if (!reqHasFile) {
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }
        requestOptions.data = formParams;
        if (reqHasFile) {
            requestOptions.contentType = false;
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: string;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: string, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

}
