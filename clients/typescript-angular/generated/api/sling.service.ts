/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * OpenAPI spec version: 3.2.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { KeystoreInfo } from '../model/keystoreInfo';
import { TruststoreInfo } from '../model/truststoreInfo';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class SlingService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {

        if (configuration) {
            this.configuration = configuration;
            this.configuration.basePath = configuration.basePath || basePath || this.basePath;

        } else {
            this.configuration.basePath = basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * 
     * @param runmode 
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteAgent(runmode: string, name: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteAgent(runmode: string, name: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteAgent(runmode: string, name: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteAgent(runmode: string, name: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling deleteAgent.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteAgent.');
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.configuration.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}/${encodeURIComponent(String(name))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteNode(path: string, name: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteNode(path: string, name: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteNode(path: string, name: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteNode(path: string, name: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling deleteNode.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNode.');
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.configuration.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param runmode 
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAgent(runmode: string, name: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getAgent(runmode: string, name: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getAgent(runmode: string, name: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getAgent(runmode: string, name: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling getAgent.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getAgent.');
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}/${encodeURIComponent(String(name))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param runmode 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAgents(runmode: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getAgents(runmode: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getAgents(runmode: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getAgents(runmode: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling getAgents.');
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<string>(`${this.configuration.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}.-1.json`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param intermediatePath 
     * @param authorizableId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, observe?: 'body', reportProgress?: boolean): Observable<KeystoreInfo>;
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<KeystoreInfo>>;
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<KeystoreInfo>>;
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling getAuthorizableKeystore.');
        }
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling getAuthorizableKeystore.');
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<KeystoreInfo>(`${this.configuration.basePath}/${encodeURIComponent(String(intermediatePath))}/${encodeURIComponent(String(authorizableId))}.ks.json`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param intermediatePath 
     * @param authorizableId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getKeystore(intermediatePath: string, authorizableId: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getKeystore(intermediatePath: string, authorizableId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getKeystore(intermediatePath: string, authorizableId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getKeystore(intermediatePath: string, authorizableId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling getKeystore.');
        }
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling getKeystore.');
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/octet-stream'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get(`${this.configuration.basePath}/${encodeURIComponent(String(intermediatePath))}/${encodeURIComponent(String(authorizableId))}/keystore/store.p12`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getNode(path: string, name: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getNode(path: string, name: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getNode(path: string, name: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getNode(path: string, name: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getNode.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getNode.');
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param group 
     * @param name 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPackage(group: string, name: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getPackage(group: string, name: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getPackage(group: string, name: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getPackage(group: string, name: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getPackage.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getPackage.');
        }
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getPackage.');
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/octet-stream'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get(`${this.configuration.basePath}/etc/packages/${encodeURIComponent(String(group))}/${encodeURIComponent(String(name))}-${encodeURIComponent(String(version))}.zip`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param group 
     * @param name 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPackageFilter(group: string, name: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getPackageFilter(group: string, name: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getPackageFilter(group: string, name: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getPackageFilter(group: string, name: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getPackageFilter.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getPackageFilter.');
        }
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getPackageFilter.');
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<string>(`${this.configuration.basePath}/etc/packages/${encodeURIComponent(String(group))}/${encodeURIComponent(String(name))}-${encodeURIComponent(String(version))}.zip/jcr:content/vlt:definition/filter.tidy.2.json`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getQuery.');
        }
        if (pLimit === null || pLimit === undefined) {
            throw new Error('Required parameter pLimit was null or undefined when calling getQuery.');
        }
        if (_1property === null || _1property === undefined) {
            throw new Error('Required parameter _1property was null or undefined when calling getQuery.');
        }
        if (_1propertyValue === null || _1propertyValue === undefined) {
            throw new Error('Required parameter _1propertyValue was null or undefined when calling getQuery.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (path !== undefined && path !== null) {
            queryParameters = queryParameters.set('path', <any>path);
        }
        if (pLimit !== undefined && pLimit !== null) {
            queryParameters = queryParameters.set('p.limit', <any>pLimit);
        }
        if (_1property !== undefined && _1property !== null) {
            queryParameters = queryParameters.set('1_property', <any>_1property);
        }
        if (_1propertyValue !== undefined && _1propertyValue !== null) {
            queryParameters = queryParameters.set('1_property.value', <any>_1propertyValue);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<string>(`${this.configuration.basePath}/bin/querybuilder.json`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTruststore(observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getTruststore(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getTruststore(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getTruststore(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/octet-stream'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get(`${this.configuration.basePath}/etc/truststore/truststore.p12`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTruststoreInfo(observe?: 'body', reportProgress?: boolean): Observable<TruststoreInfo>;
    public getTruststoreInfo(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TruststoreInfo>>;
    public getTruststoreInfo(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TruststoreInfo>>;
    public getTruststoreInfo(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TruststoreInfo>(`${this.configuration.basePath}/libs/granite/security/truststore.json`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param runmode 
     * @param name 
     * @param jcr:contentCq:distribute 
     * @param jcr:contentCq:distribute@TypeHint 
     * @param jcr:contentCq:name 
     * @param jcr:contentCq:template 
     * @param jcr:contentEnabled 
     * @param jcr:contentJcr:description 
     * @param jcr:contentJcr:lastModified 
     * @param jcr:contentJcr:lastModifiedBy 
     * @param jcr:contentJcr:mixinTypes 
     * @param jcr:contentJcr:title 
     * @param jcr:contentLogLevel 
     * @param jcr:contentNoStatusUpdate 
     * @param jcr:contentNoVersioning 
     * @param jcr:contentProtocolConnectTimeout 
     * @param jcr:contentProtocolHTTPConnectionClosed 
     * @param jcr:contentProtocolHTTPExpired 
     * @param jcr:contentProtocolHTTPHeaders 
     * @param jcr:contentProtocolHTTPHeaders@TypeHint 
     * @param jcr:contentProtocolHTTPMethod 
     * @param jcr:contentProtocolHTTPSRelaxed 
     * @param jcr:contentProtocolInterface 
     * @param jcr:contentProtocolSocketTimeout 
     * @param jcr:contentProtocolVersion 
     * @param jcr:contentProxyNTLMDomain 
     * @param jcr:contentProxyNTLMHost 
     * @param jcr:contentProxyHost 
     * @param jcr:contentProxyPassword 
     * @param jcr:contentProxyPort 
     * @param jcr:contentProxyUser 
     * @param jcr:contentQueueBatchMaxSize 
     * @param jcr:contentQueueBatchMode 
     * @param jcr:contentQueueBatchWaitTime 
     * @param jcr:contentRetryDelay 
     * @param jcr:contentReverseReplication 
     * @param jcr:contentSerializationType 
     * @param jcr:contentSling:resourceType 
     * @param jcr:contentSsl 
     * @param jcr:contentTransportNTLMDomain 
     * @param jcr:contentTransportNTLMHost 
     * @param jcr:contentTransportPassword 
     * @param jcr:contentTransportUri 
     * @param jcr:contentTransportUser 
     * @param jcr:contentTriggerDistribute 
     * @param jcr:contentTriggerModified 
     * @param jcr:contentTriggerOnOffTime 
     * @param jcr:contentTriggerReceive 
     * @param jcr:contentTriggerSpecific 
     * @param jcr:contentUserId 
     * @param jcr:primaryType 
     * @param :operation 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling postAgent.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postAgent.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (jcr:contentCq:distribute !== undefined && jcr:contentCq:distribute !== null) {
            queryParameters = queryParameters.set('jcr:content/cq:distribute', <any>jcr:contentCq:distribute);
        }
        if (jcr:contentCq:distribute@TypeHint !== undefined && jcr:contentCq:distribute@TypeHint !== null) {
            queryParameters = queryParameters.set('jcr:content/cq:distribute@TypeHint', <any>jcr:contentCq:distribute@TypeHint);
        }
        if (jcr:contentCq:name !== undefined && jcr:contentCq:name !== null) {
            queryParameters = queryParameters.set('jcr:content/cq:name', <any>jcr:contentCq:name);
        }
        if (jcr:contentCq:template !== undefined && jcr:contentCq:template !== null) {
            queryParameters = queryParameters.set('jcr:content/cq:template', <any>jcr:contentCq:template);
        }
        if (jcr:contentEnabled !== undefined && jcr:contentEnabled !== null) {
            queryParameters = queryParameters.set('jcr:content/enabled', <any>jcr:contentEnabled);
        }
        if (jcr:contentJcr:description !== undefined && jcr:contentJcr:description !== null) {
            queryParameters = queryParameters.set('jcr:content/jcr:description', <any>jcr:contentJcr:description);
        }
        if (jcr:contentJcr:lastModified !== undefined && jcr:contentJcr:lastModified !== null) {
            queryParameters = queryParameters.set('jcr:content/jcr:lastModified', <any>jcr:contentJcr:lastModified);
        }
        if (jcr:contentJcr:lastModifiedBy !== undefined && jcr:contentJcr:lastModifiedBy !== null) {
            queryParameters = queryParameters.set('jcr:content/jcr:lastModifiedBy', <any>jcr:contentJcr:lastModifiedBy);
        }
        if (jcr:contentJcr:mixinTypes !== undefined && jcr:contentJcr:mixinTypes !== null) {
            queryParameters = queryParameters.set('jcr:content/jcr:mixinTypes', <any>jcr:contentJcr:mixinTypes);
        }
        if (jcr:contentJcr:title !== undefined && jcr:contentJcr:title !== null) {
            queryParameters = queryParameters.set('jcr:content/jcr:title', <any>jcr:contentJcr:title);
        }
        if (jcr:contentLogLevel !== undefined && jcr:contentLogLevel !== null) {
            queryParameters = queryParameters.set('jcr:content/logLevel', <any>jcr:contentLogLevel);
        }
        if (jcr:contentNoStatusUpdate !== undefined && jcr:contentNoStatusUpdate !== null) {
            queryParameters = queryParameters.set('jcr:content/noStatusUpdate', <any>jcr:contentNoStatusUpdate);
        }
        if (jcr:contentNoVersioning !== undefined && jcr:contentNoVersioning !== null) {
            queryParameters = queryParameters.set('jcr:content/noVersioning', <any>jcr:contentNoVersioning);
        }
        if (jcr:contentProtocolConnectTimeout !== undefined && jcr:contentProtocolConnectTimeout !== null) {
            queryParameters = queryParameters.set('jcr:content/protocolConnectTimeout', <any>jcr:contentProtocolConnectTimeout);
        }
        if (jcr:contentProtocolHTTPConnectionClosed !== undefined && jcr:contentProtocolHTTPConnectionClosed !== null) {
            queryParameters = queryParameters.set('jcr:content/protocolHTTPConnectionClosed', <any>jcr:contentProtocolHTTPConnectionClosed);
        }
        if (jcr:contentProtocolHTTPExpired !== undefined && jcr:contentProtocolHTTPExpired !== null) {
            queryParameters = queryParameters.set('jcr:content/protocolHTTPExpired', <any>jcr:contentProtocolHTTPExpired);
        }
        if (jcr:contentProtocolHTTPHeaders) {
            jcr:contentProtocolHTTPHeaders.forEach((element) => {
                queryParameters = queryParameters.append('jcr:content/protocolHTTPHeaders', <any>element);
            })
        }
        if (jcr:contentProtocolHTTPHeaders@TypeHint !== undefined && jcr:contentProtocolHTTPHeaders@TypeHint !== null) {
            queryParameters = queryParameters.set('jcr:content/protocolHTTPHeaders@TypeHint', <any>jcr:contentProtocolHTTPHeaders@TypeHint);
        }
        if (jcr:contentProtocolHTTPMethod !== undefined && jcr:contentProtocolHTTPMethod !== null) {
            queryParameters = queryParameters.set('jcr:content/protocolHTTPMethod', <any>jcr:contentProtocolHTTPMethod);
        }
        if (jcr:contentProtocolHTTPSRelaxed !== undefined && jcr:contentProtocolHTTPSRelaxed !== null) {
            queryParameters = queryParameters.set('jcr:content/protocolHTTPSRelaxed', <any>jcr:contentProtocolHTTPSRelaxed);
        }
        if (jcr:contentProtocolInterface !== undefined && jcr:contentProtocolInterface !== null) {
            queryParameters = queryParameters.set('jcr:content/protocolInterface', <any>jcr:contentProtocolInterface);
        }
        if (jcr:contentProtocolSocketTimeout !== undefined && jcr:contentProtocolSocketTimeout !== null) {
            queryParameters = queryParameters.set('jcr:content/protocolSocketTimeout', <any>jcr:contentProtocolSocketTimeout);
        }
        if (jcr:contentProtocolVersion !== undefined && jcr:contentProtocolVersion !== null) {
            queryParameters = queryParameters.set('jcr:content/protocolVersion', <any>jcr:contentProtocolVersion);
        }
        if (jcr:contentProxyNTLMDomain !== undefined && jcr:contentProxyNTLMDomain !== null) {
            queryParameters = queryParameters.set('jcr:content/proxyNTLMDomain', <any>jcr:contentProxyNTLMDomain);
        }
        if (jcr:contentProxyNTLMHost !== undefined && jcr:contentProxyNTLMHost !== null) {
            queryParameters = queryParameters.set('jcr:content/proxyNTLMHost', <any>jcr:contentProxyNTLMHost);
        }
        if (jcr:contentProxyHost !== undefined && jcr:contentProxyHost !== null) {
            queryParameters = queryParameters.set('jcr:content/proxyHost', <any>jcr:contentProxyHost);
        }
        if (jcr:contentProxyPassword !== undefined && jcr:contentProxyPassword !== null) {
            queryParameters = queryParameters.set('jcr:content/proxyPassword', <any>jcr:contentProxyPassword);
        }
        if (jcr:contentProxyPort !== undefined && jcr:contentProxyPort !== null) {
            queryParameters = queryParameters.set('jcr:content/proxyPort', <any>jcr:contentProxyPort);
        }
        if (jcr:contentProxyUser !== undefined && jcr:contentProxyUser !== null) {
            queryParameters = queryParameters.set('jcr:content/proxyUser', <any>jcr:contentProxyUser);
        }
        if (jcr:contentQueueBatchMaxSize !== undefined && jcr:contentQueueBatchMaxSize !== null) {
            queryParameters = queryParameters.set('jcr:content/queueBatchMaxSize', <any>jcr:contentQueueBatchMaxSize);
        }
        if (jcr:contentQueueBatchMode !== undefined && jcr:contentQueueBatchMode !== null) {
            queryParameters = queryParameters.set('jcr:content/queueBatchMode', <any>jcr:contentQueueBatchMode);
        }
        if (jcr:contentQueueBatchWaitTime !== undefined && jcr:contentQueueBatchWaitTime !== null) {
            queryParameters = queryParameters.set('jcr:content/queueBatchWaitTime', <any>jcr:contentQueueBatchWaitTime);
        }
        if (jcr:contentRetryDelay !== undefined && jcr:contentRetryDelay !== null) {
            queryParameters = queryParameters.set('jcr:content/retryDelay', <any>jcr:contentRetryDelay);
        }
        if (jcr:contentReverseReplication !== undefined && jcr:contentReverseReplication !== null) {
            queryParameters = queryParameters.set('jcr:content/reverseReplication', <any>jcr:contentReverseReplication);
        }
        if (jcr:contentSerializationType !== undefined && jcr:contentSerializationType !== null) {
            queryParameters = queryParameters.set('jcr:content/serializationType', <any>jcr:contentSerializationType);
        }
        if (jcr:contentSling:resourceType !== undefined && jcr:contentSling:resourceType !== null) {
            queryParameters = queryParameters.set('jcr:content/sling:resourceType', <any>jcr:contentSling:resourceType);
        }
        if (jcr:contentSsl !== undefined && jcr:contentSsl !== null) {
            queryParameters = queryParameters.set('jcr:content/ssl', <any>jcr:contentSsl);
        }
        if (jcr:contentTransportNTLMDomain !== undefined && jcr:contentTransportNTLMDomain !== null) {
            queryParameters = queryParameters.set('jcr:content/transportNTLMDomain', <any>jcr:contentTransportNTLMDomain);
        }
        if (jcr:contentTransportNTLMHost !== undefined && jcr:contentTransportNTLMHost !== null) {
            queryParameters = queryParameters.set('jcr:content/transportNTLMHost', <any>jcr:contentTransportNTLMHost);
        }
        if (jcr:contentTransportPassword !== undefined && jcr:contentTransportPassword !== null) {
            queryParameters = queryParameters.set('jcr:content/transportPassword', <any>jcr:contentTransportPassword);
        }
        if (jcr:contentTransportUri !== undefined && jcr:contentTransportUri !== null) {
            queryParameters = queryParameters.set('jcr:content/transportUri', <any>jcr:contentTransportUri);
        }
        if (jcr:contentTransportUser !== undefined && jcr:contentTransportUser !== null) {
            queryParameters = queryParameters.set('jcr:content/transportUser', <any>jcr:contentTransportUser);
        }
        if (jcr:contentTriggerDistribute !== undefined && jcr:contentTriggerDistribute !== null) {
            queryParameters = queryParameters.set('jcr:content/triggerDistribute', <any>jcr:contentTriggerDistribute);
        }
        if (jcr:contentTriggerModified !== undefined && jcr:contentTriggerModified !== null) {
            queryParameters = queryParameters.set('jcr:content/triggerModified', <any>jcr:contentTriggerModified);
        }
        if (jcr:contentTriggerOnOffTime !== undefined && jcr:contentTriggerOnOffTime !== null) {
            queryParameters = queryParameters.set('jcr:content/triggerOnOffTime', <any>jcr:contentTriggerOnOffTime);
        }
        if (jcr:contentTriggerReceive !== undefined && jcr:contentTriggerReceive !== null) {
            queryParameters = queryParameters.set('jcr:content/triggerReceive', <any>jcr:contentTriggerReceive);
        }
        if (jcr:contentTriggerSpecific !== undefined && jcr:contentTriggerSpecific !== null) {
            queryParameters = queryParameters.set('jcr:content/triggerSpecific', <any>jcr:contentTriggerSpecific);
        }
        if (jcr:contentUserId !== undefined && jcr:contentUserId !== null) {
            queryParameters = queryParameters.set('jcr:content/userId', <any>jcr:contentUserId);
        }
        if (jcr:primaryType !== undefined && jcr:primaryType !== null) {
            queryParameters = queryParameters.set('jcr:primaryType', <any>jcr:primaryType);
        }
        if (:operation !== undefined && :operation !== null) {
            queryParameters = queryParameters.set(':operation', <any>:operation);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}/${encodeURIComponent(String(name))}`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param intermediatePath 
     * @param authorizableId 
     * @param :operation 
     * @param currentPassword 
     * @param newPassword 
     * @param rePassword 
     * @param keyPassword 
     * @param keyStorePass 
     * @param alias 
     * @param newAlias 
     * @param removeAlias 
     * @param certChain 
     * @param pk 
     * @param keyStore 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Blob, pk?: Blob, keyStore?: Blob, observe?: 'body', reportProgress?: boolean): Observable<KeystoreInfo>;
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Blob, pk?: Blob, keyStore?: Blob, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<KeystoreInfo>>;
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Blob, pk?: Blob, keyStore?: Blob, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<KeystoreInfo>>;
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Blob, pk?: Blob, keyStore?: Blob, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizableKeystore.');
        }
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizableKeystore.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (:operation !== undefined && :operation !== null) {
            queryParameters = queryParameters.set(':operation', <any>:operation);
        }
        if (currentPassword !== undefined && currentPassword !== null) {
            queryParameters = queryParameters.set('currentPassword', <any>currentPassword);
        }
        if (newPassword !== undefined && newPassword !== null) {
            queryParameters = queryParameters.set('newPassword', <any>newPassword);
        }
        if (rePassword !== undefined && rePassword !== null) {
            queryParameters = queryParameters.set('rePassword', <any>rePassword);
        }
        if (keyPassword !== undefined && keyPassword !== null) {
            queryParameters = queryParameters.set('keyPassword', <any>keyPassword);
        }
        if (keyStorePass !== undefined && keyStorePass !== null) {
            queryParameters = queryParameters.set('keyStorePass', <any>keyStorePass);
        }
        if (alias !== undefined && alias !== null) {
            queryParameters = queryParameters.set('alias', <any>alias);
        }
        if (newAlias !== undefined && newAlias !== null) {
            queryParameters = queryParameters.set('newAlias', <any>newAlias);
        }
        if (removeAlias !== undefined && removeAlias !== null) {
            queryParameters = queryParameters.set('removeAlias', <any>removeAlias);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (certChain !== undefined) {
            formParams = formParams.append('cert-chain', <any>certChain) || formParams;
        }
        if (pk !== undefined) {
            formParams = formParams.append('pk', <any>pk) || formParams;
        }
        if (keyStore !== undefined) {
            formParams = formParams.append('keyStore', <any>keyStore) || formParams;
        }

        return this.httpClient.post<KeystoreInfo>(`${this.configuration.basePath}/${encodeURIComponent(String(intermediatePath))}/${encodeURIComponent(String(authorizableId))}.ks.html`,
            convertFormParamsToString ? formParams.toString() : formParams,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param authorizableId 
     * @param intermediatePath 
     * @param createUser 
     * @param createGroup 
     * @param rep:password 
     * @param profileGivenName 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizables.');
        }
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizables.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (authorizableId !== undefined && authorizableId !== null) {
            queryParameters = queryParameters.set('authorizableId', <any>authorizableId);
        }
        if (intermediatePath !== undefined && intermediatePath !== null) {
            queryParameters = queryParameters.set('intermediatePath', <any>intermediatePath);
        }
        if (createUser !== undefined && createUser !== null) {
            queryParameters = queryParameters.set('createUser', <any>createUser);
        }
        if (createGroup !== undefined && createGroup !== null) {
            queryParameters = queryParameters.set('createGroup', <any>createGroup);
        }
        if (rep:password !== undefined && rep:password !== null) {
            queryParameters = queryParameters.set('rep:password', <any>rep:password);
        }
        if (profileGivenName !== undefined && profileGivenName !== null) {
            queryParameters = queryParameters.set('profile/givenName', <any>profileGivenName);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/html'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<string>(`${this.configuration.basePath}/libs/granite/security/post/authorizables`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param keyStorePassword 
     * @param keyStorePassword@TypeHint 
     * @param serviceRanking 
     * @param serviceRanking@TypeHint 
     * @param idpHttpRedirect 
     * @param idpHttpRedirect@TypeHint 
     * @param createUser 
     * @param createUser@TypeHint 
     * @param defaultRedirectUrl 
     * @param defaultRedirectUrl@TypeHint 
     * @param userIDAttribute 
     * @param userIDAttribute@TypeHint 
     * @param defaultGroups 
     * @param defaultGroups@TypeHint 
     * @param idpCertAlias 
     * @param idpCertAlias@TypeHint 
     * @param addGroupMemberships 
     * @param addGroupMemberships@TypeHint 
     * @param path 
     * @param path@TypeHint 
     * @param synchronizeAttributes 
     * @param synchronizeAttributes@TypeHint 
     * @param clockTolerance 
     * @param clockTolerance@TypeHint 
     * @param groupMembershipAttribute 
     * @param groupMembershipAttribute@TypeHint 
     * @param idpUrl 
     * @param idpUrl@TypeHint 
     * @param logoutUrl 
     * @param logoutUrl@TypeHint 
     * @param serviceProviderEntityId 
     * @param serviceProviderEntityId@TypeHint 
     * @param assertionConsumerServiceURL 
     * @param assertionConsumerServiceURL@TypeHint 
     * @param handleLogout 
     * @param handleLogout@TypeHint 
     * @param spPrivateKeyAlias 
     * @param spPrivateKeyAlias@TypeHint 
     * @param useEncryption 
     * @param useEncryption@TypeHint 
     * @param nameIdFormat 
     * @param nameIdFormat@TypeHint 
     * @param digestMethod 
     * @param digestMethod@TypeHint 
     * @param signatureMethod 
     * @param signatureMethod@TypeHint 
     * @param userIntermediatePath 
     * @param userIntermediatePath@TypeHint 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (keyStorePassword !== undefined && keyStorePassword !== null) {
            queryParameters = queryParameters.set('keyStorePassword', <any>keyStorePassword);
        }
        if (keyStorePassword@TypeHint !== undefined && keyStorePassword@TypeHint !== null) {
            queryParameters = queryParameters.set('keyStorePassword@TypeHint', <any>keyStorePassword@TypeHint);
        }
        if (serviceRanking !== undefined && serviceRanking !== null) {
            queryParameters = queryParameters.set('service.ranking', <any>serviceRanking);
        }
        if (serviceRanking@TypeHint !== undefined && serviceRanking@TypeHint !== null) {
            queryParameters = queryParameters.set('service.ranking@TypeHint', <any>serviceRanking@TypeHint);
        }
        if (idpHttpRedirect !== undefined && idpHttpRedirect !== null) {
            queryParameters = queryParameters.set('idpHttpRedirect', <any>idpHttpRedirect);
        }
        if (idpHttpRedirect@TypeHint !== undefined && idpHttpRedirect@TypeHint !== null) {
            queryParameters = queryParameters.set('idpHttpRedirect@TypeHint', <any>idpHttpRedirect@TypeHint);
        }
        if (createUser !== undefined && createUser !== null) {
            queryParameters = queryParameters.set('createUser', <any>createUser);
        }
        if (createUser@TypeHint !== undefined && createUser@TypeHint !== null) {
            queryParameters = queryParameters.set('createUser@TypeHint', <any>createUser@TypeHint);
        }
        if (defaultRedirectUrl !== undefined && defaultRedirectUrl !== null) {
            queryParameters = queryParameters.set('defaultRedirectUrl', <any>defaultRedirectUrl);
        }
        if (defaultRedirectUrl@TypeHint !== undefined && defaultRedirectUrl@TypeHint !== null) {
            queryParameters = queryParameters.set('defaultRedirectUrl@TypeHint', <any>defaultRedirectUrl@TypeHint);
        }
        if (userIDAttribute !== undefined && userIDAttribute !== null) {
            queryParameters = queryParameters.set('userIDAttribute', <any>userIDAttribute);
        }
        if (userIDAttribute@TypeHint !== undefined && userIDAttribute@TypeHint !== null) {
            queryParameters = queryParameters.set('userIDAttribute@TypeHint', <any>userIDAttribute@TypeHint);
        }
        if (defaultGroups) {
            defaultGroups.forEach((element) => {
                queryParameters = queryParameters.append('defaultGroups', <any>element);
            })
        }
        if (defaultGroups@TypeHint !== undefined && defaultGroups@TypeHint !== null) {
            queryParameters = queryParameters.set('defaultGroups@TypeHint', <any>defaultGroups@TypeHint);
        }
        if (idpCertAlias !== undefined && idpCertAlias !== null) {
            queryParameters = queryParameters.set('idpCertAlias', <any>idpCertAlias);
        }
        if (idpCertAlias@TypeHint !== undefined && idpCertAlias@TypeHint !== null) {
            queryParameters = queryParameters.set('idpCertAlias@TypeHint', <any>idpCertAlias@TypeHint);
        }
        if (addGroupMemberships !== undefined && addGroupMemberships !== null) {
            queryParameters = queryParameters.set('addGroupMemberships', <any>addGroupMemberships);
        }
        if (addGroupMemberships@TypeHint !== undefined && addGroupMemberships@TypeHint !== null) {
            queryParameters = queryParameters.set('addGroupMemberships@TypeHint', <any>addGroupMemberships@TypeHint);
        }
        if (path) {
            path.forEach((element) => {
                queryParameters = queryParameters.append('path', <any>element);
            })
        }
        if (path@TypeHint !== undefined && path@TypeHint !== null) {
            queryParameters = queryParameters.set('path@TypeHint', <any>path@TypeHint);
        }
        if (synchronizeAttributes) {
            synchronizeAttributes.forEach((element) => {
                queryParameters = queryParameters.append('synchronizeAttributes', <any>element);
            })
        }
        if (synchronizeAttributes@TypeHint !== undefined && synchronizeAttributes@TypeHint !== null) {
            queryParameters = queryParameters.set('synchronizeAttributes@TypeHint', <any>synchronizeAttributes@TypeHint);
        }
        if (clockTolerance !== undefined && clockTolerance !== null) {
            queryParameters = queryParameters.set('clockTolerance', <any>clockTolerance);
        }
        if (clockTolerance@TypeHint !== undefined && clockTolerance@TypeHint !== null) {
            queryParameters = queryParameters.set('clockTolerance@TypeHint', <any>clockTolerance@TypeHint);
        }
        if (groupMembershipAttribute !== undefined && groupMembershipAttribute !== null) {
            queryParameters = queryParameters.set('groupMembershipAttribute', <any>groupMembershipAttribute);
        }
        if (groupMembershipAttribute@TypeHint !== undefined && groupMembershipAttribute@TypeHint !== null) {
            queryParameters = queryParameters.set('groupMembershipAttribute@TypeHint', <any>groupMembershipAttribute@TypeHint);
        }
        if (idpUrl !== undefined && idpUrl !== null) {
            queryParameters = queryParameters.set('idpUrl', <any>idpUrl);
        }
        if (idpUrl@TypeHint !== undefined && idpUrl@TypeHint !== null) {
            queryParameters = queryParameters.set('idpUrl@TypeHint', <any>idpUrl@TypeHint);
        }
        if (logoutUrl !== undefined && logoutUrl !== null) {
            queryParameters = queryParameters.set('logoutUrl', <any>logoutUrl);
        }
        if (logoutUrl@TypeHint !== undefined && logoutUrl@TypeHint !== null) {
            queryParameters = queryParameters.set('logoutUrl@TypeHint', <any>logoutUrl@TypeHint);
        }
        if (serviceProviderEntityId !== undefined && serviceProviderEntityId !== null) {
            queryParameters = queryParameters.set('serviceProviderEntityId', <any>serviceProviderEntityId);
        }
        if (serviceProviderEntityId@TypeHint !== undefined && serviceProviderEntityId@TypeHint !== null) {
            queryParameters = queryParameters.set('serviceProviderEntityId@TypeHint', <any>serviceProviderEntityId@TypeHint);
        }
        if (assertionConsumerServiceURL !== undefined && assertionConsumerServiceURL !== null) {
            queryParameters = queryParameters.set('assertionConsumerServiceURL', <any>assertionConsumerServiceURL);
        }
        if (assertionConsumerServiceURL@TypeHint !== undefined && assertionConsumerServiceURL@TypeHint !== null) {
            queryParameters = queryParameters.set('assertionConsumerServiceURL@TypeHint', <any>assertionConsumerServiceURL@TypeHint);
        }
        if (handleLogout !== undefined && handleLogout !== null) {
            queryParameters = queryParameters.set('handleLogout', <any>handleLogout);
        }
        if (handleLogout@TypeHint !== undefined && handleLogout@TypeHint !== null) {
            queryParameters = queryParameters.set('handleLogout@TypeHint', <any>handleLogout@TypeHint);
        }
        if (spPrivateKeyAlias !== undefined && spPrivateKeyAlias !== null) {
            queryParameters = queryParameters.set('spPrivateKeyAlias', <any>spPrivateKeyAlias);
        }
        if (spPrivateKeyAlias@TypeHint !== undefined && spPrivateKeyAlias@TypeHint !== null) {
            queryParameters = queryParameters.set('spPrivateKeyAlias@TypeHint', <any>spPrivateKeyAlias@TypeHint);
        }
        if (useEncryption !== undefined && useEncryption !== null) {
            queryParameters = queryParameters.set('useEncryption', <any>useEncryption);
        }
        if (useEncryption@TypeHint !== undefined && useEncryption@TypeHint !== null) {
            queryParameters = queryParameters.set('useEncryption@TypeHint', <any>useEncryption@TypeHint);
        }
        if (nameIdFormat !== undefined && nameIdFormat !== null) {
            queryParameters = queryParameters.set('nameIdFormat', <any>nameIdFormat);
        }
        if (nameIdFormat@TypeHint !== undefined && nameIdFormat@TypeHint !== null) {
            queryParameters = queryParameters.set('nameIdFormat@TypeHint', <any>nameIdFormat@TypeHint);
        }
        if (digestMethod !== undefined && digestMethod !== null) {
            queryParameters = queryParameters.set('digestMethod', <any>digestMethod);
        }
        if (digestMethod@TypeHint !== undefined && digestMethod@TypeHint !== null) {
            queryParameters = queryParameters.set('digestMethod@TypeHint', <any>digestMethod@TypeHint);
        }
        if (signatureMethod !== undefined && signatureMethod !== null) {
            queryParameters = queryParameters.set('signatureMethod', <any>signatureMethod);
        }
        if (signatureMethod@TypeHint !== undefined && signatureMethod@TypeHint !== null) {
            queryParameters = queryParameters.set('signatureMethod@TypeHint', <any>signatureMethod@TypeHint);
        }
        if (userIntermediatePath !== undefined && userIntermediatePath !== null) {
            queryParameters = queryParameters.set('userIntermediatePath', <any>userIntermediatePath);
        }
        if (userIntermediatePath@TypeHint !== undefined && userIntermediatePath@TypeHint !== null) {
            queryParameters = queryParameters.set('userIntermediatePath@TypeHint', <any>userIntermediatePath@TypeHint);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param orgApacheFelixHttpsNio 
     * @param orgApacheFelixHttpsNio@TypeHint 
     * @param orgApacheFelixHttpsKeystore 
     * @param orgApacheFelixHttpsKeystore@TypeHint 
     * @param orgApacheFelixHttpsKeystorePassword 
     * @param orgApacheFelixHttpsKeystorePassword@TypeHint 
     * @param orgApacheFelixHttpsKeystoreKey 
     * @param orgApacheFelixHttpsKeystoreKey@TypeHint 
     * @param orgApacheFelixHttpsKeystoreKeyPassword 
     * @param orgApacheFelixHttpsKeystoreKeyPassword@TypeHint 
     * @param orgApacheFelixHttpsTruststore 
     * @param orgApacheFelixHttpsTruststore@TypeHint 
     * @param orgApacheFelixHttpsTruststorePassword 
     * @param orgApacheFelixHttpsTruststorePassword@TypeHint 
     * @param orgApacheFelixHttpsClientcertificate 
     * @param orgApacheFelixHttpsClientcertificate@TypeHint 
     * @param orgApacheFelixHttpsEnable 
     * @param orgApacheFelixHttpsEnable@TypeHint 
     * @param orgOsgiServiceHttpPortSecure 
     * @param orgOsgiServiceHttpPortSecure@TypeHint 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (orgApacheFelixHttpsNio !== undefined && orgApacheFelixHttpsNio !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.nio', <any>orgApacheFelixHttpsNio);
        }
        if (orgApacheFelixHttpsNio@TypeHint !== undefined && orgApacheFelixHttpsNio@TypeHint !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.nio@TypeHint', <any>orgApacheFelixHttpsNio@TypeHint);
        }
        if (orgApacheFelixHttpsKeystore !== undefined && orgApacheFelixHttpsKeystore !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.keystore', <any>orgApacheFelixHttpsKeystore);
        }
        if (orgApacheFelixHttpsKeystore@TypeHint !== undefined && orgApacheFelixHttpsKeystore@TypeHint !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.keystore@TypeHint', <any>orgApacheFelixHttpsKeystore@TypeHint);
        }
        if (orgApacheFelixHttpsKeystorePassword !== undefined && orgApacheFelixHttpsKeystorePassword !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.keystore.password', <any>orgApacheFelixHttpsKeystorePassword);
        }
        if (orgApacheFelixHttpsKeystorePassword@TypeHint !== undefined && orgApacheFelixHttpsKeystorePassword@TypeHint !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.keystore.password@TypeHint', <any>orgApacheFelixHttpsKeystorePassword@TypeHint);
        }
        if (orgApacheFelixHttpsKeystoreKey !== undefined && orgApacheFelixHttpsKeystoreKey !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.keystore.key', <any>orgApacheFelixHttpsKeystoreKey);
        }
        if (orgApacheFelixHttpsKeystoreKey@TypeHint !== undefined && orgApacheFelixHttpsKeystoreKey@TypeHint !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.keystore.key@TypeHint', <any>orgApacheFelixHttpsKeystoreKey@TypeHint);
        }
        if (orgApacheFelixHttpsKeystoreKeyPassword !== undefined && orgApacheFelixHttpsKeystoreKeyPassword !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.keystore.key.password', <any>orgApacheFelixHttpsKeystoreKeyPassword);
        }
        if (orgApacheFelixHttpsKeystoreKeyPassword@TypeHint !== undefined && orgApacheFelixHttpsKeystoreKeyPassword@TypeHint !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.keystore.key.password@TypeHint', <any>orgApacheFelixHttpsKeystoreKeyPassword@TypeHint);
        }
        if (orgApacheFelixHttpsTruststore !== undefined && orgApacheFelixHttpsTruststore !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.truststore', <any>orgApacheFelixHttpsTruststore);
        }
        if (orgApacheFelixHttpsTruststore@TypeHint !== undefined && orgApacheFelixHttpsTruststore@TypeHint !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.truststore@TypeHint', <any>orgApacheFelixHttpsTruststore@TypeHint);
        }
        if (orgApacheFelixHttpsTruststorePassword !== undefined && orgApacheFelixHttpsTruststorePassword !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.truststore.password', <any>orgApacheFelixHttpsTruststorePassword);
        }
        if (orgApacheFelixHttpsTruststorePassword@TypeHint !== undefined && orgApacheFelixHttpsTruststorePassword@TypeHint !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.truststore.password@TypeHint', <any>orgApacheFelixHttpsTruststorePassword@TypeHint);
        }
        if (orgApacheFelixHttpsClientcertificate !== undefined && orgApacheFelixHttpsClientcertificate !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.clientcertificate', <any>orgApacheFelixHttpsClientcertificate);
        }
        if (orgApacheFelixHttpsClientcertificate@TypeHint !== undefined && orgApacheFelixHttpsClientcertificate@TypeHint !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.clientcertificate@TypeHint', <any>orgApacheFelixHttpsClientcertificate@TypeHint);
        }
        if (orgApacheFelixHttpsEnable !== undefined && orgApacheFelixHttpsEnable !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.enable', <any>orgApacheFelixHttpsEnable);
        }
        if (orgApacheFelixHttpsEnable@TypeHint !== undefined && orgApacheFelixHttpsEnable@TypeHint !== null) {
            queryParameters = queryParameters.set('org.apache.felix.https.enable@TypeHint', <any>orgApacheFelixHttpsEnable@TypeHint);
        }
        if (orgOsgiServiceHttpPortSecure !== undefined && orgOsgiServiceHttpPortSecure !== null) {
            queryParameters = queryParameters.set('org.osgi.service.http.port.secure', <any>orgOsgiServiceHttpPortSecure);
        }
        if (orgOsgiServiceHttpPortSecure@TypeHint !== undefined && orgOsgiServiceHttpPortSecure@TypeHint !== null) {
            queryParameters = queryParameters.set('org.osgi.service.http.port.secure@TypeHint', <any>orgOsgiServiceHttpPortSecure@TypeHint);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/apps/system/config/org.apache.felix.http`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param proxyHost 
     * @param proxyHost@TypeHint 
     * @param proxyPort 
     * @param proxyPort@TypeHint 
     * @param proxyExceptions 
     * @param proxyExceptions@TypeHint 
     * @param proxyEnabled 
     * @param proxyEnabled@TypeHint 
     * @param proxyUser 
     * @param proxyUser@TypeHint 
     * @param proxyPassword 
     * @param proxyPassword@TypeHint 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (proxyHost !== undefined && proxyHost !== null) {
            queryParameters = queryParameters.set('proxy.host', <any>proxyHost);
        }
        if (proxyHost@TypeHint !== undefined && proxyHost@TypeHint !== null) {
            queryParameters = queryParameters.set('proxy.host@TypeHint', <any>proxyHost@TypeHint);
        }
        if (proxyPort !== undefined && proxyPort !== null) {
            queryParameters = queryParameters.set('proxy.port', <any>proxyPort);
        }
        if (proxyPort@TypeHint !== undefined && proxyPort@TypeHint !== null) {
            queryParameters = queryParameters.set('proxy.port@TypeHint', <any>proxyPort@TypeHint);
        }
        if (proxyExceptions) {
            proxyExceptions.forEach((element) => {
                queryParameters = queryParameters.append('proxy.exceptions', <any>element);
            })
        }
        if (proxyExceptions@TypeHint !== undefined && proxyExceptions@TypeHint !== null) {
            queryParameters = queryParameters.set('proxy.exceptions@TypeHint', <any>proxyExceptions@TypeHint);
        }
        if (proxyEnabled !== undefined && proxyEnabled !== null) {
            queryParameters = queryParameters.set('proxy.enabled', <any>proxyEnabled);
        }
        if (proxyEnabled@TypeHint !== undefined && proxyEnabled@TypeHint !== null) {
            queryParameters = queryParameters.set('proxy.enabled@TypeHint', <any>proxyEnabled@TypeHint);
        }
        if (proxyUser !== undefined && proxyUser !== null) {
            queryParameters = queryParameters.set('proxy.user', <any>proxyUser);
        }
        if (proxyUser@TypeHint !== undefined && proxyUser@TypeHint !== null) {
            queryParameters = queryParameters.set('proxy.user@TypeHint', <any>proxyUser@TypeHint);
        }
        if (proxyPassword !== undefined && proxyPassword !== null) {
            queryParameters = queryParameters.set('proxy.password', <any>proxyPassword);
        }
        if (proxyPassword@TypeHint !== undefined && proxyPassword@TypeHint !== null) {
            queryParameters = queryParameters.set('proxy.password@TypeHint', <any>proxyPassword@TypeHint);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/apps/system/config/org.apache.http.proxyconfigurator.config`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param alias 
     * @param alias@TypeHint 
     * @param davCreateAbsoluteUri 
     * @param davCreateAbsoluteUri@TypeHint 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (alias !== undefined && alias !== null) {
            queryParameters = queryParameters.set('alias', <any>alias);
        }
        if (alias@TypeHint !== undefined && alias@TypeHint !== null) {
            queryParameters = queryParameters.set('alias@TypeHint', <any>alias@TypeHint);
        }
        if (davCreateAbsoluteUri !== undefined && davCreateAbsoluteUri !== null) {
            queryParameters = queryParameters.set('dav.create-absolute-uri', <any>davCreateAbsoluteUri);
        }
        if (davCreateAbsoluteUri@TypeHint !== undefined && davCreateAbsoluteUri@TypeHint !== null) {
            queryParameters = queryParameters.set('dav.create-absolute-uri@TypeHint', <any>davCreateAbsoluteUri@TypeHint);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param jsonMaximumresults 
     * @param jsonMaximumresults@TypeHint 
     * @param enableHtml 
     * @param enableHtml@TypeHint 
     * @param enableTxt 
     * @param enableTxt@TypeHint 
     * @param enableXml 
     * @param enableXml@TypeHint 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (jsonMaximumresults !== undefined && jsonMaximumresults !== null) {
            queryParameters = queryParameters.set('json.maximumresults', <any>jsonMaximumresults);
        }
        if (jsonMaximumresults@TypeHint !== undefined && jsonMaximumresults@TypeHint !== null) {
            queryParameters = queryParameters.set('json.maximumresults@TypeHint', <any>jsonMaximumresults@TypeHint);
        }
        if (enableHtml !== undefined && enableHtml !== null) {
            queryParameters = queryParameters.set('enable.html', <any>enableHtml);
        }
        if (enableHtml@TypeHint !== undefined && enableHtml@TypeHint !== null) {
            queryParameters = queryParameters.set('enable.html@TypeHint', <any>enableHtml@TypeHint);
        }
        if (enableTxt !== undefined && enableTxt !== null) {
            queryParameters = queryParameters.set('enable.txt', <any>enableTxt);
        }
        if (enableTxt@TypeHint !== undefined && enableTxt@TypeHint !== null) {
            queryParameters = queryParameters.set('enable.txt@TypeHint', <any>enableTxt@TypeHint);
        }
        if (enableXml !== undefined && enableXml !== null) {
            queryParameters = queryParameters.set('enable.xml', <any>enableXml);
        }
        if (enableXml@TypeHint !== undefined && enableXml@TypeHint !== null) {
            queryParameters = queryParameters.set('enable.xml@TypeHint', <any>enableXml@TypeHint);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param allowEmpty 
     * @param allowEmpty@TypeHint 
     * @param allowHosts 
     * @param allowHosts@TypeHint 
     * @param allowHostsRegexp 
     * @param allowHostsRegexp@TypeHint 
     * @param filterMethods 
     * @param filterMethods@TypeHint 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (allowEmpty !== undefined && allowEmpty !== null) {
            queryParameters = queryParameters.set('allow.empty', <any>allowEmpty);
        }
        if (allowEmpty@TypeHint !== undefined && allowEmpty@TypeHint !== null) {
            queryParameters = queryParameters.set('allow.empty@TypeHint', <any>allowEmpty@TypeHint);
        }
        if (allowHosts !== undefined && allowHosts !== null) {
            queryParameters = queryParameters.set('allow.hosts', <any>allowHosts);
        }
        if (allowHosts@TypeHint !== undefined && allowHosts@TypeHint !== null) {
            queryParameters = queryParameters.set('allow.hosts@TypeHint', <any>allowHosts@TypeHint);
        }
        if (allowHostsRegexp !== undefined && allowHostsRegexp !== null) {
            queryParameters = queryParameters.set('allow.hosts.regexp', <any>allowHostsRegexp);
        }
        if (allowHostsRegexp@TypeHint !== undefined && allowHostsRegexp@TypeHint !== null) {
            queryParameters = queryParameters.set('allow.hosts.regexp@TypeHint', <any>allowHostsRegexp@TypeHint);
        }
        if (filterMethods !== undefined && filterMethods !== null) {
            queryParameters = queryParameters.set('filter.methods', <any>filterMethods);
        }
        if (filterMethods@TypeHint !== undefined && filterMethods@TypeHint !== null) {
            queryParameters = queryParameters.set('filter.methods@TypeHint', <any>filterMethods@TypeHint);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/apps/system/config/org.apache.sling.security.impl.ReferrerFilter`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param name 
     * @param :operation 
     * @param deleteAuthorizable 
     * @param file 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: Blob, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: Blob, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: Blob, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: Blob, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postNode.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postNode.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (:operation !== undefined && :operation !== null) {
            queryParameters = queryParameters.set(':operation', <any>:operation);
        }
        if (deleteAuthorizable !== undefined && deleteAuthorizable !== null) {
            queryParameters = queryParameters.set('deleteAuthorizable', <any>deleteAuthorizable);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (file !== undefined) {
            formParams = formParams.append('file', <any>file) || formParams;
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}`,
            convertFormParamsToString ? formParams.toString() : formParams,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param name 
     * @param addMembers 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postNodeRw(path: string, name: string, addMembers?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postNodeRw(path: string, name: string, addMembers?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postNodeRw(path: string, name: string, addMembers?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postNodeRw(path: string, name: string, addMembers?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postNodeRw.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postNodeRw.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (addMembers !== undefined && addMembers !== null) {
            queryParameters = queryParameters.set('addMembers', <any>addMembers);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}.rw.html`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param jcr:primaryType 
     * @param :name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postPath(path: string, jcr:primaryType: string, :name: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postPath(path: string, jcr:primaryType: string, :name: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postPath(path: string, jcr:primaryType: string, :name: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postPath(path: string, jcr:primaryType: string, :name: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postPath.');
        }
        if (jcr:primaryType === null || jcr:primaryType === undefined) {
            throw new Error('Required parameter jcr:primaryType was null or undefined when calling postPath.');
        }
        if (:name === null || :name === undefined) {
            throw new Error('Required parameter :name was null or undefined when calling postPath.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (jcr:primaryType !== undefined && jcr:primaryType !== null) {
            queryParameters = queryParameters.set('jcr:primaryType', <any>jcr:primaryType);
        }
        if (:name !== undefined && :name !== null) {
            queryParameters = queryParameters.set(':name', <any>:name);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/${encodeURIComponent(String(path))}/`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postQuery.');
        }
        if (pLimit === null || pLimit === undefined) {
            throw new Error('Required parameter pLimit was null or undefined when calling postQuery.');
        }
        if (_1property === null || _1property === undefined) {
            throw new Error('Required parameter _1property was null or undefined when calling postQuery.');
        }
        if (_1propertyValue === null || _1propertyValue === undefined) {
            throw new Error('Required parameter _1propertyValue was null or undefined when calling postQuery.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (path !== undefined && path !== null) {
            queryParameters = queryParameters.set('path', <any>path);
        }
        if (pLimit !== undefined && pLimit !== null) {
            queryParameters = queryParameters.set('p.limit', <any>pLimit);
        }
        if (_1property !== undefined && _1property !== null) {
            queryParameters = queryParameters.set('1_property', <any>_1property);
        }
        if (_1propertyValue !== undefined && _1propertyValue !== null) {
            queryParameters = queryParameters.set('1_property.value', <any>_1propertyValue);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<string>(`${this.configuration.basePath}/bin/querybuilder.json`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param ignoredeactivated 
     * @param onlymodified 
     * @param path 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (ignoredeactivated === null || ignoredeactivated === undefined) {
            throw new Error('Required parameter ignoredeactivated was null or undefined when calling postTreeActivation.');
        }
        if (onlymodified === null || onlymodified === undefined) {
            throw new Error('Required parameter onlymodified was null or undefined when calling postTreeActivation.');
        }
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postTreeActivation.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (ignoredeactivated !== undefined && ignoredeactivated !== null) {
            queryParameters = queryParameters.set('ignoredeactivated', <any>ignoredeactivated);
        }
        if (onlymodified !== undefined && onlymodified !== null) {
            queryParameters = queryParameters.set('onlymodified', <any>onlymodified);
        }
        if (path !== undefined && path !== null) {
            queryParameters = queryParameters.set('path', <any>path);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/etc/replication/treeactivation.html`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param :operation 
     * @param newPassword 
     * @param rePassword 
     * @param keyStoreType 
     * @param removeAlias 
     * @param certificate 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Blob, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Blob, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Blob, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Blob, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (:operation !== undefined && :operation !== null) {
            queryParameters = queryParameters.set(':operation', <any>:operation);
        }
        if (newPassword !== undefined && newPassword !== null) {
            queryParameters = queryParameters.set('newPassword', <any>newPassword);
        }
        if (rePassword !== undefined && rePassword !== null) {
            queryParameters = queryParameters.set('rePassword', <any>rePassword);
        }
        if (keyStoreType !== undefined && keyStoreType !== null) {
            queryParameters = queryParameters.set('keyStoreType', <any>keyStoreType);
        }
        if (removeAlias !== undefined && removeAlias !== null) {
            queryParameters = queryParameters.set('removeAlias', <any>removeAlias);
        }

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (certificate !== undefined) {
            formParams = formParams.append('certificate', <any>certificate) || formParams;
        }

        return this.httpClient.post<string>(`${this.configuration.basePath}/libs/granite/security/post/truststore`,
            convertFormParamsToString ? formParams.toString() : formParams,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param truststoreP12 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postTruststorePKCS12(truststoreP12?: Blob, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public postTruststorePKCS12(truststoreP12?: Blob, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public postTruststorePKCS12(truststoreP12?: Blob, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public postTruststorePKCS12(truststoreP12?: Blob, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (aemAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (truststoreP12 !== undefined) {
            formParams = formParams.append('truststore.p12', <any>truststoreP12) || formParams;
        }

        return this.httpClient.post<string>(`${this.configuration.basePath}/etc/truststore`,
            convertFormParamsToString ? formParams.toString() : formParams,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
