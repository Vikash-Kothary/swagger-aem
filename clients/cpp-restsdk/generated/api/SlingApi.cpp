/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * OpenAPI spec version: 3.2.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 3.2.1-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include "SlingApi.h"
#include "IHttpBody.h"
#include "JsonBody.h"
#include "MultipartFormData.h"

#include <unordered_set>

#include <boost/algorithm/string/replace.hpp>

namespace org {
namespace openapitools {
namespace client {
namespace api {

using namespace org::openapitools::client::model;

SlingApi::SlingApi( std::shared_ptr<ApiClient> apiClient )
    : m_ApiClient(apiClient)
{
}

SlingApi::~SlingApi()
{
}

pplx::task<void> SlingApi::deleteAgent(utility::string_t runmode, utility::string_t name)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/etc/replication/agents.{runmode}/{name}");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("runmode") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(runmode));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("name") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(name));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->deleteAgent does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->deleteAgent does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling deleteAgent: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling deleteAgent: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> SlingApi::deleteNode(utility::string_t path, utility::string_t name)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/{path}/{name}");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("path") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(path));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("name") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(name));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->deleteNode does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->deleteNode does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling deleteNode: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling deleteNode: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> SlingApi::getAgent(utility::string_t runmode, utility::string_t name)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/etc/replication/agents.{runmode}/{name}");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("runmode") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(runmode));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("name") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(name));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->getAgent does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->getAgent does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling getAgent: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling getAgent: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<utility::string_t> SlingApi::getAgents(utility::string_t runmode)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/etc/replication/agents.{runmode}.-1.json");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("runmode") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(runmode));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    // plain text
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("text/plain")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->getAgents does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->getAgents does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling getAgents: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling getAgents: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        utility::string_t result(utility::conversions::to_string_t(""));

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result = ModelBase::stringFromJson(json);
            
        }
        else if(responseHttpContentType == utility::conversions::to_string_t("text/plain"))
        {
            result = response;
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling getAgents: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<KeystoreInfo>> SlingApi::getAuthorizableKeystore(utility::string_t intermediatePath, utility::string_t authorizableId)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/{intermediatePath}/{authorizableId}.ks.json");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("intermediatePath") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(intermediatePath));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("authorizableId") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(authorizableId));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("text/plain") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->getAuthorizableKeystore does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->getAuthorizableKeystore does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling getAuthorizableKeystore: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling getAuthorizableKeystore: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<KeystoreInfo> result(new KeystoreInfo());

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling getAuthorizableKeystore: unsupported response type"));
        }

        return result;
    });
}
pplx::task<HttpContent> SlingApi::getKeystore(utility::string_t intermediatePath, utility::string_t authorizableId)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/{intermediatePath}/{authorizableId}/keystore/store.p12");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("intermediatePath") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(intermediatePath));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("authorizableId") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(authorizableId));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/octet-stream") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        //It's going to be binary, so just use the first one.
        responseHttpContentType = *responseHttpContentTypes.begin();
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->getKeystore does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling getKeystore: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling getKeystore: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_vector();
    })
    .then([=](std::vector<unsigned char> response)
    {
        HttpContent result;
        std::shared_ptr<std::stringstream> stream = std::make_shared<std::stringstream>(std::string(response.begin(), response.end()));
        result.setData(stream);
        return result;
    });
}
pplx::task<void> SlingApi::getNode(utility::string_t path, utility::string_t name)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/{path}/{name}");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("path") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(path));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("name") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(name));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->getNode does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->getNode does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling getNode: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling getNode: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<HttpContent> SlingApi::getPackage(utility::string_t group, utility::string_t name, utility::string_t version)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/etc/packages/{group}/{name}-{version}.zip");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("group") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(group));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("name") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(name));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("version") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(version));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/octet-stream") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        //It's going to be binary, so just use the first one.
        responseHttpContentType = *responseHttpContentTypes.begin();
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->getPackage does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling getPackage: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling getPackage: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_vector();
    })
    .then([=](std::vector<unsigned char> response)
    {
        HttpContent result;
        std::shared_ptr<std::stringstream> stream = std::make_shared<std::stringstream>(std::string(response.begin(), response.end()));
        result.setData(stream);
        return result;
    });
}
pplx::task<utility::string_t> SlingApi::getPackageFilter(utility::string_t group, utility::string_t name, utility::string_t version)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("group") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(group));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("name") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(name));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("version") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(version));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    // plain text
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("text/plain")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->getPackageFilter does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->getPackageFilter does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling getPackageFilter: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling getPackageFilter: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        utility::string_t result(utility::conversions::to_string_t(""));

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result = ModelBase::stringFromJson(json);
            
        }
        else if(responseHttpContentType == utility::conversions::to_string_t("text/plain"))
        {
            result = response;
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling getPackageFilter: unsupported response type"));
        }

        return result;
    });
}
pplx::task<utility::string_t> SlingApi::getQuery(utility::string_t path, double pPeriodlimit, utility::string_t _1_property, utility::string_t _1_property_value)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/bin/querybuilder.json");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    // plain text
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("text/plain")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->getQuery does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    {
        queryParams[utility::conversions::to_string_t("path")] = ApiClient::parameterToString(path);
    }
    {
        queryParams[utility::conversions::to_string_t("p.limit")] = ApiClient::parameterToString(pPeriodlimit);
    }
    {
        queryParams[utility::conversions::to_string_t("1_property")] = ApiClient::parameterToString(_1_property);
    }
    {
        queryParams[utility::conversions::to_string_t("1_property.value")] = ApiClient::parameterToString(_1_property_value);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->getQuery does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling getQuery: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling getQuery: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        utility::string_t result(utility::conversions::to_string_t(""));

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result = ModelBase::stringFromJson(json);
            
        }
        else if(responseHttpContentType == utility::conversions::to_string_t("text/plain"))
        {
            result = response;
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling getQuery: unsupported response type"));
        }

        return result;
    });
}
pplx::task<HttpContent> SlingApi::getTruststore()
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/etc/truststore/truststore.p12");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/octet-stream") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        //It's going to be binary, so just use the first one.
        responseHttpContentType = *responseHttpContentTypes.begin();
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->getTruststore does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling getTruststore: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling getTruststore: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_vector();
    })
    .then([=](std::vector<unsigned char> response)
    {
        HttpContent result;
        std::shared_ptr<std::stringstream> stream = std::make_shared<std::stringstream>(std::string(response.begin(), response.end()));
        result.setData(stream);
        return result;
    });
}
pplx::task<std::shared_ptr<TruststoreInfo>> SlingApi::getTruststoreInfo()
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/libs/granite/security/truststore.json");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->getTruststoreInfo does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->getTruststoreInfo does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling getTruststoreInfo: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling getTruststoreInfo: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<TruststoreInfo> result(new TruststoreInfo());

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling getTruststoreInfo: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> SlingApi::postAgent(utility::string_t runmode, utility::string_t name, boost::optional<bool> jcrContentSlashcqDistribute, boost::optional<utility::string_t> jcrContentSlashcqDistributeAtTypeHint, boost::optional<utility::string_t> jcrContentSlashcqName, boost::optional<utility::string_t> jcrContentSlashcqTemplate, boost::optional<bool> jcrContentSlashenabled, boost::optional<utility::string_t> jcrContentSlashjcrDescription, boost::optional<utility::string_t> jcrContentSlashjcrLastModified, boost::optional<utility::string_t> jcrContentSlashjcrLastModifiedBy, boost::optional<utility::string_t> jcrContentSlashjcrMixinTypes, boost::optional<utility::string_t> jcrContentSlashjcrTitle, boost::optional<utility::string_t> jcrContentSlashlogLevel, boost::optional<bool> jcrContentSlashnoStatusUpdate, boost::optional<bool> jcrContentSlashnoVersioning, boost::optional<double> jcrContentSlashprotocolConnectTimeout, boost::optional<bool> jcrContentSlashprotocolHTTPConnectionClosed, boost::optional<utility::string_t> jcrContentSlashprotocolHTTPExpired, boost::optional<std::vector<utility::string_t>> jcrContentSlashprotocolHTTPHeaders, boost::optional<utility::string_t> jcrContentSlashprotocolHTTPHeadersAtTypeHint, boost::optional<utility::string_t> jcrContentSlashprotocolHTTPMethod, boost::optional<bool> jcrContentSlashprotocolHTTPSRelaxed, boost::optional<utility::string_t> jcrContentSlashprotocolInterface, boost::optional<double> jcrContentSlashprotocolSocketTimeout, boost::optional<utility::string_t> jcrContentSlashprotocolVersion, boost::optional<utility::string_t> jcrContentSlashproxyNTLMDomain, boost::optional<utility::string_t> jcrContentSlashproxyNTLMHost, boost::optional<utility::string_t> jcrContentSlashproxyHost, boost::optional<utility::string_t> jcrContentSlashproxyPassword, boost::optional<double> jcrContentSlashproxyPort, boost::optional<utility::string_t> jcrContentSlashproxyUser, boost::optional<double> jcrContentSlashqueueBatchMaxSize, boost::optional<utility::string_t> jcrContentSlashqueueBatchMode, boost::optional<double> jcrContentSlashqueueBatchWaitTime, boost::optional<utility::string_t> jcrContentSlashretryDelay, boost::optional<bool> jcrContentSlashreverseReplication, boost::optional<utility::string_t> jcrContentSlashserializationType, boost::optional<utility::string_t> jcrContentSlashslingResourceType, boost::optional<utility::string_t> jcrContentSlashssl, boost::optional<utility::string_t> jcrContentSlashtransportNTLMDomain, boost::optional<utility::string_t> jcrContentSlashtransportNTLMHost, boost::optional<utility::string_t> jcrContentSlashtransportPassword, boost::optional<utility::string_t> jcrContentSlashtransportUri, boost::optional<utility::string_t> jcrContentSlashtransportUser, boost::optional<bool> jcrContentSlashtriggerDistribute, boost::optional<bool> jcrContentSlashtriggerModified, boost::optional<bool> jcrContentSlashtriggerOnOffTime, boost::optional<bool> jcrContentSlashtriggerReceive, boost::optional<bool> jcrContentSlashtriggerSpecific, boost::optional<utility::string_t> jcrContentSlashuserId, boost::optional<utility::string_t> jcrPrimaryType, boost::optional<utility::string_t> operation)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/etc/replication/agents.{runmode}/{name}");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("runmode") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(runmode));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("name") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(name));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postAgent does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    if (jcrContentSlashcqDistribute)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/cq:distribute")] = ApiClient::parameterToString(*jcrContentSlashcqDistribute);
    }
    if (jcrContentSlashcqDistributeAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/cq:distribute@TypeHint")] = ApiClient::parameterToString(*jcrContentSlashcqDistributeAtTypeHint);
    }
    if (jcrContentSlashcqName)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/cq:name")] = ApiClient::parameterToString(*jcrContentSlashcqName);
    }
    if (jcrContentSlashcqTemplate)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/cq:template")] = ApiClient::parameterToString(*jcrContentSlashcqTemplate);
    }
    if (jcrContentSlashenabled)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/enabled")] = ApiClient::parameterToString(*jcrContentSlashenabled);
    }
    if (jcrContentSlashjcrDescription)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/jcr:description")] = ApiClient::parameterToString(*jcrContentSlashjcrDescription);
    }
    if (jcrContentSlashjcrLastModified)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/jcr:lastModified")] = ApiClient::parameterToString(*jcrContentSlashjcrLastModified);
    }
    if (jcrContentSlashjcrLastModifiedBy)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/jcr:lastModifiedBy")] = ApiClient::parameterToString(*jcrContentSlashjcrLastModifiedBy);
    }
    if (jcrContentSlashjcrMixinTypes)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/jcr:mixinTypes")] = ApiClient::parameterToString(*jcrContentSlashjcrMixinTypes);
    }
    if (jcrContentSlashjcrTitle)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/jcr:title")] = ApiClient::parameterToString(*jcrContentSlashjcrTitle);
    }
    if (jcrContentSlashlogLevel)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/logLevel")] = ApiClient::parameterToString(*jcrContentSlashlogLevel);
    }
    if (jcrContentSlashnoStatusUpdate)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/noStatusUpdate")] = ApiClient::parameterToString(*jcrContentSlashnoStatusUpdate);
    }
    if (jcrContentSlashnoVersioning)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/noVersioning")] = ApiClient::parameterToString(*jcrContentSlashnoVersioning);
    }
    if (jcrContentSlashprotocolConnectTimeout)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/protocolConnectTimeout")] = ApiClient::parameterToString(*jcrContentSlashprotocolConnectTimeout);
    }
    if (jcrContentSlashprotocolHTTPConnectionClosed)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/protocolHTTPConnectionClosed")] = ApiClient::parameterToString(*jcrContentSlashprotocolHTTPConnectionClosed);
    }
    if (jcrContentSlashprotocolHTTPExpired)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/protocolHTTPExpired")] = ApiClient::parameterToString(*jcrContentSlashprotocolHTTPExpired);
    }
    if (jcrContentSlashprotocolHTTPHeaders)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/protocolHTTPHeaders")] = ApiClient::parameterToString(*jcrContentSlashprotocolHTTPHeaders);
    }
    if (jcrContentSlashprotocolHTTPHeadersAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/protocolHTTPHeaders@TypeHint")] = ApiClient::parameterToString(*jcrContentSlashprotocolHTTPHeadersAtTypeHint);
    }
    if (jcrContentSlashprotocolHTTPMethod)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/protocolHTTPMethod")] = ApiClient::parameterToString(*jcrContentSlashprotocolHTTPMethod);
    }
    if (jcrContentSlashprotocolHTTPSRelaxed)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/protocolHTTPSRelaxed")] = ApiClient::parameterToString(*jcrContentSlashprotocolHTTPSRelaxed);
    }
    if (jcrContentSlashprotocolInterface)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/protocolInterface")] = ApiClient::parameterToString(*jcrContentSlashprotocolInterface);
    }
    if (jcrContentSlashprotocolSocketTimeout)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/protocolSocketTimeout")] = ApiClient::parameterToString(*jcrContentSlashprotocolSocketTimeout);
    }
    if (jcrContentSlashprotocolVersion)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/protocolVersion")] = ApiClient::parameterToString(*jcrContentSlashprotocolVersion);
    }
    if (jcrContentSlashproxyNTLMDomain)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/proxyNTLMDomain")] = ApiClient::parameterToString(*jcrContentSlashproxyNTLMDomain);
    }
    if (jcrContentSlashproxyNTLMHost)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/proxyNTLMHost")] = ApiClient::parameterToString(*jcrContentSlashproxyNTLMHost);
    }
    if (jcrContentSlashproxyHost)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/proxyHost")] = ApiClient::parameterToString(*jcrContentSlashproxyHost);
    }
    if (jcrContentSlashproxyPassword)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/proxyPassword")] = ApiClient::parameterToString(*jcrContentSlashproxyPassword);
    }
    if (jcrContentSlashproxyPort)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/proxyPort")] = ApiClient::parameterToString(*jcrContentSlashproxyPort);
    }
    if (jcrContentSlashproxyUser)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/proxyUser")] = ApiClient::parameterToString(*jcrContentSlashproxyUser);
    }
    if (jcrContentSlashqueueBatchMaxSize)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/queueBatchMaxSize")] = ApiClient::parameterToString(*jcrContentSlashqueueBatchMaxSize);
    }
    if (jcrContentSlashqueueBatchMode)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/queueBatchMode")] = ApiClient::parameterToString(*jcrContentSlashqueueBatchMode);
    }
    if (jcrContentSlashqueueBatchWaitTime)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/queueBatchWaitTime")] = ApiClient::parameterToString(*jcrContentSlashqueueBatchWaitTime);
    }
    if (jcrContentSlashretryDelay)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/retryDelay")] = ApiClient::parameterToString(*jcrContentSlashretryDelay);
    }
    if (jcrContentSlashreverseReplication)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/reverseReplication")] = ApiClient::parameterToString(*jcrContentSlashreverseReplication);
    }
    if (jcrContentSlashserializationType)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/serializationType")] = ApiClient::parameterToString(*jcrContentSlashserializationType);
    }
    if (jcrContentSlashslingResourceType)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/sling:resourceType")] = ApiClient::parameterToString(*jcrContentSlashslingResourceType);
    }
    if (jcrContentSlashssl)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/ssl")] = ApiClient::parameterToString(*jcrContentSlashssl);
    }
    if (jcrContentSlashtransportNTLMDomain)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/transportNTLMDomain")] = ApiClient::parameterToString(*jcrContentSlashtransportNTLMDomain);
    }
    if (jcrContentSlashtransportNTLMHost)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/transportNTLMHost")] = ApiClient::parameterToString(*jcrContentSlashtransportNTLMHost);
    }
    if (jcrContentSlashtransportPassword)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/transportPassword")] = ApiClient::parameterToString(*jcrContentSlashtransportPassword);
    }
    if (jcrContentSlashtransportUri)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/transportUri")] = ApiClient::parameterToString(*jcrContentSlashtransportUri);
    }
    if (jcrContentSlashtransportUser)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/transportUser")] = ApiClient::parameterToString(*jcrContentSlashtransportUser);
    }
    if (jcrContentSlashtriggerDistribute)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/triggerDistribute")] = ApiClient::parameterToString(*jcrContentSlashtriggerDistribute);
    }
    if (jcrContentSlashtriggerModified)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/triggerModified")] = ApiClient::parameterToString(*jcrContentSlashtriggerModified);
    }
    if (jcrContentSlashtriggerOnOffTime)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/triggerOnOffTime")] = ApiClient::parameterToString(*jcrContentSlashtriggerOnOffTime);
    }
    if (jcrContentSlashtriggerReceive)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/triggerReceive")] = ApiClient::parameterToString(*jcrContentSlashtriggerReceive);
    }
    if (jcrContentSlashtriggerSpecific)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/triggerSpecific")] = ApiClient::parameterToString(*jcrContentSlashtriggerSpecific);
    }
    if (jcrContentSlashuserId)
    {
        queryParams[utility::conversions::to_string_t("jcr:content/userId")] = ApiClient::parameterToString(*jcrContentSlashuserId);
    }
    if (jcrPrimaryType)
    {
        queryParams[utility::conversions::to_string_t("jcr:primaryType")] = ApiClient::parameterToString(*jcrPrimaryType);
    }
    if (operation)
    {
        queryParams[utility::conversions::to_string_t(":operation")] = ApiClient::parameterToString(*operation);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postAgent does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postAgent: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postAgent: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<KeystoreInfo>> SlingApi::postAuthorizableKeystore(utility::string_t intermediatePath, utility::string_t authorizableId, boost::optional<utility::string_t> operation, boost::optional<utility::string_t> currentPassword, boost::optional<utility::string_t> newPassword, boost::optional<utility::string_t> rePassword, boost::optional<utility::string_t> keyPassword, boost::optional<utility::string_t> keyStorePass, boost::optional<utility::string_t> alias, boost::optional<utility::string_t> newAlias, boost::optional<utility::string_t> removeAlias, boost::optional<std::shared_ptr<HttpContent>> certChain, boost::optional<std::shared_ptr<HttpContent>> pk, boost::optional<std::shared_ptr<HttpContent>> keyStore)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/{intermediatePath}/{authorizableId}.ks.html");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("intermediatePath") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(intermediatePath));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("authorizableId") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(authorizableId));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("text/plain") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postAuthorizableKeystore does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( utility::conversions::to_string_t("multipart/form-data") );

    if (operation)
    {
        queryParams[utility::conversions::to_string_t(":operation")] = ApiClient::parameterToString(*operation);
    }
    if (currentPassword)
    {
        queryParams[utility::conversions::to_string_t("currentPassword")] = ApiClient::parameterToString(*currentPassword);
    }
    if (newPassword)
    {
        queryParams[utility::conversions::to_string_t("newPassword")] = ApiClient::parameterToString(*newPassword);
    }
    if (rePassword)
    {
        queryParams[utility::conversions::to_string_t("rePassword")] = ApiClient::parameterToString(*rePassword);
    }
    if (keyPassword)
    {
        queryParams[utility::conversions::to_string_t("keyPassword")] = ApiClient::parameterToString(*keyPassword);
    }
    if (keyStorePass)
    {
        queryParams[utility::conversions::to_string_t("keyStorePass")] = ApiClient::parameterToString(*keyStorePass);
    }
    if (alias)
    {
        queryParams[utility::conversions::to_string_t("alias")] = ApiClient::parameterToString(*alias);
    }
    if (newAlias)
    {
        queryParams[utility::conversions::to_string_t("newAlias")] = ApiClient::parameterToString(*newAlias);
    }
    if (removeAlias)
    {
        queryParams[utility::conversions::to_string_t("removeAlias")] = ApiClient::parameterToString(*removeAlias);
    }
    if (certChain && *certChain != nullptr)
    {
        fileParams[ utility::conversions::to_string_t("cert-chain") ] = *certChain;
    }
    if (pk && *pk != nullptr)
    {
        fileParams[ utility::conversions::to_string_t("pk") ] = *pk;
    }
    if (keyStore && *keyStore != nullptr)
    {
        fileParams[ utility::conversions::to_string_t("keyStore") ] = *keyStore;
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postAuthorizableKeystore does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postAuthorizableKeystore: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postAuthorizableKeystore: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<KeystoreInfo> result(new KeystoreInfo());

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling postAuthorizableKeystore: unsupported response type"));
        }

        return result;
    });
}
pplx::task<utility::string_t> SlingApi::postAuthorizables(utility::string_t authorizableId, utility::string_t intermediatePath, boost::optional<utility::string_t> createUser, boost::optional<utility::string_t> createGroup, boost::optional<utility::string_t> repPassword, boost::optional<utility::string_t> profileSlashgivenName)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/libs/granite/security/post/authorizables");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("text/html") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    // plain text
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("text/plain")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postAuthorizables does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    {
        queryParams[utility::conversions::to_string_t("authorizableId")] = ApiClient::parameterToString(authorizableId);
    }
    {
        queryParams[utility::conversions::to_string_t("intermediatePath")] = ApiClient::parameterToString(intermediatePath);
    }
    if (createUser)
    {
        queryParams[utility::conversions::to_string_t("createUser")] = ApiClient::parameterToString(*createUser);
    }
    if (createGroup)
    {
        queryParams[utility::conversions::to_string_t("createGroup")] = ApiClient::parameterToString(*createGroup);
    }
    if (repPassword)
    {
        queryParams[utility::conversions::to_string_t("rep:password")] = ApiClient::parameterToString(*repPassword);
    }
    if (profileSlashgivenName)
    {
        queryParams[utility::conversions::to_string_t("profile/givenName")] = ApiClient::parameterToString(*profileSlashgivenName);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postAuthorizables does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postAuthorizables: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postAuthorizables: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        utility::string_t result(utility::conversions::to_string_t(""));

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result = ModelBase::stringFromJson(json);
            
        }
        else if(responseHttpContentType == utility::conversions::to_string_t("text/plain"))
        {
            result = response;
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling postAuthorizables: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> SlingApi::postConfigAdobeGraniteSamlAuthenticationHandler(boost::optional<utility::string_t> keyStorePassword, boost::optional<utility::string_t> keyStorePasswordAtTypeHint, boost::optional<int32_t> servicePeriodranking, boost::optional<utility::string_t> servicePeriodrankingAtTypeHint, boost::optional<bool> idpHttpRedirect, boost::optional<utility::string_t> idpHttpRedirectAtTypeHint, boost::optional<bool> createUser, boost::optional<utility::string_t> createUserAtTypeHint, boost::optional<utility::string_t> defaultRedirectUrl, boost::optional<utility::string_t> defaultRedirectUrlAtTypeHint, boost::optional<utility::string_t> userIDAttribute, boost::optional<utility::string_t> userIDAttributeAtTypeHint, boost::optional<std::vector<utility::string_t>> defaultGroups, boost::optional<utility::string_t> defaultGroupsAtTypeHint, boost::optional<utility::string_t> idpCertAlias, boost::optional<utility::string_t> idpCertAliasAtTypeHint, boost::optional<bool> addGroupMemberships, boost::optional<utility::string_t> addGroupMembershipsAtTypeHint, boost::optional<std::vector<utility::string_t>> path, boost::optional<utility::string_t> pathAtTypeHint, boost::optional<std::vector<utility::string_t>> synchronizeAttributes, boost::optional<utility::string_t> synchronizeAttributesAtTypeHint, boost::optional<int32_t> clockTolerance, boost::optional<utility::string_t> clockToleranceAtTypeHint, boost::optional<utility::string_t> groupMembershipAttribute, boost::optional<utility::string_t> groupMembershipAttributeAtTypeHint, boost::optional<utility::string_t> idpUrl, boost::optional<utility::string_t> idpUrlAtTypeHint, boost::optional<utility::string_t> logoutUrl, boost::optional<utility::string_t> logoutUrlAtTypeHint, boost::optional<utility::string_t> serviceProviderEntityId, boost::optional<utility::string_t> serviceProviderEntityIdAtTypeHint, boost::optional<utility::string_t> assertionConsumerServiceURL, boost::optional<utility::string_t> assertionConsumerServiceURLAtTypeHint, boost::optional<bool> handleLogout, boost::optional<utility::string_t> handleLogoutAtTypeHint, boost::optional<utility::string_t> spPrivateKeyAlias, boost::optional<utility::string_t> spPrivateKeyAliasAtTypeHint, boost::optional<bool> useEncryption, boost::optional<utility::string_t> useEncryptionAtTypeHint, boost::optional<utility::string_t> nameIdFormat, boost::optional<utility::string_t> nameIdFormatAtTypeHint, boost::optional<utility::string_t> digestMethod, boost::optional<utility::string_t> digestMethodAtTypeHint, boost::optional<utility::string_t> signatureMethod, boost::optional<utility::string_t> signatureMethodAtTypeHint, boost::optional<utility::string_t> userIntermediatePath, boost::optional<utility::string_t> userIntermediatePathAtTypeHint)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postConfigAdobeGraniteSamlAuthenticationHandler does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    if (keyStorePassword)
    {
        queryParams[utility::conversions::to_string_t("keyStorePassword")] = ApiClient::parameterToString(*keyStorePassword);
    }
    if (keyStorePasswordAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("keyStorePassword@TypeHint")] = ApiClient::parameterToString(*keyStorePasswordAtTypeHint);
    }
    if (servicePeriodranking)
    {
        queryParams[utility::conversions::to_string_t("service.ranking")] = ApiClient::parameterToString(*servicePeriodranking);
    }
    if (servicePeriodrankingAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("service.ranking@TypeHint")] = ApiClient::parameterToString(*servicePeriodrankingAtTypeHint);
    }
    if (idpHttpRedirect)
    {
        queryParams[utility::conversions::to_string_t("idpHttpRedirect")] = ApiClient::parameterToString(*idpHttpRedirect);
    }
    if (idpHttpRedirectAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("idpHttpRedirect@TypeHint")] = ApiClient::parameterToString(*idpHttpRedirectAtTypeHint);
    }
    if (createUser)
    {
        queryParams[utility::conversions::to_string_t("createUser")] = ApiClient::parameterToString(*createUser);
    }
    if (createUserAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("createUser@TypeHint")] = ApiClient::parameterToString(*createUserAtTypeHint);
    }
    if (defaultRedirectUrl)
    {
        queryParams[utility::conversions::to_string_t("defaultRedirectUrl")] = ApiClient::parameterToString(*defaultRedirectUrl);
    }
    if (defaultRedirectUrlAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("defaultRedirectUrl@TypeHint")] = ApiClient::parameterToString(*defaultRedirectUrlAtTypeHint);
    }
    if (userIDAttribute)
    {
        queryParams[utility::conversions::to_string_t("userIDAttribute")] = ApiClient::parameterToString(*userIDAttribute);
    }
    if (userIDAttributeAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("userIDAttribute@TypeHint")] = ApiClient::parameterToString(*userIDAttributeAtTypeHint);
    }
    if (defaultGroups)
    {
        queryParams[utility::conversions::to_string_t("defaultGroups")] = ApiClient::parameterToString(*defaultGroups);
    }
    if (defaultGroupsAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("defaultGroups@TypeHint")] = ApiClient::parameterToString(*defaultGroupsAtTypeHint);
    }
    if (idpCertAlias)
    {
        queryParams[utility::conversions::to_string_t("idpCertAlias")] = ApiClient::parameterToString(*idpCertAlias);
    }
    if (idpCertAliasAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("idpCertAlias@TypeHint")] = ApiClient::parameterToString(*idpCertAliasAtTypeHint);
    }
    if (addGroupMemberships)
    {
        queryParams[utility::conversions::to_string_t("addGroupMemberships")] = ApiClient::parameterToString(*addGroupMemberships);
    }
    if (addGroupMembershipsAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("addGroupMemberships@TypeHint")] = ApiClient::parameterToString(*addGroupMembershipsAtTypeHint);
    }
    if (path)
    {
        queryParams[utility::conversions::to_string_t("path")] = ApiClient::parameterToString(*path);
    }
    if (pathAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("path@TypeHint")] = ApiClient::parameterToString(*pathAtTypeHint);
    }
    if (synchronizeAttributes)
    {
        queryParams[utility::conversions::to_string_t("synchronizeAttributes")] = ApiClient::parameterToString(*synchronizeAttributes);
    }
    if (synchronizeAttributesAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("synchronizeAttributes@TypeHint")] = ApiClient::parameterToString(*synchronizeAttributesAtTypeHint);
    }
    if (clockTolerance)
    {
        queryParams[utility::conversions::to_string_t("clockTolerance")] = ApiClient::parameterToString(*clockTolerance);
    }
    if (clockToleranceAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("clockTolerance@TypeHint")] = ApiClient::parameterToString(*clockToleranceAtTypeHint);
    }
    if (groupMembershipAttribute)
    {
        queryParams[utility::conversions::to_string_t("groupMembershipAttribute")] = ApiClient::parameterToString(*groupMembershipAttribute);
    }
    if (groupMembershipAttributeAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("groupMembershipAttribute@TypeHint")] = ApiClient::parameterToString(*groupMembershipAttributeAtTypeHint);
    }
    if (idpUrl)
    {
        queryParams[utility::conversions::to_string_t("idpUrl")] = ApiClient::parameterToString(*idpUrl);
    }
    if (idpUrlAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("idpUrl@TypeHint")] = ApiClient::parameterToString(*idpUrlAtTypeHint);
    }
    if (logoutUrl)
    {
        queryParams[utility::conversions::to_string_t("logoutUrl")] = ApiClient::parameterToString(*logoutUrl);
    }
    if (logoutUrlAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("logoutUrl@TypeHint")] = ApiClient::parameterToString(*logoutUrlAtTypeHint);
    }
    if (serviceProviderEntityId)
    {
        queryParams[utility::conversions::to_string_t("serviceProviderEntityId")] = ApiClient::parameterToString(*serviceProviderEntityId);
    }
    if (serviceProviderEntityIdAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("serviceProviderEntityId@TypeHint")] = ApiClient::parameterToString(*serviceProviderEntityIdAtTypeHint);
    }
    if (assertionConsumerServiceURL)
    {
        queryParams[utility::conversions::to_string_t("assertionConsumerServiceURL")] = ApiClient::parameterToString(*assertionConsumerServiceURL);
    }
    if (assertionConsumerServiceURLAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("assertionConsumerServiceURL@TypeHint")] = ApiClient::parameterToString(*assertionConsumerServiceURLAtTypeHint);
    }
    if (handleLogout)
    {
        queryParams[utility::conversions::to_string_t("handleLogout")] = ApiClient::parameterToString(*handleLogout);
    }
    if (handleLogoutAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("handleLogout@TypeHint")] = ApiClient::parameterToString(*handleLogoutAtTypeHint);
    }
    if (spPrivateKeyAlias)
    {
        queryParams[utility::conversions::to_string_t("spPrivateKeyAlias")] = ApiClient::parameterToString(*spPrivateKeyAlias);
    }
    if (spPrivateKeyAliasAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("spPrivateKeyAlias@TypeHint")] = ApiClient::parameterToString(*spPrivateKeyAliasAtTypeHint);
    }
    if (useEncryption)
    {
        queryParams[utility::conversions::to_string_t("useEncryption")] = ApiClient::parameterToString(*useEncryption);
    }
    if (useEncryptionAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("useEncryption@TypeHint")] = ApiClient::parameterToString(*useEncryptionAtTypeHint);
    }
    if (nameIdFormat)
    {
        queryParams[utility::conversions::to_string_t("nameIdFormat")] = ApiClient::parameterToString(*nameIdFormat);
    }
    if (nameIdFormatAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("nameIdFormat@TypeHint")] = ApiClient::parameterToString(*nameIdFormatAtTypeHint);
    }
    if (digestMethod)
    {
        queryParams[utility::conversions::to_string_t("digestMethod")] = ApiClient::parameterToString(*digestMethod);
    }
    if (digestMethodAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("digestMethod@TypeHint")] = ApiClient::parameterToString(*digestMethodAtTypeHint);
    }
    if (signatureMethod)
    {
        queryParams[utility::conversions::to_string_t("signatureMethod")] = ApiClient::parameterToString(*signatureMethod);
    }
    if (signatureMethodAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("signatureMethod@TypeHint")] = ApiClient::parameterToString(*signatureMethodAtTypeHint);
    }
    if (userIntermediatePath)
    {
        queryParams[utility::conversions::to_string_t("userIntermediatePath")] = ApiClient::parameterToString(*userIntermediatePath);
    }
    if (userIntermediatePathAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("userIntermediatePath@TypeHint")] = ApiClient::parameterToString(*userIntermediatePathAtTypeHint);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postConfigAdobeGraniteSamlAuthenticationHandler does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postConfigAdobeGraniteSamlAuthenticationHandler: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postConfigAdobeGraniteSamlAuthenticationHandler: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> SlingApi::postConfigApacheFelixJettyBasedHttpService(boost::optional<bool> orgPeriodapachePeriodfelixPeriodhttpsPeriodnio, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodnioAtTypeHint, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystore, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreAtTypeHint, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpassword, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordAtTypeHint, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkey, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyAtTypeHint, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpassword, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordAtTypeHint, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststore, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreAtTypeHint, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpassword, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordAtTypeHint, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificate, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateAtTypeHint, boost::optional<bool> orgPeriodapachePeriodfelixPeriodhttpsPeriodenable, boost::optional<utility::string_t> orgPeriodapachePeriodfelixPeriodhttpsPeriodenableAtTypeHint, boost::optional<utility::string_t> orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecure, boost::optional<utility::string_t> orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureAtTypeHint)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/apps/system/config/org.apache.felix.http");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postConfigApacheFelixJettyBasedHttpService does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodnio)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.nio")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodnio);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodnioAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.nio@TypeHint")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodnioAtTypeHint);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystore)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.keystore")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystore);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.keystore@TypeHint")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreAtTypeHint);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpassword)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.keystore.password")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpassword);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.keystore.password@TypeHint")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordAtTypeHint);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkey)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.keystore.key")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkey);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.keystore.key@TypeHint")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyAtTypeHint);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpassword)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.keystore.key.password")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpassword);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.keystore.key.password@TypeHint")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordAtTypeHint);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststore)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.truststore")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststore);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.truststore@TypeHint")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreAtTypeHint);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpassword)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.truststore.password")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpassword);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.truststore.password@TypeHint")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordAtTypeHint);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificate)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.clientcertificate")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificate);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.clientcertificate@TypeHint")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateAtTypeHint);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodenable)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.enable")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodenable);
    }
    if (orgPeriodapachePeriodfelixPeriodhttpsPeriodenableAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("org.apache.felix.https.enable@TypeHint")] = ApiClient::parameterToString(*orgPeriodapachePeriodfelixPeriodhttpsPeriodenableAtTypeHint);
    }
    if (orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecure)
    {
        queryParams[utility::conversions::to_string_t("org.osgi.service.http.port.secure")] = ApiClient::parameterToString(*orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecure);
    }
    if (orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("org.osgi.service.http.port.secure@TypeHint")] = ApiClient::parameterToString(*orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureAtTypeHint);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postConfigApacheFelixJettyBasedHttpService does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postConfigApacheFelixJettyBasedHttpService: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postConfigApacheFelixJettyBasedHttpService: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> SlingApi::postConfigApacheHttpComponentsProxyConfiguration(boost::optional<utility::string_t> proxyPeriodhost, boost::optional<utility::string_t> proxyPeriodhostAtTypeHint, boost::optional<int32_t> proxyPeriodport, boost::optional<utility::string_t> proxyPeriodportAtTypeHint, boost::optional<std::vector<utility::string_t>> proxyPeriodexceptions, boost::optional<utility::string_t> proxyPeriodexceptionsAtTypeHint, boost::optional<bool> proxyPeriodenabled, boost::optional<utility::string_t> proxyPeriodenabledAtTypeHint, boost::optional<utility::string_t> proxyPerioduser, boost::optional<utility::string_t> proxyPerioduserAtTypeHint, boost::optional<utility::string_t> proxyPeriodpassword, boost::optional<utility::string_t> proxyPeriodpasswordAtTypeHint)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/apps/system/config/org.apache.http.proxyconfigurator.config");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postConfigApacheHttpComponentsProxyConfiguration does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    if (proxyPeriodhost)
    {
        queryParams[utility::conversions::to_string_t("proxy.host")] = ApiClient::parameterToString(*proxyPeriodhost);
    }
    if (proxyPeriodhostAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("proxy.host@TypeHint")] = ApiClient::parameterToString(*proxyPeriodhostAtTypeHint);
    }
    if (proxyPeriodport)
    {
        queryParams[utility::conversions::to_string_t("proxy.port")] = ApiClient::parameterToString(*proxyPeriodport);
    }
    if (proxyPeriodportAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("proxy.port@TypeHint")] = ApiClient::parameterToString(*proxyPeriodportAtTypeHint);
    }
    if (proxyPeriodexceptions)
    {
        queryParams[utility::conversions::to_string_t("proxy.exceptions")] = ApiClient::parameterToString(*proxyPeriodexceptions);
    }
    if (proxyPeriodexceptionsAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("proxy.exceptions@TypeHint")] = ApiClient::parameterToString(*proxyPeriodexceptionsAtTypeHint);
    }
    if (proxyPeriodenabled)
    {
        queryParams[utility::conversions::to_string_t("proxy.enabled")] = ApiClient::parameterToString(*proxyPeriodenabled);
    }
    if (proxyPeriodenabledAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("proxy.enabled@TypeHint")] = ApiClient::parameterToString(*proxyPeriodenabledAtTypeHint);
    }
    if (proxyPerioduser)
    {
        queryParams[utility::conversions::to_string_t("proxy.user")] = ApiClient::parameterToString(*proxyPerioduser);
    }
    if (proxyPerioduserAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("proxy.user@TypeHint")] = ApiClient::parameterToString(*proxyPerioduserAtTypeHint);
    }
    if (proxyPeriodpassword)
    {
        queryParams[utility::conversions::to_string_t("proxy.password")] = ApiClient::parameterToString(*proxyPeriodpassword);
    }
    if (proxyPeriodpasswordAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("proxy.password@TypeHint")] = ApiClient::parameterToString(*proxyPeriodpasswordAtTypeHint);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postConfigApacheHttpComponentsProxyConfiguration does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postConfigApacheHttpComponentsProxyConfiguration: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postConfigApacheHttpComponentsProxyConfiguration: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> SlingApi::postConfigApacheSlingDavExServlet(boost::optional<utility::string_t> alias, boost::optional<utility::string_t> aliasAtTypeHint, boost::optional<bool> davPeriodcreateAbsoluteUri, boost::optional<utility::string_t> davPeriodcreateAbsoluteUriAtTypeHint)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postConfigApacheSlingDavExServlet does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    if (alias)
    {
        queryParams[utility::conversions::to_string_t("alias")] = ApiClient::parameterToString(*alias);
    }
    if (aliasAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("alias@TypeHint")] = ApiClient::parameterToString(*aliasAtTypeHint);
    }
    if (davPeriodcreateAbsoluteUri)
    {
        queryParams[utility::conversions::to_string_t("dav.create-absolute-uri")] = ApiClient::parameterToString(*davPeriodcreateAbsoluteUri);
    }
    if (davPeriodcreateAbsoluteUriAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("dav.create-absolute-uri@TypeHint")] = ApiClient::parameterToString(*davPeriodcreateAbsoluteUriAtTypeHint);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postConfigApacheSlingDavExServlet does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postConfigApacheSlingDavExServlet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postConfigApacheSlingDavExServlet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> SlingApi::postConfigApacheSlingGetServlet(boost::optional<utility::string_t> jsonPeriodmaximumresults, boost::optional<utility::string_t> jsonPeriodmaximumresultsAtTypeHint, boost::optional<bool> enablePeriodhtml, boost::optional<utility::string_t> enablePeriodhtmlAtTypeHint, boost::optional<bool> enablePeriodtxt, boost::optional<utility::string_t> enablePeriodtxtAtTypeHint, boost::optional<bool> enablePeriodxml, boost::optional<utility::string_t> enablePeriodxmlAtTypeHint)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postConfigApacheSlingGetServlet does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    if (jsonPeriodmaximumresults)
    {
        queryParams[utility::conversions::to_string_t("json.maximumresults")] = ApiClient::parameterToString(*jsonPeriodmaximumresults);
    }
    if (jsonPeriodmaximumresultsAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("json.maximumresults@TypeHint")] = ApiClient::parameterToString(*jsonPeriodmaximumresultsAtTypeHint);
    }
    if (enablePeriodhtml)
    {
        queryParams[utility::conversions::to_string_t("enable.html")] = ApiClient::parameterToString(*enablePeriodhtml);
    }
    if (enablePeriodhtmlAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("enable.html@TypeHint")] = ApiClient::parameterToString(*enablePeriodhtmlAtTypeHint);
    }
    if (enablePeriodtxt)
    {
        queryParams[utility::conversions::to_string_t("enable.txt")] = ApiClient::parameterToString(*enablePeriodtxt);
    }
    if (enablePeriodtxtAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("enable.txt@TypeHint")] = ApiClient::parameterToString(*enablePeriodtxtAtTypeHint);
    }
    if (enablePeriodxml)
    {
        queryParams[utility::conversions::to_string_t("enable.xml")] = ApiClient::parameterToString(*enablePeriodxml);
    }
    if (enablePeriodxmlAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("enable.xml@TypeHint")] = ApiClient::parameterToString(*enablePeriodxmlAtTypeHint);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postConfigApacheSlingGetServlet does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postConfigApacheSlingGetServlet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postConfigApacheSlingGetServlet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> SlingApi::postConfigApacheSlingReferrerFilter(boost::optional<bool> allowPeriodempty, boost::optional<utility::string_t> allowPeriodemptyAtTypeHint, boost::optional<utility::string_t> allowPeriodhosts, boost::optional<utility::string_t> allowPeriodhostsAtTypeHint, boost::optional<utility::string_t> allowPeriodhostsPeriodregexp, boost::optional<utility::string_t> allowPeriodhostsPeriodregexpAtTypeHint, boost::optional<utility::string_t> filterPeriodmethods, boost::optional<utility::string_t> filterPeriodmethodsAtTypeHint)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/apps/system/config/org.apache.sling.security.impl.ReferrerFilter");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postConfigApacheSlingReferrerFilter does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    if (allowPeriodempty)
    {
        queryParams[utility::conversions::to_string_t("allow.empty")] = ApiClient::parameterToString(*allowPeriodempty);
    }
    if (allowPeriodemptyAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("allow.empty@TypeHint")] = ApiClient::parameterToString(*allowPeriodemptyAtTypeHint);
    }
    if (allowPeriodhosts)
    {
        queryParams[utility::conversions::to_string_t("allow.hosts")] = ApiClient::parameterToString(*allowPeriodhosts);
    }
    if (allowPeriodhostsAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("allow.hosts@TypeHint")] = ApiClient::parameterToString(*allowPeriodhostsAtTypeHint);
    }
    if (allowPeriodhostsPeriodregexp)
    {
        queryParams[utility::conversions::to_string_t("allow.hosts.regexp")] = ApiClient::parameterToString(*allowPeriodhostsPeriodregexp);
    }
    if (allowPeriodhostsPeriodregexpAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("allow.hosts.regexp@TypeHint")] = ApiClient::parameterToString(*allowPeriodhostsPeriodregexpAtTypeHint);
    }
    if (filterPeriodmethods)
    {
        queryParams[utility::conversions::to_string_t("filter.methods")] = ApiClient::parameterToString(*filterPeriodmethods);
    }
    if (filterPeriodmethodsAtTypeHint)
    {
        queryParams[utility::conversions::to_string_t("filter.methods@TypeHint")] = ApiClient::parameterToString(*filterPeriodmethodsAtTypeHint);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postConfigApacheSlingReferrerFilter does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postConfigApacheSlingReferrerFilter: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postConfigApacheSlingReferrerFilter: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> SlingApi::postNode(utility::string_t path, utility::string_t name, boost::optional<utility::string_t> operation, boost::optional<utility::string_t> deleteAuthorizable, boost::optional<std::shared_ptr<HttpContent>> file)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/{path}/{name}");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("path") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(path));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("name") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(name));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postNode does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( utility::conversions::to_string_t("multipart/form-data") );

    if (operation)
    {
        queryParams[utility::conversions::to_string_t(":operation")] = ApiClient::parameterToString(*operation);
    }
    if (deleteAuthorizable)
    {
        queryParams[utility::conversions::to_string_t("deleteAuthorizable")] = ApiClient::parameterToString(*deleteAuthorizable);
    }
    if (file && *file != nullptr)
    {
        fileParams[ utility::conversions::to_string_t("file") ] = *file;
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postNode does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postNode: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postNode: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> SlingApi::postNodeRw(utility::string_t path, utility::string_t name, boost::optional<utility::string_t> addMembers)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/{path}/{name}.rw.html");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("path") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(path));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("name") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(name));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postNodeRw does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    if (addMembers)
    {
        queryParams[utility::conversions::to_string_t("addMembers")] = ApiClient::parameterToString(*addMembers);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postNodeRw does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postNodeRw: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postNodeRw: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> SlingApi::postPath(utility::string_t path, utility::string_t jcrPrimaryType, utility::string_t name)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/{path}/");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("path") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(path));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postPath does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    {
        queryParams[utility::conversions::to_string_t("jcr:primaryType")] = ApiClient::parameterToString(jcrPrimaryType);
    }
    {
        queryParams[utility::conversions::to_string_t(":name")] = ApiClient::parameterToString(name);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postPath does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postPath: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postPath: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<utility::string_t> SlingApi::postQuery(utility::string_t path, double pPeriodlimit, utility::string_t _1_property, utility::string_t _1_property_value)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/bin/querybuilder.json");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    // plain text
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("text/plain")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postQuery does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    {
        queryParams[utility::conversions::to_string_t("path")] = ApiClient::parameterToString(path);
    }
    {
        queryParams[utility::conversions::to_string_t("p.limit")] = ApiClient::parameterToString(pPeriodlimit);
    }
    {
        queryParams[utility::conversions::to_string_t("1_property")] = ApiClient::parameterToString(_1_property);
    }
    {
        queryParams[utility::conversions::to_string_t("1_property.value")] = ApiClient::parameterToString(_1_property_value);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postQuery does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postQuery: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postQuery: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        utility::string_t result(utility::conversions::to_string_t(""));

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result = ModelBase::stringFromJson(json);
            
        }
        else if(responseHttpContentType == utility::conversions::to_string_t("text/plain"))
        {
            result = response;
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling postQuery: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> SlingApi::postTreeActivation(bool ignoredeactivated, bool onlymodified, utility::string_t path)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/etc/replication/treeactivation.html");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postTreeActivation does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    {
        queryParams[utility::conversions::to_string_t("ignoredeactivated")] = ApiClient::parameterToString(ignoredeactivated);
    }
    {
        queryParams[utility::conversions::to_string_t("onlymodified")] = ApiClient::parameterToString(onlymodified);
    }
    {
        queryParams[utility::conversions::to_string_t("path")] = ApiClient::parameterToString(path);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postTreeActivation does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postTreeActivation: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postTreeActivation: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<utility::string_t> SlingApi::postTruststore(boost::optional<utility::string_t> operation, boost::optional<utility::string_t> newPassword, boost::optional<utility::string_t> rePassword, boost::optional<utility::string_t> keyStoreType, boost::optional<utility::string_t> removeAlias, boost::optional<std::shared_ptr<HttpContent>> certificate)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/libs/granite/security/post/truststore");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("text/plain") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    // plain text
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("text/plain")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postTruststore does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( utility::conversions::to_string_t("multipart/form-data") );

    if (operation)
    {
        queryParams[utility::conversions::to_string_t(":operation")] = ApiClient::parameterToString(*operation);
    }
    if (newPassword)
    {
        queryParams[utility::conversions::to_string_t("newPassword")] = ApiClient::parameterToString(*newPassword);
    }
    if (rePassword)
    {
        queryParams[utility::conversions::to_string_t("rePassword")] = ApiClient::parameterToString(*rePassword);
    }
    if (keyStoreType)
    {
        queryParams[utility::conversions::to_string_t("keyStoreType")] = ApiClient::parameterToString(*keyStoreType);
    }
    if (removeAlias)
    {
        queryParams[utility::conversions::to_string_t("removeAlias")] = ApiClient::parameterToString(*removeAlias);
    }
    if (certificate && *certificate != nullptr)
    {
        fileParams[ utility::conversions::to_string_t("certificate") ] = *certificate;
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postTruststore does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postTruststore: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postTruststore: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        utility::string_t result(utility::conversions::to_string_t(""));

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result = ModelBase::stringFromJson(json);
            
        }
        else if(responseHttpContentType == utility::conversions::to_string_t("text/plain"))
        {
            result = response;
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling postTruststore: unsupported response type"));
        }

        return result;
    });
}
pplx::task<utility::string_t> SlingApi::postTruststorePKCS12(boost::optional<std::shared_ptr<HttpContent>> truststorePeriodp12)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/etc/truststore");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("text/plain") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    // plain text
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("text/plain")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("SlingApi->postTruststorePKCS12 does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( utility::conversions::to_string_t("multipart/form-data") );

    if (truststorePeriodp12 && *truststorePeriodp12 != nullptr)
    {
        fileParams[ utility::conversions::to_string_t("truststore.p12") ] = *truststorePeriodp12;
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("SlingApi->postTruststorePKCS12 does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postTruststorePKCS12: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postTruststorePKCS12: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        utility::string_t result(utility::conversions::to_string_t(""));

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result = ModelBase::stringFromJson(json);
            
        }
        else if(responseHttpContentType == utility::conversions::to_string_t("text/plain"))
        {
            result = response;
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling postTruststorePKCS12: unsupported response type"));
        }

        return result;
    });
}

}
}
}
}

