/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * OpenAPI spec version: 3.2.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 3.2.1-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include "ConsoleApi.h"
#include "IHttpBody.h"
#include "JsonBody.h"
#include "MultipartFormData.h"

#include <unordered_set>

#include <boost/algorithm/string/replace.hpp>

namespace org {
namespace openapitools {
namespace client {
namespace api {

using namespace org::openapitools::client::model;

ConsoleApi::ConsoleApi( std::shared_ptr<ApiClient> apiClient )
    : m_ApiClient(apiClient)
{
}

ConsoleApi::~ConsoleApi()
{
}

pplx::task<std::vector<utility::string_t>> ConsoleApi::getAemProductInfo()
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/system/console/status-productinfo.json");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("ConsoleApi->getAemProductInfo does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("ConsoleApi->getAemProductInfo does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling getAemProductInfo: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling getAemProductInfo: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::vector<utility::string_t> result;

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            for( auto& item : json.as_array() )
            {
                result.push_back(ModelBase::stringFromJson(item));
                
            }
            
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling getAemProductInfo: unsupported response type"));
        }

        return result;
    });
}
pplx::task<utility::string_t> ConsoleApi::getConfigMgr()
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/system/console/configMgr");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("text/xml") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    // plain text
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("text/plain")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("text/plain");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("ConsoleApi->getConfigMgr does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("ConsoleApi->getConfigMgr does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling getConfigMgr: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling getConfigMgr: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        utility::string_t result(utility::conversions::to_string_t(""));

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result = ModelBase::stringFromJson(json);
            
        }
        else if(responseHttpContentType == utility::conversions::to_string_t("text/plain"))
        {
            result = response;
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling getConfigMgr: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> ConsoleApi::postBundle(utility::string_t name, utility::string_t action)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/system/console/bundles/{name}");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("name") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(name));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("ConsoleApi->postBundle does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    {
        queryParams[utility::conversions::to_string_t("action")] = ApiClient::parameterToString(action);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("ConsoleApi->postBundle does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postBundle: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postBundle: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> ConsoleApi::postJmxRepository(utility::string_t action)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/system/console/jmx/com.adobe.granite:type=Repository/op/{action}");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("action") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(action));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("ConsoleApi->postJmxRepository does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("ConsoleApi->postJmxRepository does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postJmxRepository: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postJmxRepository: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<SamlConfigurationInfo>> ConsoleApi::postSamlConfiguration(boost::optional<bool> post, boost::optional<bool> apply, boost::optional<bool> _delete, boost::optional<utility::string_t> action, boost::optional<utility::string_t> Dollarlocation, boost::optional<std::vector<utility::string_t>> path, boost::optional<int32_t> servicePeriodranking, boost::optional<utility::string_t> idpUrl, boost::optional<utility::string_t> idpCertAlias, boost::optional<bool> idpHttpRedirect, boost::optional<utility::string_t> serviceProviderEntityId, boost::optional<utility::string_t> assertionConsumerServiceURL, boost::optional<utility::string_t> spPrivateKeyAlias, boost::optional<utility::string_t> keyStorePassword, boost::optional<utility::string_t> defaultRedirectUrl, boost::optional<utility::string_t> userIDAttribute, boost::optional<bool> useEncryption, boost::optional<bool> createUser, boost::optional<bool> addGroupMemberships, boost::optional<utility::string_t> groupMembershipAttribute, boost::optional<std::vector<utility::string_t>> defaultGroups, boost::optional<utility::string_t> nameIdFormat, boost::optional<std::vector<utility::string_t>> synchronizeAttributes, boost::optional<bool> handleLogout, boost::optional<utility::string_t> logoutUrl, boost::optional<int32_t> clockTolerance, boost::optional<utility::string_t> digestMethod, boost::optional<utility::string_t> signatureMethod, boost::optional<utility::string_t> userIntermediatePath, boost::optional<std::vector<utility::string_t>> propertylist)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("text/plain") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("ConsoleApi->postSamlConfiguration does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    if (post)
    {
        queryParams[utility::conversions::to_string_t("post")] = ApiClient::parameterToString(*post);
    }
    if (apply)
    {
        queryParams[utility::conversions::to_string_t("apply")] = ApiClient::parameterToString(*apply);
    }
    if (_delete)
    {
        queryParams[utility::conversions::to_string_t("delete")] = ApiClient::parameterToString(*_delete);
    }
    if (action)
    {
        queryParams[utility::conversions::to_string_t("action")] = ApiClient::parameterToString(*action);
    }
    if (Dollarlocation)
    {
        queryParams[utility::conversions::to_string_t("$location")] = ApiClient::parameterToString(*Dollarlocation);
    }
    if (path)
    {
        queryParams[utility::conversions::to_string_t("path")] = ApiClient::parameterToString(*path);
    }
    if (servicePeriodranking)
    {
        queryParams[utility::conversions::to_string_t("service.ranking")] = ApiClient::parameterToString(*servicePeriodranking);
    }
    if (idpUrl)
    {
        queryParams[utility::conversions::to_string_t("idpUrl")] = ApiClient::parameterToString(*idpUrl);
    }
    if (idpCertAlias)
    {
        queryParams[utility::conversions::to_string_t("idpCertAlias")] = ApiClient::parameterToString(*idpCertAlias);
    }
    if (idpHttpRedirect)
    {
        queryParams[utility::conversions::to_string_t("idpHttpRedirect")] = ApiClient::parameterToString(*idpHttpRedirect);
    }
    if (serviceProviderEntityId)
    {
        queryParams[utility::conversions::to_string_t("serviceProviderEntityId")] = ApiClient::parameterToString(*serviceProviderEntityId);
    }
    if (assertionConsumerServiceURL)
    {
        queryParams[utility::conversions::to_string_t("assertionConsumerServiceURL")] = ApiClient::parameterToString(*assertionConsumerServiceURL);
    }
    if (spPrivateKeyAlias)
    {
        queryParams[utility::conversions::to_string_t("spPrivateKeyAlias")] = ApiClient::parameterToString(*spPrivateKeyAlias);
    }
    if (keyStorePassword)
    {
        queryParams[utility::conversions::to_string_t("keyStorePassword")] = ApiClient::parameterToString(*keyStorePassword);
    }
    if (defaultRedirectUrl)
    {
        queryParams[utility::conversions::to_string_t("defaultRedirectUrl")] = ApiClient::parameterToString(*defaultRedirectUrl);
    }
    if (userIDAttribute)
    {
        queryParams[utility::conversions::to_string_t("userIDAttribute")] = ApiClient::parameterToString(*userIDAttribute);
    }
    if (useEncryption)
    {
        queryParams[utility::conversions::to_string_t("useEncryption")] = ApiClient::parameterToString(*useEncryption);
    }
    if (createUser)
    {
        queryParams[utility::conversions::to_string_t("createUser")] = ApiClient::parameterToString(*createUser);
    }
    if (addGroupMemberships)
    {
        queryParams[utility::conversions::to_string_t("addGroupMemberships")] = ApiClient::parameterToString(*addGroupMemberships);
    }
    if (groupMembershipAttribute)
    {
        queryParams[utility::conversions::to_string_t("groupMembershipAttribute")] = ApiClient::parameterToString(*groupMembershipAttribute);
    }
    if (defaultGroups)
    {
        queryParams[utility::conversions::to_string_t("defaultGroups")] = ApiClient::parameterToString(*defaultGroups);
    }
    if (nameIdFormat)
    {
        queryParams[utility::conversions::to_string_t("nameIdFormat")] = ApiClient::parameterToString(*nameIdFormat);
    }
    if (synchronizeAttributes)
    {
        queryParams[utility::conversions::to_string_t("synchronizeAttributes")] = ApiClient::parameterToString(*synchronizeAttributes);
    }
    if (handleLogout)
    {
        queryParams[utility::conversions::to_string_t("handleLogout")] = ApiClient::parameterToString(*handleLogout);
    }
    if (logoutUrl)
    {
        queryParams[utility::conversions::to_string_t("logoutUrl")] = ApiClient::parameterToString(*logoutUrl);
    }
    if (clockTolerance)
    {
        queryParams[utility::conversions::to_string_t("clockTolerance")] = ApiClient::parameterToString(*clockTolerance);
    }
    if (digestMethod)
    {
        queryParams[utility::conversions::to_string_t("digestMethod")] = ApiClient::parameterToString(*digestMethod);
    }
    if (signatureMethod)
    {
        queryParams[utility::conversions::to_string_t("signatureMethod")] = ApiClient::parameterToString(*signatureMethod);
    }
    if (userIntermediatePath)
    {
        queryParams[utility::conversions::to_string_t("userIntermediatePath")] = ApiClient::parameterToString(*userIntermediatePath);
    }
    if (propertylist)
    {
        queryParams[utility::conversions::to_string_t("propertylist")] = ApiClient::parameterToString(*propertylist);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("ConsoleApi->postSamlConfiguration does not consume any supported media type"));
    }

    // authentication (aemAuth) required
    // Basic authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling postSamlConfiguration: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling postSamlConfiguration: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<SamlConfigurationInfo> result(new SamlConfigurationInfo());

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling postSamlConfiguration: unsupported response type"));
        }

        return result;
    });
}

}
}
}
}

