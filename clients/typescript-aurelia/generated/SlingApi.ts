/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * OpenAPI spec version: 3.2.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { autoinject } from 'aurelia-framework';
import { HttpClient } from 'aurelia-http-client';
import { Api } from './Api';
import { AuthStorage } from './AuthStorage';
import {
  KeystoreInfo,
  TruststoreInfo,
} from './models';

/**
 * deleteAgent - parameters interface
 */
export interface IDeleteAgentParams {
  runmode: string;
  name: string;
}

/**
 * deleteNode - parameters interface
 */
export interface IDeleteNodeParams {
  path: string;
  name: string;
}

/**
 * getAgent - parameters interface
 */
export interface IGetAgentParams {
  runmode: string;
  name: string;
}

/**
 * getAgents - parameters interface
 */
export interface IGetAgentsParams {
  runmode: string;
}

/**
 * getAuthorizableKeystore - parameters interface
 */
export interface IGetAuthorizableKeystoreParams {
  intermediatePath: string;
  authorizableId: string;
}

/**
 * getKeystore - parameters interface
 */
export interface IGetKeystoreParams {
  intermediatePath: string;
  authorizableId: string;
}

/**
 * getNode - parameters interface
 */
export interface IGetNodeParams {
  path: string;
  name: string;
}

/**
 * getPackage - parameters interface
 */
export interface IGetPackageParams {
  group: string;
  name: string;
  version: string;
}

/**
 * getPackageFilter - parameters interface
 */
export interface IGetPackageFilterParams {
  group: string;
  name: string;
  version: string;
}

/**
 * getQuery - parameters interface
 */
export interface IGetQueryParams {
  path: string;
  pLimit: number;
  _1property: string;
  _1propertyValue: string;
}

/**
 * getTruststore - parameters interface
 */
export interface IGetTruststoreParams {
}

/**
 * getTruststoreInfo - parameters interface
 */
export interface IGetTruststoreInfoParams {
}

/**
 * postAgent - parameters interface
 */
export interface IPostAgentParams {
  runmode: string;
  name: string;
  jcr:contentCq:distribute?: boolean;
  jcr:contentCq:distribute@TypeHint?: string;
  jcr:contentCq:name?: string;
  jcr:contentCq:template?: string;
  jcr:contentEnabled?: boolean;
  jcr:contentJcr:description?: string;
  jcr:contentJcr:lastModified?: string;
  jcr:contentJcr:lastModifiedBy?: string;
  jcr:contentJcr:mixinTypes?: string;
  jcr:contentJcr:title?: string;
  jcr:contentLogLevel?: string;
  jcr:contentNoStatusUpdate?: boolean;
  jcr:contentNoVersioning?: boolean;
  jcr:contentProtocolConnectTimeout?: number;
  jcr:contentProtocolHTTPConnectionClosed?: boolean;
  jcr:contentProtocolHTTPExpired?: string;
  jcr:contentProtocolHTTPHeaders?: Array<string>;
  jcr:contentProtocolHTTPHeaders@TypeHint?: string;
  jcr:contentProtocolHTTPMethod?: string;
  jcr:contentProtocolHTTPSRelaxed?: boolean;
  jcr:contentProtocolInterface?: string;
  jcr:contentProtocolSocketTimeout?: number;
  jcr:contentProtocolVersion?: string;
  jcr:contentProxyNTLMDomain?: string;
  jcr:contentProxyNTLMHost?: string;
  jcr:contentProxyHost?: string;
  jcr:contentProxyPassword?: string;
  jcr:contentProxyPort?: number;
  jcr:contentProxyUser?: string;
  jcr:contentQueueBatchMaxSize?: number;
  jcr:contentQueueBatchMode?: string;
  jcr:contentQueueBatchWaitTime?: number;
  jcr:contentRetryDelay?: string;
  jcr:contentReverseReplication?: boolean;
  jcr:contentSerializationType?: string;
  jcr:contentSling:resourceType?: string;
  jcr:contentSsl?: string;
  jcr:contentTransportNTLMDomain?: string;
  jcr:contentTransportNTLMHost?: string;
  jcr:contentTransportPassword?: string;
  jcr:contentTransportUri?: string;
  jcr:contentTransportUser?: string;
  jcr:contentTriggerDistribute?: boolean;
  jcr:contentTriggerModified?: boolean;
  jcr:contentTriggerOnOffTime?: boolean;
  jcr:contentTriggerReceive?: boolean;
  jcr:contentTriggerSpecific?: boolean;
  jcr:contentUserId?: string;
  jcr:primaryType?: string;
  :operation?: string;
}

/**
 * postAuthorizableKeystore - parameters interface
 */
export interface IPostAuthorizableKeystoreParams {
  intermediatePath: string;
  authorizableId: string;
  :operation?: string;
  currentPassword?: string;
  newPassword?: string;
  rePassword?: string;
  keyPassword?: string;
  keyStorePass?: string;
  alias?: string;
  newAlias?: string;
  removeAlias?: string;
  certChain?: any;
  pk?: any;
  keyStore?: any;
}

/**
 * postAuthorizables - parameters interface
 */
export interface IPostAuthorizablesParams {
  authorizableId: string;
  intermediatePath: string;
  createUser?: string;
  createGroup?: string;
  rep:password?: string;
  profileGivenName?: string;
}

/**
 * postConfigAdobeGraniteSamlAuthenticationHandler - parameters interface
 */
export interface IPostConfigAdobeGraniteSamlAuthenticationHandlerParams {
  keyStorePassword?: string;
  keyStorePassword@TypeHint?: string;
  serviceRanking?: number;
  serviceRanking@TypeHint?: string;
  idpHttpRedirect?: boolean;
  idpHttpRedirect@TypeHint?: string;
  createUser?: boolean;
  createUser@TypeHint?: string;
  defaultRedirectUrl?: string;
  defaultRedirectUrl@TypeHint?: string;
  userIDAttribute?: string;
  userIDAttribute@TypeHint?: string;
  defaultGroups?: Array<string>;
  defaultGroups@TypeHint?: string;
  idpCertAlias?: string;
  idpCertAlias@TypeHint?: string;
  addGroupMemberships?: boolean;
  addGroupMemberships@TypeHint?: string;
  path?: Array<string>;
  path@TypeHint?: string;
  synchronizeAttributes?: Array<string>;
  synchronizeAttributes@TypeHint?: string;
  clockTolerance?: number;
  clockTolerance@TypeHint?: string;
  groupMembershipAttribute?: string;
  groupMembershipAttribute@TypeHint?: string;
  idpUrl?: string;
  idpUrl@TypeHint?: string;
  logoutUrl?: string;
  logoutUrl@TypeHint?: string;
  serviceProviderEntityId?: string;
  serviceProviderEntityId@TypeHint?: string;
  assertionConsumerServiceURL?: string;
  assertionConsumerServiceURL@TypeHint?: string;
  handleLogout?: boolean;
  handleLogout@TypeHint?: string;
  spPrivateKeyAlias?: string;
  spPrivateKeyAlias@TypeHint?: string;
  useEncryption?: boolean;
  useEncryption@TypeHint?: string;
  nameIdFormat?: string;
  nameIdFormat@TypeHint?: string;
  digestMethod?: string;
  digestMethod@TypeHint?: string;
  signatureMethod?: string;
  signatureMethod@TypeHint?: string;
  userIntermediatePath?: string;
  userIntermediatePath@TypeHint?: string;
}

/**
 * postConfigApacheFelixJettyBasedHttpService - parameters interface
 */
export interface IPostConfigApacheFelixJettyBasedHttpServiceParams {
  orgApacheFelixHttpsNio?: boolean;
  orgApacheFelixHttpsNio@TypeHint?: string;
  orgApacheFelixHttpsKeystore?: string;
  orgApacheFelixHttpsKeystore@TypeHint?: string;
  orgApacheFelixHttpsKeystorePassword?: string;
  orgApacheFelixHttpsKeystorePassword@TypeHint?: string;
  orgApacheFelixHttpsKeystoreKey?: string;
  orgApacheFelixHttpsKeystoreKey@TypeHint?: string;
  orgApacheFelixHttpsKeystoreKeyPassword?: string;
  orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string;
  orgApacheFelixHttpsTruststore?: string;
  orgApacheFelixHttpsTruststore@TypeHint?: string;
  orgApacheFelixHttpsTruststorePassword?: string;
  orgApacheFelixHttpsTruststorePassword@TypeHint?: string;
  orgApacheFelixHttpsClientcertificate?: string;
  orgApacheFelixHttpsClientcertificate@TypeHint?: string;
  orgApacheFelixHttpsEnable?: boolean;
  orgApacheFelixHttpsEnable@TypeHint?: string;
  orgOsgiServiceHttpPortSecure?: string;
  orgOsgiServiceHttpPortSecure@TypeHint?: string;
}

/**
 * postConfigApacheHttpComponentsProxyConfiguration - parameters interface
 */
export interface IPostConfigApacheHttpComponentsProxyConfigurationParams {
  proxyHost?: string;
  proxyHost@TypeHint?: string;
  proxyPort?: number;
  proxyPort@TypeHint?: string;
  proxyExceptions?: Array<string>;
  proxyExceptions@TypeHint?: string;
  proxyEnabled?: boolean;
  proxyEnabled@TypeHint?: string;
  proxyUser?: string;
  proxyUser@TypeHint?: string;
  proxyPassword?: string;
  proxyPassword@TypeHint?: string;
}

/**
 * postConfigApacheSlingDavExServlet - parameters interface
 */
export interface IPostConfigApacheSlingDavExServletParams {
  alias?: string;
  alias@TypeHint?: string;
  davCreateAbsoluteUri?: boolean;
  davCreateAbsoluteUri@TypeHint?: string;
}

/**
 * postConfigApacheSlingGetServlet - parameters interface
 */
export interface IPostConfigApacheSlingGetServletParams {
  jsonMaximumresults?: string;
  jsonMaximumresults@TypeHint?: string;
  enableHtml?: boolean;
  enableHtml@TypeHint?: string;
  enableTxt?: boolean;
  enableTxt@TypeHint?: string;
  enableXml?: boolean;
  enableXml@TypeHint?: string;
}

/**
 * postConfigApacheSlingReferrerFilter - parameters interface
 */
export interface IPostConfigApacheSlingReferrerFilterParams {
  allowEmpty?: boolean;
  allowEmpty@TypeHint?: string;
  allowHosts?: string;
  allowHosts@TypeHint?: string;
  allowHostsRegexp?: string;
  allowHostsRegexp@TypeHint?: string;
  filterMethods?: string;
  filterMethods@TypeHint?: string;
}

/**
 * postNode - parameters interface
 */
export interface IPostNodeParams {
  path: string;
  name: string;
  :operation?: string;
  deleteAuthorizable?: string;
  file?: any;
}

/**
 * postNodeRw - parameters interface
 */
export interface IPostNodeRwParams {
  path: string;
  name: string;
  addMembers?: string;
}

/**
 * postPath - parameters interface
 */
export interface IPostPathParams {
  path: string;
  jcr:primaryType: string;
  :name: string;
}

/**
 * postQuery - parameters interface
 */
export interface IPostQueryParams {
  path: string;
  pLimit: number;
  _1property: string;
  _1propertyValue: string;
}

/**
 * postTreeActivation - parameters interface
 */
export interface IPostTreeActivationParams {
  ignoredeactivated: boolean;
  onlymodified: boolean;
  path: string;
}

/**
 * postTruststore - parameters interface
 */
export interface IPostTruststoreParams {
  :operation?: string;
  newPassword?: string;
  rePassword?: string;
  keyStoreType?: string;
  removeAlias?: string;
  certificate?: any;
}

/**
 * postTruststorePKCS12 - parameters interface
 */
export interface IPostTruststorePKCS12Params {
  truststoreP12?: any;
}

/**
 * SlingApi - API class
 */
@autoinject()
export class SlingApi extends Api {

  /**
   * Creates a new SlingApi class.
   *
   * @param httpClient The Aurelia HTTP client to be injected.
   * @param authStorage A storage for authentication data.
   */
  constructor(httpClient: HttpClient, authStorage: AuthStorage) {
    super(httpClient, authStorage);
  }

  /**
   * @param params.runmode 
   * @param params.name 
   */
  async deleteAgent(params: IDeleteAgentParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('deleteAgent', params, 'runmode');
    this.ensureParamIsSet('deleteAgent', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/etc/replication/agents.{runmode}/{name}`
      .replace(`{${'runmode'}}`, encodeURIComponent(`${params['runmode']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asDelete()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.path 
   * @param params.name 
   */
  async deleteNode(params: IDeleteNodeParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('deleteNode', params, 'path');
    this.ensureParamIsSet('deleteNode', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/{path}/{name}`
      .replace(`{${'path'}}`, encodeURIComponent(`${params['path']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asDelete()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.runmode 
   * @param params.name 
   */
  async getAgent(params: IGetAgentParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('getAgent', params, 'runmode');
    this.ensureParamIsSet('getAgent', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/etc/replication/agents.{runmode}/{name}`
      .replace(`{${'runmode'}}`, encodeURIComponent(`${params['runmode']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.runmode 
   */
  async getAgents(params: IGetAgentsParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('getAgents', params, 'runmode');

    // Create URL to call
    const url = `${this.basePath}/etc/replication/agents.{runmode}.-1.json`
      .replace(`{${'runmode'}}`, encodeURIComponent(`${params['runmode']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.intermediatePath 
   * @param params.authorizableId 
   */
  async getAuthorizableKeystore(params: IGetAuthorizableKeystoreParams): Promise<KeystoreInfo> {
    // Verify required parameters are set
    this.ensureParamIsSet('getAuthorizableKeystore', params, 'intermediatePath');
    this.ensureParamIsSet('getAuthorizableKeystore', params, 'authorizableId');

    // Create URL to call
    const url = `${this.basePath}/{intermediatePath}/{authorizableId}.ks.json`
      .replace(`{${'intermediatePath'}}`, encodeURIComponent(`${params['intermediatePath']}`))
      .replace(`{${'authorizableId'}}`, encodeURIComponent(`${params['authorizableId']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.intermediatePath 
   * @param params.authorizableId 
   */
  async getKeystore(params: IGetKeystoreParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('getKeystore', params, 'intermediatePath');
    this.ensureParamIsSet('getKeystore', params, 'authorizableId');

    // Create URL to call
    const url = `${this.basePath}/{intermediatePath}/{authorizableId}/keystore/store.p12`
      .replace(`{${'intermediatePath'}}`, encodeURIComponent(`${params['intermediatePath']}`))
      .replace(`{${'authorizableId'}}`, encodeURIComponent(`${params['authorizableId']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.path 
   * @param params.name 
   */
  async getNode(params: IGetNodeParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('getNode', params, 'path');
    this.ensureParamIsSet('getNode', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/{path}/{name}`
      .replace(`{${'path'}}`, encodeURIComponent(`${params['path']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.group 
   * @param params.name 
   * @param params.version 
   */
  async getPackage(params: IGetPackageParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('getPackage', params, 'group');
    this.ensureParamIsSet('getPackage', params, 'name');
    this.ensureParamIsSet('getPackage', params, 'version');

    // Create URL to call
    const url = `${this.basePath}/etc/packages/{group}/{name}-{version}.zip`
      .replace(`{${'group'}}`, encodeURIComponent(`${params['group']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`))
      .replace(`{${'version'}}`, encodeURIComponent(`${params['version']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.group 
   * @param params.name 
   * @param params.version 
   */
  async getPackageFilter(params: IGetPackageFilterParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('getPackageFilter', params, 'group');
    this.ensureParamIsSet('getPackageFilter', params, 'name');
    this.ensureParamIsSet('getPackageFilter', params, 'version');

    // Create URL to call
    const url = `${this.basePath}/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json`
      .replace(`{${'group'}}`, encodeURIComponent(`${params['group']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`))
      .replace(`{${'version'}}`, encodeURIComponent(`${params['version']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.path 
   * @param params.pLimit 
   * @param params._1property 
   * @param params._1propertyValue 
   */
  async getQuery(params: IGetQueryParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('getQuery', params, 'path');
    this.ensureParamIsSet('getQuery', params, 'pLimit');
    this.ensureParamIsSet('getQuery', params, '_1property');
    this.ensureParamIsSet('getQuery', params, '_1propertyValue');

    // Create URL to call
    const url = `${this.basePath}/bin/querybuilder.json`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'path': params['path'],
        'p.limit': params['pLimit'],
        '1_property': params['_1property'],
        '1_property.value': params['_1propertyValue'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   */
  async getTruststore(): Promise<any> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/etc/truststore/truststore.p12`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   */
  async getTruststoreInfo(): Promise<TruststoreInfo> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/libs/granite/security/truststore.json`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.runmode 
   * @param params.name 
   * @param params.jcr:contentCq:distribute 
   * @param params.jcr:contentCq:distribute@TypeHint 
   * @param params.jcr:contentCq:name 
   * @param params.jcr:contentCq:template 
   * @param params.jcr:contentEnabled 
   * @param params.jcr:contentJcr:description 
   * @param params.jcr:contentJcr:lastModified 
   * @param params.jcr:contentJcr:lastModifiedBy 
   * @param params.jcr:contentJcr:mixinTypes 
   * @param params.jcr:contentJcr:title 
   * @param params.jcr:contentLogLevel 
   * @param params.jcr:contentNoStatusUpdate 
   * @param params.jcr:contentNoVersioning 
   * @param params.jcr:contentProtocolConnectTimeout 
   * @param params.jcr:contentProtocolHTTPConnectionClosed 
   * @param params.jcr:contentProtocolHTTPExpired 
   * @param params.jcr:contentProtocolHTTPHeaders 
   * @param params.jcr:contentProtocolHTTPHeaders@TypeHint 
   * @param params.jcr:contentProtocolHTTPMethod 
   * @param params.jcr:contentProtocolHTTPSRelaxed 
   * @param params.jcr:contentProtocolInterface 
   * @param params.jcr:contentProtocolSocketTimeout 
   * @param params.jcr:contentProtocolVersion 
   * @param params.jcr:contentProxyNTLMDomain 
   * @param params.jcr:contentProxyNTLMHost 
   * @param params.jcr:contentProxyHost 
   * @param params.jcr:contentProxyPassword 
   * @param params.jcr:contentProxyPort 
   * @param params.jcr:contentProxyUser 
   * @param params.jcr:contentQueueBatchMaxSize 
   * @param params.jcr:contentQueueBatchMode 
   * @param params.jcr:contentQueueBatchWaitTime 
   * @param params.jcr:contentRetryDelay 
   * @param params.jcr:contentReverseReplication 
   * @param params.jcr:contentSerializationType 
   * @param params.jcr:contentSling:resourceType 
   * @param params.jcr:contentSsl 
   * @param params.jcr:contentTransportNTLMDomain 
   * @param params.jcr:contentTransportNTLMHost 
   * @param params.jcr:contentTransportPassword 
   * @param params.jcr:contentTransportUri 
   * @param params.jcr:contentTransportUser 
   * @param params.jcr:contentTriggerDistribute 
   * @param params.jcr:contentTriggerModified 
   * @param params.jcr:contentTriggerOnOffTime 
   * @param params.jcr:contentTriggerReceive 
   * @param params.jcr:contentTriggerSpecific 
   * @param params.jcr:contentUserId 
   * @param params.jcr:primaryType 
   * @param params.:operation 
   */
  async postAgent(params: IPostAgentParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('postAgent', params, 'runmode');
    this.ensureParamIsSet('postAgent', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/etc/replication/agents.{runmode}/{name}`
      .replace(`{${'runmode'}}`, encodeURIComponent(`${params['runmode']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'jcr:content/cq:distribute': params['jcr:contentCq:distribute'],
        'jcr:content/cq:distribute@TypeHint': params['jcr:contentCq:distribute@TypeHint'],
        'jcr:content/cq:name': params['jcr:contentCq:name'],
        'jcr:content/cq:template': params['jcr:contentCq:template'],
        'jcr:content/enabled': params['jcr:contentEnabled'],
        'jcr:content/jcr:description': params['jcr:contentJcr:description'],
        'jcr:content/jcr:lastModified': params['jcr:contentJcr:lastModified'],
        'jcr:content/jcr:lastModifiedBy': params['jcr:contentJcr:lastModifiedBy'],
        'jcr:content/jcr:mixinTypes': params['jcr:contentJcr:mixinTypes'],
        'jcr:content/jcr:title': params['jcr:contentJcr:title'],
        'jcr:content/logLevel': params['jcr:contentLogLevel'],
        'jcr:content/noStatusUpdate': params['jcr:contentNoStatusUpdate'],
        'jcr:content/noVersioning': params['jcr:contentNoVersioning'],
        'jcr:content/protocolConnectTimeout': params['jcr:contentProtocolConnectTimeout'],
        'jcr:content/protocolHTTPConnectionClosed': params['jcr:contentProtocolHTTPConnectionClosed'],
        'jcr:content/protocolHTTPExpired': params['jcr:contentProtocolHTTPExpired'],
        'jcr:content/protocolHTTPHeaders': params['jcr:contentProtocolHTTPHeaders'],
        'jcr:content/protocolHTTPHeaders@TypeHint': params['jcr:contentProtocolHTTPHeaders@TypeHint'],
        'jcr:content/protocolHTTPMethod': params['jcr:contentProtocolHTTPMethod'],
        'jcr:content/protocolHTTPSRelaxed': params['jcr:contentProtocolHTTPSRelaxed'],
        'jcr:content/protocolInterface': params['jcr:contentProtocolInterface'],
        'jcr:content/protocolSocketTimeout': params['jcr:contentProtocolSocketTimeout'],
        'jcr:content/protocolVersion': params['jcr:contentProtocolVersion'],
        'jcr:content/proxyNTLMDomain': params['jcr:contentProxyNTLMDomain'],
        'jcr:content/proxyNTLMHost': params['jcr:contentProxyNTLMHost'],
        'jcr:content/proxyHost': params['jcr:contentProxyHost'],
        'jcr:content/proxyPassword': params['jcr:contentProxyPassword'],
        'jcr:content/proxyPort': params['jcr:contentProxyPort'],
        'jcr:content/proxyUser': params['jcr:contentProxyUser'],
        'jcr:content/queueBatchMaxSize': params['jcr:contentQueueBatchMaxSize'],
        'jcr:content/queueBatchMode': params['jcr:contentQueueBatchMode'],
        'jcr:content/queueBatchWaitTime': params['jcr:contentQueueBatchWaitTime'],
        'jcr:content/retryDelay': params['jcr:contentRetryDelay'],
        'jcr:content/reverseReplication': params['jcr:contentReverseReplication'],
        'jcr:content/serializationType': params['jcr:contentSerializationType'],
        'jcr:content/sling:resourceType': params['jcr:contentSling:resourceType'],
        'jcr:content/ssl': params['jcr:contentSsl'],
        'jcr:content/transportNTLMDomain': params['jcr:contentTransportNTLMDomain'],
        'jcr:content/transportNTLMHost': params['jcr:contentTransportNTLMHost'],
        'jcr:content/transportPassword': params['jcr:contentTransportPassword'],
        'jcr:content/transportUri': params['jcr:contentTransportUri'],
        'jcr:content/transportUser': params['jcr:contentTransportUser'],
        'jcr:content/triggerDistribute': params['jcr:contentTriggerDistribute'],
        'jcr:content/triggerModified': params['jcr:contentTriggerModified'],
        'jcr:content/triggerOnOffTime': params['jcr:contentTriggerOnOffTime'],
        'jcr:content/triggerReceive': params['jcr:contentTriggerReceive'],
        'jcr:content/triggerSpecific': params['jcr:contentTriggerSpecific'],
        'jcr:content/userId': params['jcr:contentUserId'],
        'jcr:primaryType': params['jcr:primaryType'],
        ':operation': params[':operation'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.intermediatePath 
   * @param params.authorizableId 
   * @param params.:operation 
   * @param params.currentPassword 
   * @param params.newPassword 
   * @param params.rePassword 
   * @param params.keyPassword 
   * @param params.keyStorePass 
   * @param params.alias 
   * @param params.newAlias 
   * @param params.removeAlias 
   * @param params.certChain 
   * @param params.pk 
   * @param params.keyStore 
   */
  async postAuthorizableKeystore(params: IPostAuthorizableKeystoreParams): Promise<KeystoreInfo> {
    // Verify required parameters are set
    this.ensureParamIsSet('postAuthorizableKeystore', params, 'intermediatePath');
    this.ensureParamIsSet('postAuthorizableKeystore', params, 'authorizableId');

    // Create URL to call
    const url = `${this.basePath}/{intermediatePath}/{authorizableId}.ks.html`
      .replace(`{${'intermediatePath'}}`, encodeURIComponent(`${params['intermediatePath']}`))
      .replace(`{${'authorizableId'}}`, encodeURIComponent(`${params['authorizableId']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        ':operation': params[':operation'],
        'currentPassword': params['currentPassword'],
        'newPassword': params['newPassword'],
        'rePassword': params['rePassword'],
        'keyPassword': params['keyPassword'],
        'keyStorePass': params['keyStorePass'],
        'alias': params['alias'],
        'newAlias': params['newAlias'],
        'removeAlias': params['removeAlias'],
      })
      // Encode form parameters
      .withHeader('content-type', 'application/x-www-form-urlencoded')
      .withContent(this.queryString({ 
        'cert-chain': params['certChain'],
        'pk': params['pk'],
        'keyStore': params['keyStore'],
      }))

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.authorizableId 
   * @param params.intermediatePath 
   * @param params.createUser 
   * @param params.createGroup 
   * @param params.rep:password 
   * @param params.profileGivenName 
   */
  async postAuthorizables(params: IPostAuthorizablesParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('postAuthorizables', params, 'authorizableId');
    this.ensureParamIsSet('postAuthorizables', params, 'intermediatePath');

    // Create URL to call
    const url = `${this.basePath}/libs/granite/security/post/authorizables`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'authorizableId': params['authorizableId'],
        'intermediatePath': params['intermediatePath'],
        'createUser': params['createUser'],
        'createGroup': params['createGroup'],
        'rep:password': params['rep:password'],
        'profile/givenName': params['profileGivenName'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.keyStorePassword 
   * @param params.keyStorePassword@TypeHint 
   * @param params.serviceRanking 
   * @param params.serviceRanking@TypeHint 
   * @param params.idpHttpRedirect 
   * @param params.idpHttpRedirect@TypeHint 
   * @param params.createUser 
   * @param params.createUser@TypeHint 
   * @param params.defaultRedirectUrl 
   * @param params.defaultRedirectUrl@TypeHint 
   * @param params.userIDAttribute 
   * @param params.userIDAttribute@TypeHint 
   * @param params.defaultGroups 
   * @param params.defaultGroups@TypeHint 
   * @param params.idpCertAlias 
   * @param params.idpCertAlias@TypeHint 
   * @param params.addGroupMemberships 
   * @param params.addGroupMemberships@TypeHint 
   * @param params.path 
   * @param params.path@TypeHint 
   * @param params.synchronizeAttributes 
   * @param params.synchronizeAttributes@TypeHint 
   * @param params.clockTolerance 
   * @param params.clockTolerance@TypeHint 
   * @param params.groupMembershipAttribute 
   * @param params.groupMembershipAttribute@TypeHint 
   * @param params.idpUrl 
   * @param params.idpUrl@TypeHint 
   * @param params.logoutUrl 
   * @param params.logoutUrl@TypeHint 
   * @param params.serviceProviderEntityId 
   * @param params.serviceProviderEntityId@TypeHint 
   * @param params.assertionConsumerServiceURL 
   * @param params.assertionConsumerServiceURL@TypeHint 
   * @param params.handleLogout 
   * @param params.handleLogout@TypeHint 
   * @param params.spPrivateKeyAlias 
   * @param params.spPrivateKeyAlias@TypeHint 
   * @param params.useEncryption 
   * @param params.useEncryption@TypeHint 
   * @param params.nameIdFormat 
   * @param params.nameIdFormat@TypeHint 
   * @param params.digestMethod 
   * @param params.digestMethod@TypeHint 
   * @param params.signatureMethod 
   * @param params.signatureMethod@TypeHint 
   * @param params.userIntermediatePath 
   * @param params.userIntermediatePath@TypeHint 
   */
  async postConfigAdobeGraniteSamlAuthenticationHandler(params: IPostConfigAdobeGraniteSamlAuthenticationHandlerParams): Promise<any> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'keyStorePassword': params['keyStorePassword'],
        'keyStorePassword@TypeHint': params['keyStorePassword@TypeHint'],
        'service.ranking': params['serviceRanking'],
        'service.ranking@TypeHint': params['serviceRanking@TypeHint'],
        'idpHttpRedirect': params['idpHttpRedirect'],
        'idpHttpRedirect@TypeHint': params['idpHttpRedirect@TypeHint'],
        'createUser': params['createUser'],
        'createUser@TypeHint': params['createUser@TypeHint'],
        'defaultRedirectUrl': params['defaultRedirectUrl'],
        'defaultRedirectUrl@TypeHint': params['defaultRedirectUrl@TypeHint'],
        'userIDAttribute': params['userIDAttribute'],
        'userIDAttribute@TypeHint': params['userIDAttribute@TypeHint'],
        'defaultGroups': params['defaultGroups'],
        'defaultGroups@TypeHint': params['defaultGroups@TypeHint'],
        'idpCertAlias': params['idpCertAlias'],
        'idpCertAlias@TypeHint': params['idpCertAlias@TypeHint'],
        'addGroupMemberships': params['addGroupMemberships'],
        'addGroupMemberships@TypeHint': params['addGroupMemberships@TypeHint'],
        'path': params['path'],
        'path@TypeHint': params['path@TypeHint'],
        'synchronizeAttributes': params['synchronizeAttributes'],
        'synchronizeAttributes@TypeHint': params['synchronizeAttributes@TypeHint'],
        'clockTolerance': params['clockTolerance'],
        'clockTolerance@TypeHint': params['clockTolerance@TypeHint'],
        'groupMembershipAttribute': params['groupMembershipAttribute'],
        'groupMembershipAttribute@TypeHint': params['groupMembershipAttribute@TypeHint'],
        'idpUrl': params['idpUrl'],
        'idpUrl@TypeHint': params['idpUrl@TypeHint'],
        'logoutUrl': params['logoutUrl'],
        'logoutUrl@TypeHint': params['logoutUrl@TypeHint'],
        'serviceProviderEntityId': params['serviceProviderEntityId'],
        'serviceProviderEntityId@TypeHint': params['serviceProviderEntityId@TypeHint'],
        'assertionConsumerServiceURL': params['assertionConsumerServiceURL'],
        'assertionConsumerServiceURL@TypeHint': params['assertionConsumerServiceURL@TypeHint'],
        'handleLogout': params['handleLogout'],
        'handleLogout@TypeHint': params['handleLogout@TypeHint'],
        'spPrivateKeyAlias': params['spPrivateKeyAlias'],
        'spPrivateKeyAlias@TypeHint': params['spPrivateKeyAlias@TypeHint'],
        'useEncryption': params['useEncryption'],
        'useEncryption@TypeHint': params['useEncryption@TypeHint'],
        'nameIdFormat': params['nameIdFormat'],
        'nameIdFormat@TypeHint': params['nameIdFormat@TypeHint'],
        'digestMethod': params['digestMethod'],
        'digestMethod@TypeHint': params['digestMethod@TypeHint'],
        'signatureMethod': params['signatureMethod'],
        'signatureMethod@TypeHint': params['signatureMethod@TypeHint'],
        'userIntermediatePath': params['userIntermediatePath'],
        'userIntermediatePath@TypeHint': params['userIntermediatePath@TypeHint'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.orgApacheFelixHttpsNio 
   * @param params.orgApacheFelixHttpsNio@TypeHint 
   * @param params.orgApacheFelixHttpsKeystore 
   * @param params.orgApacheFelixHttpsKeystore@TypeHint 
   * @param params.orgApacheFelixHttpsKeystorePassword 
   * @param params.orgApacheFelixHttpsKeystorePassword@TypeHint 
   * @param params.orgApacheFelixHttpsKeystoreKey 
   * @param params.orgApacheFelixHttpsKeystoreKey@TypeHint 
   * @param params.orgApacheFelixHttpsKeystoreKeyPassword 
   * @param params.orgApacheFelixHttpsKeystoreKeyPassword@TypeHint 
   * @param params.orgApacheFelixHttpsTruststore 
   * @param params.orgApacheFelixHttpsTruststore@TypeHint 
   * @param params.orgApacheFelixHttpsTruststorePassword 
   * @param params.orgApacheFelixHttpsTruststorePassword@TypeHint 
   * @param params.orgApacheFelixHttpsClientcertificate 
   * @param params.orgApacheFelixHttpsClientcertificate@TypeHint 
   * @param params.orgApacheFelixHttpsEnable 
   * @param params.orgApacheFelixHttpsEnable@TypeHint 
   * @param params.orgOsgiServiceHttpPortSecure 
   * @param params.orgOsgiServiceHttpPortSecure@TypeHint 
   */
  async postConfigApacheFelixJettyBasedHttpService(params: IPostConfigApacheFelixJettyBasedHttpServiceParams): Promise<any> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/apps/system/config/org.apache.felix.http`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'org.apache.felix.https.nio': params['orgApacheFelixHttpsNio'],
        'org.apache.felix.https.nio@TypeHint': params['orgApacheFelixHttpsNio@TypeHint'],
        'org.apache.felix.https.keystore': params['orgApacheFelixHttpsKeystore'],
        'org.apache.felix.https.keystore@TypeHint': params['orgApacheFelixHttpsKeystore@TypeHint'],
        'org.apache.felix.https.keystore.password': params['orgApacheFelixHttpsKeystorePassword'],
        'org.apache.felix.https.keystore.password@TypeHint': params['orgApacheFelixHttpsKeystorePassword@TypeHint'],
        'org.apache.felix.https.keystore.key': params['orgApacheFelixHttpsKeystoreKey'],
        'org.apache.felix.https.keystore.key@TypeHint': params['orgApacheFelixHttpsKeystoreKey@TypeHint'],
        'org.apache.felix.https.keystore.key.password': params['orgApacheFelixHttpsKeystoreKeyPassword'],
        'org.apache.felix.https.keystore.key.password@TypeHint': params['orgApacheFelixHttpsKeystoreKeyPassword@TypeHint'],
        'org.apache.felix.https.truststore': params['orgApacheFelixHttpsTruststore'],
        'org.apache.felix.https.truststore@TypeHint': params['orgApacheFelixHttpsTruststore@TypeHint'],
        'org.apache.felix.https.truststore.password': params['orgApacheFelixHttpsTruststorePassword'],
        'org.apache.felix.https.truststore.password@TypeHint': params['orgApacheFelixHttpsTruststorePassword@TypeHint'],
        'org.apache.felix.https.clientcertificate': params['orgApacheFelixHttpsClientcertificate'],
        'org.apache.felix.https.clientcertificate@TypeHint': params['orgApacheFelixHttpsClientcertificate@TypeHint'],
        'org.apache.felix.https.enable': params['orgApacheFelixHttpsEnable'],
        'org.apache.felix.https.enable@TypeHint': params['orgApacheFelixHttpsEnable@TypeHint'],
        'org.osgi.service.http.port.secure': params['orgOsgiServiceHttpPortSecure'],
        'org.osgi.service.http.port.secure@TypeHint': params['orgOsgiServiceHttpPortSecure@TypeHint'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.proxyHost 
   * @param params.proxyHost@TypeHint 
   * @param params.proxyPort 
   * @param params.proxyPort@TypeHint 
   * @param params.proxyExceptions 
   * @param params.proxyExceptions@TypeHint 
   * @param params.proxyEnabled 
   * @param params.proxyEnabled@TypeHint 
   * @param params.proxyUser 
   * @param params.proxyUser@TypeHint 
   * @param params.proxyPassword 
   * @param params.proxyPassword@TypeHint 
   */
  async postConfigApacheHttpComponentsProxyConfiguration(params: IPostConfigApacheHttpComponentsProxyConfigurationParams): Promise<any> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/apps/system/config/org.apache.http.proxyconfigurator.config`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'proxy.host': params['proxyHost'],
        'proxy.host@TypeHint': params['proxyHost@TypeHint'],
        'proxy.port': params['proxyPort'],
        'proxy.port@TypeHint': params['proxyPort@TypeHint'],
        'proxy.exceptions': params['proxyExceptions'],
        'proxy.exceptions@TypeHint': params['proxyExceptions@TypeHint'],
        'proxy.enabled': params['proxyEnabled'],
        'proxy.enabled@TypeHint': params['proxyEnabled@TypeHint'],
        'proxy.user': params['proxyUser'],
        'proxy.user@TypeHint': params['proxyUser@TypeHint'],
        'proxy.password': params['proxyPassword'],
        'proxy.password@TypeHint': params['proxyPassword@TypeHint'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.alias 
   * @param params.alias@TypeHint 
   * @param params.davCreateAbsoluteUri 
   * @param params.davCreateAbsoluteUri@TypeHint 
   */
  async postConfigApacheSlingDavExServlet(params: IPostConfigApacheSlingDavExServletParams): Promise<any> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'alias': params['alias'],
        'alias@TypeHint': params['alias@TypeHint'],
        'dav.create-absolute-uri': params['davCreateAbsoluteUri'],
        'dav.create-absolute-uri@TypeHint': params['davCreateAbsoluteUri@TypeHint'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.jsonMaximumresults 
   * @param params.jsonMaximumresults@TypeHint 
   * @param params.enableHtml 
   * @param params.enableHtml@TypeHint 
   * @param params.enableTxt 
   * @param params.enableTxt@TypeHint 
   * @param params.enableXml 
   * @param params.enableXml@TypeHint 
   */
  async postConfigApacheSlingGetServlet(params: IPostConfigApacheSlingGetServletParams): Promise<any> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'json.maximumresults': params['jsonMaximumresults'],
        'json.maximumresults@TypeHint': params['jsonMaximumresults@TypeHint'],
        'enable.html': params['enableHtml'],
        'enable.html@TypeHint': params['enableHtml@TypeHint'],
        'enable.txt': params['enableTxt'],
        'enable.txt@TypeHint': params['enableTxt@TypeHint'],
        'enable.xml': params['enableXml'],
        'enable.xml@TypeHint': params['enableXml@TypeHint'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.allowEmpty 
   * @param params.allowEmpty@TypeHint 
   * @param params.allowHosts 
   * @param params.allowHosts@TypeHint 
   * @param params.allowHostsRegexp 
   * @param params.allowHostsRegexp@TypeHint 
   * @param params.filterMethods 
   * @param params.filterMethods@TypeHint 
   */
  async postConfigApacheSlingReferrerFilter(params: IPostConfigApacheSlingReferrerFilterParams): Promise<any> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/apps/system/config/org.apache.sling.security.impl.ReferrerFilter`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'allow.empty': params['allowEmpty'],
        'allow.empty@TypeHint': params['allowEmpty@TypeHint'],
        'allow.hosts': params['allowHosts'],
        'allow.hosts@TypeHint': params['allowHosts@TypeHint'],
        'allow.hosts.regexp': params['allowHostsRegexp'],
        'allow.hosts.regexp@TypeHint': params['allowHostsRegexp@TypeHint'],
        'filter.methods': params['filterMethods'],
        'filter.methods@TypeHint': params['filterMethods@TypeHint'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.path 
   * @param params.name 
   * @param params.:operation 
   * @param params.deleteAuthorizable 
   * @param params.file 
   */
  async postNode(params: IPostNodeParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('postNode', params, 'path');
    this.ensureParamIsSet('postNode', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/{path}/{name}`
      .replace(`{${'path'}}`, encodeURIComponent(`${params['path']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        ':operation': params[':operation'],
        'deleteAuthorizable': params['deleteAuthorizable'],
      })
      // Encode form parameters
      .withHeader('content-type', 'application/x-www-form-urlencoded')
      .withContent(this.queryString({ 
        'file': params['file'],
      }))

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.path 
   * @param params.name 
   * @param params.addMembers 
   */
  async postNodeRw(params: IPostNodeRwParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('postNodeRw', params, 'path');
    this.ensureParamIsSet('postNodeRw', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/{path}/{name}.rw.html`
      .replace(`{${'path'}}`, encodeURIComponent(`${params['path']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'addMembers': params['addMembers'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.path 
   * @param params.jcr:primaryType 
   * @param params.:name 
   */
  async postPath(params: IPostPathParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('postPath', params, 'path');
    this.ensureParamIsSet('postPath', params, 'jcr:primaryType');
    this.ensureParamIsSet('postPath', params, ':name');

    // Create URL to call
    const url = `${this.basePath}/{path}/`
      .replace(`{${'path'}}`, encodeURIComponent(`${params['path']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'jcr:primaryType': params['jcr:primaryType'],
        ':name': params[':name'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.path 
   * @param params.pLimit 
   * @param params._1property 
   * @param params._1propertyValue 
   */
  async postQuery(params: IPostQueryParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('postQuery', params, 'path');
    this.ensureParamIsSet('postQuery', params, 'pLimit');
    this.ensureParamIsSet('postQuery', params, '_1property');
    this.ensureParamIsSet('postQuery', params, '_1propertyValue');

    // Create URL to call
    const url = `${this.basePath}/bin/querybuilder.json`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'path': params['path'],
        'p.limit': params['pLimit'],
        '1_property': params['_1property'],
        '1_property.value': params['_1propertyValue'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.ignoredeactivated 
   * @param params.onlymodified 
   * @param params.path 
   */
  async postTreeActivation(params: IPostTreeActivationParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('postTreeActivation', params, 'ignoredeactivated');
    this.ensureParamIsSet('postTreeActivation', params, 'onlymodified');
    this.ensureParamIsSet('postTreeActivation', params, 'path');

    // Create URL to call
    const url = `${this.basePath}/etc/replication/treeactivation.html`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'ignoredeactivated': params['ignoredeactivated'],
        'onlymodified': params['onlymodified'],
        'path': params['path'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.:operation 
   * @param params.newPassword 
   * @param params.rePassword 
   * @param params.keyStoreType 
   * @param params.removeAlias 
   * @param params.certificate 
   */
  async postTruststore(params: IPostTruststoreParams): Promise<string> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/libs/granite/security/post/truststore`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        ':operation': params[':operation'],
        'newPassword': params['newPassword'],
        'rePassword': params['rePassword'],
        'keyStoreType': params['keyStoreType'],
        'removeAlias': params['removeAlias'],
      })
      // Encode form parameters
      .withHeader('content-type', 'application/x-www-form-urlencoded')
      .withContent(this.queryString({ 
        'certificate': params['certificate'],
      }))

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.truststoreP12 
   */
  async postTruststorePKCS12(params: IPostTruststorePKCS12Params): Promise<string> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/etc/truststore`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Encode form parameters
      .withHeader('content-type', 'application/x-www-form-urlencoded')
      .withContent(this.queryString({ 
        'truststore.p12': params['truststoreP12'],
      }))

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

}

