// @flow
/* eslint-disable no-use-before-define */
/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * OpenAPI spec version: 3.2.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}


/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type InstallStatus = {
    /**
     * 
     * @type {InstallStatusStatus}
     * @memberof InstallStatus
     */
    status?: InstallStatusStatus;
}


/**
 * 
 * @export
 */
export type InstallStatusStatus = {
    /**
     * 
     * @type {boolean}
     * @memberof InstallStatusStatus
     */
    finished?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InstallStatusStatus
     */
    itemCount?: number;
}


/**
 * 
 * @export
 */
export type KeystoreChainItems = {
    /**
     * e.g. \"CN=localhost\"
     * @type {string}
     * @memberof KeystoreChainItems
     */
    subject?: string;
    /**
     * e.g. \"CN=Admin\"
     * @type {string}
     * @memberof KeystoreChainItems
     */
    issuer?: string;
    /**
     * e.g. \"Sun Jul 01 12:00:00 AEST 2018\"
     * @type {string}
     * @memberof KeystoreChainItems
     */
    notBefore?: string;
    /**
     * e.g. \"Sun Jun 30 23:59:50 AEST 2019\"
     * @type {string}
     * @memberof KeystoreChainItems
     */
    notAfter?: string;
    /**
     * 18165099476682912368
     * @type {number}
     * @memberof KeystoreChainItems
     */
    serialNumber?: number;
}


/**
 * 
 * @export
 */
export type KeystoreInfo = {
    /**
     * 
     * @type {Array<KeystoreItems>}
     * @memberof KeystoreInfo
     */
    aliases?: Array<KeystoreItems>;
    /**
     * False if truststore don't exist
     * @type {boolean}
     * @memberof KeystoreInfo
     */
    exists?: boolean;
}


/**
 * 
 * @export
 */
export type KeystoreItems = {
    /**
     * Keystore alias name
     * @type {string}
     * @memberof KeystoreItems
     */
    alias?: string;
    /**
     * e.g. \"privateKey\"
     * @type {string}
     * @memberof KeystoreItems
     */
    entryType?: string;
    /**
     * e.g. \"RSA\"
     * @type {string}
     * @memberof KeystoreItems
     */
    algorithm?: string;
    /**
     * e.g. \"PKCS#8\"
     * @type {string}
     * @memberof KeystoreItems
     */
    format?: string;
    /**
     * 
     * @type {Array<KeystoreChainItems>}
     * @memberof KeystoreItems
     */
    chain?: Array<KeystoreChainItems>;
}


/**
 * 
 * @export
 */
export type SamlConfigurationInfo = {
    /**
     * Persistent Identity (PID)
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    pid?: string;
    /**
     * Title
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    title?: string;
    /**
     * Title
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    description?: string;
    /**
     * needed for configuration binding
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    bundleLocation?: string;
    /**
     * needed for configuraiton binding
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    serviceLocation?: string;
    /**
     * 
     * @type {SamlConfigurationProperties}
     * @memberof SamlConfigurationInfo
     */
    properties?: SamlConfigurationProperties;
}


/**
 * 
 * @export
 */
export type SamlConfigurationProperties = {
    /**
     * 
     * @type {SamlConfigurationPropertyItemsArray}
     * @memberof SamlConfigurationProperties
     */
    path?: SamlConfigurationPropertyItemsArray;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsLong}
     * @memberof SamlConfigurationProperties
     */
    serviceRanking?: SamlConfigurationPropertyItemsLong;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    idpUrl?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    idpCertAlias?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    idpHttpRedirect?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    serviceProviderEntityId?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    assertionConsumerServiceURL?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    spPrivateKeyAlias?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    keyStorePassword?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    defaultRedirectUrl?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    userIDAttribute?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    useEncryption?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    createUser?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    addGroupMemberships?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    groupMembershipAttribute?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsArray}
     * @memberof SamlConfigurationProperties
     */
    defaultGroups?: SamlConfigurationPropertyItemsArray;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    nameIdFormat?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsArray}
     * @memberof SamlConfigurationProperties
     */
    synchronizeAttributes?: SamlConfigurationPropertyItemsArray;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    handleLogout?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    logoutUrl?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsLong}
     * @memberof SamlConfigurationProperties
     */
    clockTolerance?: SamlConfigurationPropertyItemsLong;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    digestMethod?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    signatureMethod?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    userIntermediatePath?: SamlConfigurationPropertyItemsString;
}


/**
 * 
 * @export
 */
export type SamlConfigurationPropertyItemsArray = {
    /**
     * property name
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    name?: string;
    /**
     * True if optional
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    optional?: boolean;
    /**
     * True if property is set
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    isSet?: boolean;
    /**
     * Property type, 1=String, 3=long, 11=boolean, 12=Password
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    type?: number;
    /**
     * Property value
     * @type {Array<string>}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    values?: Array<string>;
    /**
     * Property description
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    description?: string;
}


/**
 * 
 * @export
 */
export type SamlConfigurationPropertyItemsBoolean = {
    /**
     * property name
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    name?: string;
    /**
     * True if optional
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    optional?: boolean;
    /**
     * True if property is set
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    isSet?: boolean;
    /**
     * Property type, 1=String, 3=long, 11=boolean, 12=Password
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    type?: number;
    /**
     * Property value
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    value?: boolean;
    /**
     * Property description
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    description?: string;
}


/**
 * 
 * @export
 */
export type SamlConfigurationPropertyItemsLong = {
    /**
     * property name
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    name?: string;
    /**
     * True if optional
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    optional?: boolean;
    /**
     * True if property is set
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    isSet?: boolean;
    /**
     * Property type, 1=String, 3=long, 11=boolean, 12=Password
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    type?: number;
    /**
     * Property value
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    value?: number;
    /**
     * Property description
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    description?: string;
}


/**
 * 
 * @export
 */
export type SamlConfigurationPropertyItemsString = {
    /**
     * property name
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsString
     */
    name?: string;
    /**
     * True if optional
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsString
     */
    optional?: boolean;
    /**
     * True if property is set
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsString
     */
    isSet?: boolean;
    /**
     * Property type, 1=String, 3=long, 11=boolean, 12=Password
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsString
     */
    type?: number;
    /**
     * Property value
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsString
     */
    value?: string;
    /**
     * Property description
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsString
     */
    description?: string;
}


/**
 * 
 * @export
 */
export type TruststoreInfo = {
    /**
     * 
     * @type {Array<TruststoreItems>}
     * @memberof TruststoreInfo
     */
    aliases?: Array<TruststoreItems>;
    /**
     * False if truststore don't exist
     * @type {boolean}
     * @memberof TruststoreInfo
     */
    exists?: boolean;
}


/**
 * 
 * @export
 */
export type TruststoreItems = {
    /**
     * Truststore alias name
     * @type {string}
     * @memberof TruststoreItems
     */
    alias?: string;
    /**
     * 
     * @type {string}
     * @memberof TruststoreItems
     */
    entryType?: string;
    /**
     * e.g. \"CN=localhost\"
     * @type {string}
     * @memberof TruststoreItems
     */
    subject?: string;
    /**
     * e.g. \"CN=Admin\"
     * @type {string}
     * @memberof TruststoreItems
     */
    issuer?: string;
    /**
     * e.g. \"Sun Jul 01 12:00:00 AEST 2018\"
     * @type {string}
     * @memberof TruststoreItems
     */
    notBefore?: string;
    /**
     * e.g. \"Sun Jun 30 23:59:50 AEST 2019\"
     * @type {string}
     * @memberof TruststoreItems
     */
    notAfter?: string;
    /**
     * 18165099476682912368
     * @type {number}
     * @memberof TruststoreItems
     */
    serialNumber?: number;
}




/**
 * ConsoleApi - fetch parameter creator
 * @export
 */
export const ConsoleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getAemProductInfo(options: RequestOptions): FetchArgs {
            const localVarPath = `/system/console/status-productinfo.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getConfigMgr(options: RequestOptions): FetchArgs {
            const localVarPath = `/system/console/configMgr`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postBundle(name: string, action: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postBundle.');
            }
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling postBundle.');
            }
            const localVarPath = `/system/console/bundles/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = ((action:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postJmxRepository(action: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling postJmxRepository.');
            }
            const localVarPath = `/system/console/jmx/com.adobe.granite:type=Repository/op/{action}`
                .replace(`{${"action"}}`, encodeURIComponent(String(action)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postSamlConfiguration(post?: boolean, apply?: boolean, _delete?: boolean, action?: string, $location?: string, path?: Array<string>, serviceRanking?: number, idpUrl?: string, idpCertAlias?: string, idpHttpRedirect?: boolean, serviceProviderEntityId?: string, assertionConsumerServiceURL?: string, spPrivateKeyAlias?: string, keyStorePassword?: string, defaultRedirectUrl?: string, userIDAttribute?: string, useEncryption?: boolean, createUser?: boolean, addGroupMemberships?: boolean, groupMembershipAttribute?: string, defaultGroups?: Array<string>, nameIdFormat?: string, synchronizeAttributes?: Array<string>, handleLogout?: boolean, logoutUrl?: string, clockTolerance?: number, digestMethod?: string, signatureMethod?: string, userIntermediatePath?: string, propertylist?: Array<string>, options: RequestOptions): FetchArgs {
            const localVarPath = `/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (post !== undefined) {
                localVarQueryParameter['post'] = ((post:any):string);
            }

            if (apply !== undefined) {
                localVarQueryParameter['apply'] = ((apply:any):string);
            }

            if (_delete !== undefined) {
                localVarQueryParameter['delete'] = ((_delete:any):string);
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = ((action:any):string);
            }

            if ($location !== undefined) {
                localVarQueryParameter['$location'] = (($location:any):string);
            }

            if (path) {
                localVarQueryParameter['path'] = path;
            }

            if (serviceRanking !== undefined) {
                localVarQueryParameter['service.ranking'] = ((serviceRanking:any):string);
            }

            if (idpUrl !== undefined) {
                localVarQueryParameter['idpUrl'] = ((idpUrl:any):string);
            }

            if (idpCertAlias !== undefined) {
                localVarQueryParameter['idpCertAlias'] = ((idpCertAlias:any):string);
            }

            if (idpHttpRedirect !== undefined) {
                localVarQueryParameter['idpHttpRedirect'] = ((idpHttpRedirect:any):string);
            }

            if (serviceProviderEntityId !== undefined) {
                localVarQueryParameter['serviceProviderEntityId'] = ((serviceProviderEntityId:any):string);
            }

            if (assertionConsumerServiceURL !== undefined) {
                localVarQueryParameter['assertionConsumerServiceURL'] = ((assertionConsumerServiceURL:any):string);
            }

            if (spPrivateKeyAlias !== undefined) {
                localVarQueryParameter['spPrivateKeyAlias'] = ((spPrivateKeyAlias:any):string);
            }

            if (keyStorePassword !== undefined) {
                localVarQueryParameter['keyStorePassword'] = ((keyStorePassword:any):string);
            }

            if (defaultRedirectUrl !== undefined) {
                localVarQueryParameter['defaultRedirectUrl'] = ((defaultRedirectUrl:any):string);
            }

            if (userIDAttribute !== undefined) {
                localVarQueryParameter['userIDAttribute'] = ((userIDAttribute:any):string);
            }

            if (useEncryption !== undefined) {
                localVarQueryParameter['useEncryption'] = ((useEncryption:any):string);
            }

            if (createUser !== undefined) {
                localVarQueryParameter['createUser'] = ((createUser:any):string);
            }

            if (addGroupMemberships !== undefined) {
                localVarQueryParameter['addGroupMemberships'] = ((addGroupMemberships:any):string);
            }

            if (groupMembershipAttribute !== undefined) {
                localVarQueryParameter['groupMembershipAttribute'] = ((groupMembershipAttribute:any):string);
            }

            if (defaultGroups) {
                localVarQueryParameter['defaultGroups'] = defaultGroups;
            }

            if (nameIdFormat !== undefined) {
                localVarQueryParameter['nameIdFormat'] = ((nameIdFormat:any):string);
            }

            if (synchronizeAttributes) {
                localVarQueryParameter['synchronizeAttributes'] = synchronizeAttributes;
            }

            if (handleLogout !== undefined) {
                localVarQueryParameter['handleLogout'] = ((handleLogout:any):string);
            }

            if (logoutUrl !== undefined) {
                localVarQueryParameter['logoutUrl'] = ((logoutUrl:any):string);
            }

            if (clockTolerance !== undefined) {
                localVarQueryParameter['clockTolerance'] = ((clockTolerance:any):string);
            }

            if (digestMethod !== undefined) {
                localVarQueryParameter['digestMethod'] = ((digestMethod:any):string);
            }

            if (signatureMethod !== undefined) {
                localVarQueryParameter['signatureMethod'] = ((signatureMethod:any):string);
            }

            if (userIntermediatePath !== undefined) {
                localVarQueryParameter['userIntermediatePath'] = ((userIntermediatePath:any):string);
            }

            if (propertylist) {
                localVarQueryParameter['propertylist'] = propertylist.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ConsoleApiType = { 
    getAemProductInfo(options?: RequestOptions): Promise<Array<string>>,

    getConfigMgr(options?: RequestOptions): Promise<string>,

    postBundle(name: string, action: string, options?: RequestOptions): Promise<Response>,

    postJmxRepository(action: string, options?: RequestOptions): Promise<Response>,

    postSamlConfiguration(post?: boolean, apply?: boolean, _delete?: boolean, action?: string, $location?: string, path?: Array<string>, serviceRanking?: number, idpUrl?: string, idpCertAlias?: string, idpHttpRedirect?: boolean, serviceProviderEntityId?: string, assertionConsumerServiceURL?: string, spPrivateKeyAlias?: string, keyStorePassword?: string, defaultRedirectUrl?: string, userIDAttribute?: string, useEncryption?: boolean, createUser?: boolean, addGroupMemberships?: boolean, groupMembershipAttribute?: string, defaultGroups?: Array<string>, nameIdFormat?: string, synchronizeAttributes?: Array<string>, handleLogout?: boolean, logoutUrl?: string, clockTolerance?: number, digestMethod?: string, signatureMethod?: string, userIntermediatePath?: string, propertylist?: Array<string>, options?: RequestOptions): Promise<SamlConfigurationInfo>,
}

/**
 * ConsoleApi - factory function to inject configuration 
 * @export
 */
export const ConsoleApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ConsoleApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getAemProductInfo(options?: RequestOptions = {}): Promise<Array<string>> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).getAemProductInfo(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getConfigMgr(options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).getConfigMgr(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postBundle(name: string, action: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).postBundle(name, action, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postJmxRepository(action: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).postJmxRepository(action, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postSamlConfiguration(post?: boolean, apply?: boolean, _delete?: boolean, action?: string, $location?: string, path?: Array<string>, serviceRanking?: number, idpUrl?: string, idpCertAlias?: string, idpHttpRedirect?: boolean, serviceProviderEntityId?: string, assertionConsumerServiceURL?: string, spPrivateKeyAlias?: string, keyStorePassword?: string, defaultRedirectUrl?: string, userIDAttribute?: string, useEncryption?: boolean, createUser?: boolean, addGroupMemberships?: boolean, groupMembershipAttribute?: string, defaultGroups?: Array<string>, nameIdFormat?: string, synchronizeAttributes?: Array<string>, handleLogout?: boolean, logoutUrl?: string, clockTolerance?: number, digestMethod?: string, signatureMethod?: string, userIntermediatePath?: string, propertylist?: Array<string>, options?: RequestOptions = {}): Promise<SamlConfigurationInfo> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).postSamlConfiguration(post, apply, _delete, action, $location, path, serviceRanking, idpUrl, idpCertAlias, idpHttpRedirect, serviceProviderEntityId, assertionConsumerServiceURL, spPrivateKeyAlias, keyStorePassword, defaultRedirectUrl, userIDAttribute, useEncryption, createUser, addGroupMemberships, groupMembershipAttribute, defaultGroups, nameIdFormat, synchronizeAttributes, handleLogout, logoutUrl, clockTolerance, digestMethod, signatureMethod, userIntermediatePath, propertylist, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * CqApi - fetch parameter creator
 * @export
 */
export const CqApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getLoginPage(options: RequestOptions): FetchArgs {
            const localVarPath = `/libs/granite/core/content/login.html`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postCqActions(authorizableId: string, changelog: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling postCqActions.');
            }
            // verify required parameter 'changelog' is not null or undefined
            if (changelog === null || changelog === undefined) {
                throw new RequiredError('changelog','Required parameter changelog was null or undefined when calling postCqActions.');
            }
            const localVarPath = `/.cqactions.html`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorizableId !== undefined) {
                localVarQueryParameter['authorizableId'] = ((authorizableId:any):string);
            }

            if (changelog !== undefined) {
                localVarQueryParameter['changelog'] = ((changelog:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CqApiType = { 
    getLoginPage(options?: RequestOptions): Promise<string>,

    postCqActions(authorizableId: string, changelog: string, options?: RequestOptions): Promise<Response>,
}

/**
 * CqApi - factory function to inject configuration 
 * @export
 */
export const CqApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CqApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getLoginPage(options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CqApiFetchParamCreator(configuration).getLoginPage(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postCqActions(authorizableId: string, changelog: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CqApiFetchParamCreator(configuration).postCqActions(authorizableId, changelog, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * CrxApi - fetch parameter creator
 * @export
 */
export const CrxApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getCrxdeStatus(options: RequestOptions): FetchArgs {
            const localVarPath = `/crx/server/crx.default/jcr:root/.1.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getInstallStatus(options: RequestOptions): FetchArgs {
            const localVarPath = `/crx/packmgr/installstatus.jsp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getPackageManagerServlet(options: RequestOptions): FetchArgs {
            const localVarPath = `/crx/packmgr/service/script.html`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPackageService(cmd: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'cmd' is not null or undefined
            if (cmd === null || cmd === undefined) {
                throw new RequiredError('cmd','Required parameter cmd was null or undefined when calling postPackageService.');
            }
            const localVarPath = `/crx/packmgr/service.jsp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (cmd !== undefined) {
                localVarQueryParameter['cmd'] = ((cmd:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPackageServiceJson(path: string, cmd: string, groupName?: string, packageName?: string, packageVersion?: string, charset?: string, force?: boolean, recursive?: boolean, _package?: any, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postPackageServiceJson.');
            }
            // verify required parameter 'cmd' is not null or undefined
            if (cmd === null || cmd === undefined) {
                throw new RequiredError('cmd','Required parameter cmd was null or undefined when calling postPackageServiceJson.');
            }
            const localVarPath = `/crx/packmgr/service/.json/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (cmd !== undefined) {
                localVarQueryParameter['cmd'] = ((cmd:any):string);
            }

            if (groupName !== undefined) {
                localVarQueryParameter['groupName'] = ((groupName:any):string);
            }

            if (packageName !== undefined) {
                localVarQueryParameter['packageName'] = ((packageName:any):string);
            }

            if (packageVersion !== undefined) {
                localVarQueryParameter['packageVersion'] = ((packageVersion:any):string);
            }

            if (charset !== undefined) {
                localVarQueryParameter['_charset_'] = ((charset:any):string);
            }

            if (force !== undefined) {
                localVarQueryParameter['force'] = ((force:any):string);
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = ((recursive:any):string);
            }

            if (_package !== undefined) {
                localVarFormParams.set('package', ((_package:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPackageUpdate(groupName: string, packageName: string, version: string, path: string, filter?: string, charset?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'groupName' is not null or undefined
            if (groupName === null || groupName === undefined) {
                throw new RequiredError('groupName','Required parameter groupName was null or undefined when calling postPackageUpdate.');
            }
            // verify required parameter 'packageName' is not null or undefined
            if (packageName === null || packageName === undefined) {
                throw new RequiredError('packageName','Required parameter packageName was null or undefined when calling postPackageUpdate.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling postPackageUpdate.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postPackageUpdate.');
            }
            const localVarPath = `/crx/packmgr/update.jsp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (groupName !== undefined) {
                localVarQueryParameter['groupName'] = ((groupName:any):string);
            }

            if (packageName !== undefined) {
                localVarQueryParameter['packageName'] = ((packageName:any):string);
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = ((version:any):string);
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = ((path:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            if (charset !== undefined) {
                localVarQueryParameter['_charset_'] = ((charset:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postSetPassword(old: string, plain: string, verify: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'old' is not null or undefined
            if (old === null || old === undefined) {
                throw new RequiredError('old','Required parameter old was null or undefined when calling postSetPassword.');
            }
            // verify required parameter 'plain' is not null or undefined
            if (plain === null || plain === undefined) {
                throw new RequiredError('plain','Required parameter plain was null or undefined when calling postSetPassword.');
            }
            // verify required parameter 'verify' is not null or undefined
            if (verify === null || verify === undefined) {
                throw new RequiredError('verify','Required parameter verify was null or undefined when calling postSetPassword.');
            }
            const localVarPath = `/crx/explorer/ui/setpassword.jsp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (old !== undefined) {
                localVarQueryParameter['old'] = ((old:any):string);
            }

            if (plain !== undefined) {
                localVarQueryParameter['plain'] = ((plain:any):string);
            }

            if (verify !== undefined) {
                localVarQueryParameter['verify'] = ((verify:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CrxApiType = { 
    getCrxdeStatus(options?: RequestOptions): Promise<string>,

    getInstallStatus(options?: RequestOptions): Promise<InstallStatus>,

    getPackageManagerServlet(options?: RequestOptions): Promise<Response>,

    postPackageService(cmd: string, options?: RequestOptions): Promise<string>,

    postPackageServiceJson(path: string, cmd: string, groupName?: string, packageName?: string, packageVersion?: string, charset?: string, force?: boolean, recursive?: boolean, _package?: any, options?: RequestOptions): Promise<string>,

    postPackageUpdate(groupName: string, packageName: string, version: string, path: string, filter?: string, charset?: string, options?: RequestOptions): Promise<string>,

    postSetPassword(old: string, plain: string, verify: string, options?: RequestOptions): Promise<string>,
}

/**
 * CrxApi - factory function to inject configuration 
 * @export
 */
export const CrxApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CrxApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getCrxdeStatus(options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).getCrxdeStatus(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getInstallStatus(options?: RequestOptions = {}): Promise<InstallStatus> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).getInstallStatus(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getPackageManagerServlet(options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).getPackageManagerServlet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPackageService(cmd: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).postPackageService(cmd, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPackageServiceJson(path: string, cmd: string, groupName?: string, packageName?: string, packageVersion?: string, charset?: string, force?: boolean, recursive?: boolean, _package?: any, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).postPackageServiceJson(path, cmd, groupName, packageName, packageVersion, charset, force, recursive, _package, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPackageUpdate(groupName: string, packageName: string, version: string, path: string, filter?: string, charset?: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).postPackageUpdate(groupName, packageName, version, path, filter, charset, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postSetPassword(old: string, plain: string, verify: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).postSetPassword(old, plain, verify, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * CustomApi - fetch parameter creator
 * @export
 */
export const CustomApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getAemHealthCheck(tags?: string, combineTagsOr?: boolean, options: RequestOptions): FetchArgs {
            const localVarPath = `/system/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = ((tags:any):string);
            }

            if (combineTagsOr !== undefined) {
                localVarQueryParameter['combineTagsOr'] = ((combineTagsOr:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigAemHealthCheckServlet(bundlesIgnored?: Array<string>, bundlesIgnored@TypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/com.shinesolutions.healthcheck.hc.impl.ActiveBundleHealthCheck`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (bundlesIgnored) {
                localVarQueryParameter['bundles.ignored'] = bundlesIgnored;
            }

            if (bundlesIgnored@TypeHint !== undefined) {
                localVarQueryParameter['bundles.ignored@TypeHint'] = ((bundlesIgnored@TypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigAemPasswordReset(pwdresetAuthorizables?: Array<string>, pwdresetAuthorizables@TypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/com.shinesolutions.aem.passwordreset.Activator`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (pwdresetAuthorizables) {
                localVarQueryParameter['pwdreset.authorizables'] = pwdresetAuthorizables;
            }

            if (pwdresetAuthorizables@TypeHint !== undefined) {
                localVarQueryParameter['pwdreset.authorizables@TypeHint'] = ((pwdresetAuthorizables@TypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CustomApiType = { 
    getAemHealthCheck(tags?: string, combineTagsOr?: boolean, options?: RequestOptions): Promise<string>,

    postConfigAemHealthCheckServlet(bundlesIgnored?: Array<string>, bundlesIgnored@TypeHint?: string, options?: RequestOptions): Promise<Response>,

    postConfigAemPasswordReset(pwdresetAuthorizables?: Array<string>, pwdresetAuthorizables@TypeHint?: string, options?: RequestOptions): Promise<Response>,
}

/**
 * CustomApi - factory function to inject configuration 
 * @export
 */
export const CustomApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CustomApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getAemHealthCheck(tags?: string, combineTagsOr?: boolean, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CustomApiFetchParamCreator(configuration).getAemHealthCheck(tags, combineTagsOr, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigAemHealthCheckServlet(bundlesIgnored?: Array<string>, bundlesIgnored@TypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CustomApiFetchParamCreator(configuration).postConfigAemHealthCheckServlet(bundlesIgnored, bundlesIgnored@TypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigAemPasswordReset(pwdresetAuthorizables?: Array<string>, pwdresetAuthorizables@TypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CustomApiFetchParamCreator(configuration).postConfigAemPasswordReset(pwdresetAuthorizables, pwdresetAuthorizables@TypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * SlingApi - fetch parameter creator
 * @export
 */
export const SlingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        deleteAgent(runmode: string, name: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'runmode' is not null or undefined
            if (runmode === null || runmode === undefined) {
                throw new RequiredError('runmode','Required parameter runmode was null or undefined when calling deleteAgent.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteAgent.');
            }
            const localVarPath = `/etc/replication/agents.{runmode}/{name}`
                .replace(`{${"runmode"}}`, encodeURIComponent(String(runmode)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        deleteNode(path: string, name: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling deleteNode.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteNode.');
            }
            const localVarPath = `/{path}/{name}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getAgent(runmode: string, name: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'runmode' is not null or undefined
            if (runmode === null || runmode === undefined) {
                throw new RequiredError('runmode','Required parameter runmode was null or undefined when calling getAgent.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getAgent.');
            }
            const localVarPath = `/etc/replication/agents.{runmode}/{name}`
                .replace(`{${"runmode"}}`, encodeURIComponent(String(runmode)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getAgents(runmode: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'runmode' is not null or undefined
            if (runmode === null || runmode === undefined) {
                throw new RequiredError('runmode','Required parameter runmode was null or undefined when calling getAgents.');
            }
            const localVarPath = `/etc/replication/agents.{runmode}.-1.json`
                .replace(`{${"runmode"}}`, encodeURIComponent(String(runmode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getAuthorizableKeystore(intermediatePath: string, authorizableId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'intermediatePath' is not null or undefined
            if (intermediatePath === null || intermediatePath === undefined) {
                throw new RequiredError('intermediatePath','Required parameter intermediatePath was null or undefined when calling getAuthorizableKeystore.');
            }
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling getAuthorizableKeystore.');
            }
            const localVarPath = `/{intermediatePath}/{authorizableId}.ks.json`
                .replace(`{${"intermediatePath"}}`, encodeURIComponent(String(intermediatePath)))
                .replace(`{${"authorizableId"}}`, encodeURIComponent(String(authorizableId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getKeystore(intermediatePath: string, authorizableId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'intermediatePath' is not null or undefined
            if (intermediatePath === null || intermediatePath === undefined) {
                throw new RequiredError('intermediatePath','Required parameter intermediatePath was null or undefined when calling getKeystore.');
            }
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling getKeystore.');
            }
            const localVarPath = `/{intermediatePath}/{authorizableId}/keystore/store.p12`
                .replace(`{${"intermediatePath"}}`, encodeURIComponent(String(intermediatePath)))
                .replace(`{${"authorizableId"}}`, encodeURIComponent(String(authorizableId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getNode(path: string, name: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getNode.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getNode.');
            }
            const localVarPath = `/{path}/{name}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getPackage(group: string, name: string, version: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getPackage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPackage.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getPackage.');
            }
            const localVarPath = `/etc/packages/{group}/{name}-{version}.zip`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getPackageFilter(group: string, name: string, version: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getPackageFilter.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPackageFilter.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getPackageFilter.');
            }
            const localVarPath = `/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getQuery.');
            }
            // verify required parameter 'pLimit' is not null or undefined
            if (pLimit === null || pLimit === undefined) {
                throw new RequiredError('pLimit','Required parameter pLimit was null or undefined when calling getQuery.');
            }
            // verify required parameter '_1property' is not null or undefined
            if (_1property === null || _1property === undefined) {
                throw new RequiredError('_1property','Required parameter _1property was null or undefined when calling getQuery.');
            }
            // verify required parameter '_1propertyValue' is not null or undefined
            if (_1propertyValue === null || _1propertyValue === undefined) {
                throw new RequiredError('_1propertyValue','Required parameter _1propertyValue was null or undefined when calling getQuery.');
            }
            const localVarPath = `/bin/querybuilder.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = ((path:any):string);
            }

            if (pLimit !== undefined) {
                localVarQueryParameter['p.limit'] = ((pLimit:any):string);
            }

            if (_1property !== undefined) {
                localVarQueryParameter['1_property'] = ((_1property:any):string);
            }

            if (_1propertyValue !== undefined) {
                localVarQueryParameter['1_property.value'] = ((_1propertyValue:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getTruststore(options: RequestOptions): FetchArgs {
            const localVarPath = `/etc/truststore/truststore.p12`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getTruststoreInfo(options: RequestOptions): FetchArgs {
            const localVarPath = `/libs/granite/security/truststore.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'runmode' is not null or undefined
            if (runmode === null || runmode === undefined) {
                throw new RequiredError('runmode','Required parameter runmode was null or undefined when calling postAgent.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postAgent.');
            }
            const localVarPath = `/etc/replication/agents.{runmode}/{name}`
                .replace(`{${"runmode"}}`, encodeURIComponent(String(runmode)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jcr:contentCq:distribute !== undefined) {
                localVarQueryParameter['jcr:content/cq:distribute'] = ((jcr:contentCq:distribute:any):string);
            }

            if (jcr:contentCq:distribute@TypeHint !== undefined) {
                localVarQueryParameter['jcr:content/cq:distribute@TypeHint'] = ((jcr:contentCq:distribute@TypeHint:any):string);
            }

            if (jcr:contentCq:name !== undefined) {
                localVarQueryParameter['jcr:content/cq:name'] = ((jcr:contentCq:name:any):string);
            }

            if (jcr:contentCq:template !== undefined) {
                localVarQueryParameter['jcr:content/cq:template'] = ((jcr:contentCq:template:any):string);
            }

            if (jcr:contentEnabled !== undefined) {
                localVarQueryParameter['jcr:content/enabled'] = ((jcr:contentEnabled:any):string);
            }

            if (jcr:contentJcr:description !== undefined) {
                localVarQueryParameter['jcr:content/jcr:description'] = ((jcr:contentJcr:description:any):string);
            }

            if (jcr:contentJcr:lastModified !== undefined) {
                localVarQueryParameter['jcr:content/jcr:lastModified'] = ((jcr:contentJcr:lastModified:any):string);
            }

            if (jcr:contentJcr:lastModifiedBy !== undefined) {
                localVarQueryParameter['jcr:content/jcr:lastModifiedBy'] = ((jcr:contentJcr:lastModifiedBy:any):string);
            }

            if (jcr:contentJcr:mixinTypes !== undefined) {
                localVarQueryParameter['jcr:content/jcr:mixinTypes'] = ((jcr:contentJcr:mixinTypes:any):string);
            }

            if (jcr:contentJcr:title !== undefined) {
                localVarQueryParameter['jcr:content/jcr:title'] = ((jcr:contentJcr:title:any):string);
            }

            if (jcr:contentLogLevel !== undefined) {
                localVarQueryParameter['jcr:content/logLevel'] = ((jcr:contentLogLevel:any):string);
            }

            if (jcr:contentNoStatusUpdate !== undefined) {
                localVarQueryParameter['jcr:content/noStatusUpdate'] = ((jcr:contentNoStatusUpdate:any):string);
            }

            if (jcr:contentNoVersioning !== undefined) {
                localVarQueryParameter['jcr:content/noVersioning'] = ((jcr:contentNoVersioning:any):string);
            }

            if (jcr:contentProtocolConnectTimeout !== undefined) {
                localVarQueryParameter['jcr:content/protocolConnectTimeout'] = ((jcr:contentProtocolConnectTimeout:any):string);
            }

            if (jcr:contentProtocolHTTPConnectionClosed !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPConnectionClosed'] = ((jcr:contentProtocolHTTPConnectionClosed:any):string);
            }

            if (jcr:contentProtocolHTTPExpired !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPExpired'] = ((jcr:contentProtocolHTTPExpired:any):string);
            }

            if (jcr:contentProtocolHTTPHeaders) {
                localVarQueryParameter['jcr:content/protocolHTTPHeaders'] = jcr:contentProtocolHTTPHeaders;
            }

            if (jcr:contentProtocolHTTPHeaders@TypeHint !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPHeaders@TypeHint'] = ((jcr:contentProtocolHTTPHeaders@TypeHint:any):string);
            }

            if (jcr:contentProtocolHTTPMethod !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPMethod'] = ((jcr:contentProtocolHTTPMethod:any):string);
            }

            if (jcr:contentProtocolHTTPSRelaxed !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPSRelaxed'] = ((jcr:contentProtocolHTTPSRelaxed:any):string);
            }

            if (jcr:contentProtocolInterface !== undefined) {
                localVarQueryParameter['jcr:content/protocolInterface'] = ((jcr:contentProtocolInterface:any):string);
            }

            if (jcr:contentProtocolSocketTimeout !== undefined) {
                localVarQueryParameter['jcr:content/protocolSocketTimeout'] = ((jcr:contentProtocolSocketTimeout:any):string);
            }

            if (jcr:contentProtocolVersion !== undefined) {
                localVarQueryParameter['jcr:content/protocolVersion'] = ((jcr:contentProtocolVersion:any):string);
            }

            if (jcr:contentProxyNTLMDomain !== undefined) {
                localVarQueryParameter['jcr:content/proxyNTLMDomain'] = ((jcr:contentProxyNTLMDomain:any):string);
            }

            if (jcr:contentProxyNTLMHost !== undefined) {
                localVarQueryParameter['jcr:content/proxyNTLMHost'] = ((jcr:contentProxyNTLMHost:any):string);
            }

            if (jcr:contentProxyHost !== undefined) {
                localVarQueryParameter['jcr:content/proxyHost'] = ((jcr:contentProxyHost:any):string);
            }

            if (jcr:contentProxyPassword !== undefined) {
                localVarQueryParameter['jcr:content/proxyPassword'] = ((jcr:contentProxyPassword:any):string);
            }

            if (jcr:contentProxyPort !== undefined) {
                localVarQueryParameter['jcr:content/proxyPort'] = ((jcr:contentProxyPort:any):string);
            }

            if (jcr:contentProxyUser !== undefined) {
                localVarQueryParameter['jcr:content/proxyUser'] = ((jcr:contentProxyUser:any):string);
            }

            if (jcr:contentQueueBatchMaxSize !== undefined) {
                localVarQueryParameter['jcr:content/queueBatchMaxSize'] = ((jcr:contentQueueBatchMaxSize:any):string);
            }

            if (jcr:contentQueueBatchMode !== undefined) {
                localVarQueryParameter['jcr:content/queueBatchMode'] = ((jcr:contentQueueBatchMode:any):string);
            }

            if (jcr:contentQueueBatchWaitTime !== undefined) {
                localVarQueryParameter['jcr:content/queueBatchWaitTime'] = ((jcr:contentQueueBatchWaitTime:any):string);
            }

            if (jcr:contentRetryDelay !== undefined) {
                localVarQueryParameter['jcr:content/retryDelay'] = ((jcr:contentRetryDelay:any):string);
            }

            if (jcr:contentReverseReplication !== undefined) {
                localVarQueryParameter['jcr:content/reverseReplication'] = ((jcr:contentReverseReplication:any):string);
            }

            if (jcr:contentSerializationType !== undefined) {
                localVarQueryParameter['jcr:content/serializationType'] = ((jcr:contentSerializationType:any):string);
            }

            if (jcr:contentSling:resourceType !== undefined) {
                localVarQueryParameter['jcr:content/sling:resourceType'] = ((jcr:contentSling:resourceType:any):string);
            }

            if (jcr:contentSsl !== undefined) {
                localVarQueryParameter['jcr:content/ssl'] = ((jcr:contentSsl:any):string);
            }

            if (jcr:contentTransportNTLMDomain !== undefined) {
                localVarQueryParameter['jcr:content/transportNTLMDomain'] = ((jcr:contentTransportNTLMDomain:any):string);
            }

            if (jcr:contentTransportNTLMHost !== undefined) {
                localVarQueryParameter['jcr:content/transportNTLMHost'] = ((jcr:contentTransportNTLMHost:any):string);
            }

            if (jcr:contentTransportPassword !== undefined) {
                localVarQueryParameter['jcr:content/transportPassword'] = ((jcr:contentTransportPassword:any):string);
            }

            if (jcr:contentTransportUri !== undefined) {
                localVarQueryParameter['jcr:content/transportUri'] = ((jcr:contentTransportUri:any):string);
            }

            if (jcr:contentTransportUser !== undefined) {
                localVarQueryParameter['jcr:content/transportUser'] = ((jcr:contentTransportUser:any):string);
            }

            if (jcr:contentTriggerDistribute !== undefined) {
                localVarQueryParameter['jcr:content/triggerDistribute'] = ((jcr:contentTriggerDistribute:any):string);
            }

            if (jcr:contentTriggerModified !== undefined) {
                localVarQueryParameter['jcr:content/triggerModified'] = ((jcr:contentTriggerModified:any):string);
            }

            if (jcr:contentTriggerOnOffTime !== undefined) {
                localVarQueryParameter['jcr:content/triggerOnOffTime'] = ((jcr:contentTriggerOnOffTime:any):string);
            }

            if (jcr:contentTriggerReceive !== undefined) {
                localVarQueryParameter['jcr:content/triggerReceive'] = ((jcr:contentTriggerReceive:any):string);
            }

            if (jcr:contentTriggerSpecific !== undefined) {
                localVarQueryParameter['jcr:content/triggerSpecific'] = ((jcr:contentTriggerSpecific:any):string);
            }

            if (jcr:contentUserId !== undefined) {
                localVarQueryParameter['jcr:content/userId'] = ((jcr:contentUserId:any):string);
            }

            if (jcr:primaryType !== undefined) {
                localVarQueryParameter['jcr:primaryType'] = ((jcr:primaryType:any):string);
            }

            if (:operation !== undefined) {
                localVarQueryParameter[':operation'] = ((:operation:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: any, pk?: any, keyStore?: any, options: RequestOptions): FetchArgs {
            // verify required parameter 'intermediatePath' is not null or undefined
            if (intermediatePath === null || intermediatePath === undefined) {
                throw new RequiredError('intermediatePath','Required parameter intermediatePath was null or undefined when calling postAuthorizableKeystore.');
            }
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling postAuthorizableKeystore.');
            }
            const localVarPath = `/{intermediatePath}/{authorizableId}.ks.html`
                .replace(`{${"intermediatePath"}}`, encodeURIComponent(String(intermediatePath)))
                .replace(`{${"authorizableId"}}`, encodeURIComponent(String(authorizableId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (:operation !== undefined) {
                localVarQueryParameter[':operation'] = ((:operation:any):string);
            }

            if (currentPassword !== undefined) {
                localVarQueryParameter['currentPassword'] = ((currentPassword:any):string);
            }

            if (newPassword !== undefined) {
                localVarQueryParameter['newPassword'] = ((newPassword:any):string);
            }

            if (rePassword !== undefined) {
                localVarQueryParameter['rePassword'] = ((rePassword:any):string);
            }

            if (keyPassword !== undefined) {
                localVarQueryParameter['keyPassword'] = ((keyPassword:any):string);
            }

            if (keyStorePass !== undefined) {
                localVarQueryParameter['keyStorePass'] = ((keyStorePass:any):string);
            }

            if (alias !== undefined) {
                localVarQueryParameter['alias'] = ((alias:any):string);
            }

            if (newAlias !== undefined) {
                localVarQueryParameter['newAlias'] = ((newAlias:any):string);
            }

            if (removeAlias !== undefined) {
                localVarQueryParameter['removeAlias'] = ((removeAlias:any):string);
            }

            if (certChain !== undefined) {
                localVarFormParams.set('cert-chain', ((certChain:any):string));
            }

            if (pk !== undefined) {
                localVarFormParams.set('pk', ((pk:any):string));
            }

            if (keyStore !== undefined) {
                localVarFormParams.set('keyStore', ((keyStore:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling postAuthorizables.');
            }
            // verify required parameter 'intermediatePath' is not null or undefined
            if (intermediatePath === null || intermediatePath === undefined) {
                throw new RequiredError('intermediatePath','Required parameter intermediatePath was null or undefined when calling postAuthorizables.');
            }
            const localVarPath = `/libs/granite/security/post/authorizables`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorizableId !== undefined) {
                localVarQueryParameter['authorizableId'] = ((authorizableId:any):string);
            }

            if (intermediatePath !== undefined) {
                localVarQueryParameter['intermediatePath'] = ((intermediatePath:any):string);
            }

            if (createUser !== undefined) {
                localVarQueryParameter['createUser'] = ((createUser:any):string);
            }

            if (createGroup !== undefined) {
                localVarQueryParameter['createGroup'] = ((createGroup:any):string);
            }

            if (rep:password !== undefined) {
                localVarQueryParameter['rep:password'] = ((rep:password:any):string);
            }

            if (profileGivenName !== undefined) {
                localVarQueryParameter['profile/givenName'] = ((profileGivenName:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (keyStorePassword !== undefined) {
                localVarQueryParameter['keyStorePassword'] = ((keyStorePassword:any):string);
            }

            if (keyStorePassword@TypeHint !== undefined) {
                localVarQueryParameter['keyStorePassword@TypeHint'] = ((keyStorePassword@TypeHint:any):string);
            }

            if (serviceRanking !== undefined) {
                localVarQueryParameter['service.ranking'] = ((serviceRanking:any):string);
            }

            if (serviceRanking@TypeHint !== undefined) {
                localVarQueryParameter['service.ranking@TypeHint'] = ((serviceRanking@TypeHint:any):string);
            }

            if (idpHttpRedirect !== undefined) {
                localVarQueryParameter['idpHttpRedirect'] = ((idpHttpRedirect:any):string);
            }

            if (idpHttpRedirect@TypeHint !== undefined) {
                localVarQueryParameter['idpHttpRedirect@TypeHint'] = ((idpHttpRedirect@TypeHint:any):string);
            }

            if (createUser !== undefined) {
                localVarQueryParameter['createUser'] = ((createUser:any):string);
            }

            if (createUser@TypeHint !== undefined) {
                localVarQueryParameter['createUser@TypeHint'] = ((createUser@TypeHint:any):string);
            }

            if (defaultRedirectUrl !== undefined) {
                localVarQueryParameter['defaultRedirectUrl'] = ((defaultRedirectUrl:any):string);
            }

            if (defaultRedirectUrl@TypeHint !== undefined) {
                localVarQueryParameter['defaultRedirectUrl@TypeHint'] = ((defaultRedirectUrl@TypeHint:any):string);
            }

            if (userIDAttribute !== undefined) {
                localVarQueryParameter['userIDAttribute'] = ((userIDAttribute:any):string);
            }

            if (userIDAttribute@TypeHint !== undefined) {
                localVarQueryParameter['userIDAttribute@TypeHint'] = ((userIDAttribute@TypeHint:any):string);
            }

            if (defaultGroups) {
                localVarQueryParameter['defaultGroups'] = defaultGroups;
            }

            if (defaultGroups@TypeHint !== undefined) {
                localVarQueryParameter['defaultGroups@TypeHint'] = ((defaultGroups@TypeHint:any):string);
            }

            if (idpCertAlias !== undefined) {
                localVarQueryParameter['idpCertAlias'] = ((idpCertAlias:any):string);
            }

            if (idpCertAlias@TypeHint !== undefined) {
                localVarQueryParameter['idpCertAlias@TypeHint'] = ((idpCertAlias@TypeHint:any):string);
            }

            if (addGroupMemberships !== undefined) {
                localVarQueryParameter['addGroupMemberships'] = ((addGroupMemberships:any):string);
            }

            if (addGroupMemberships@TypeHint !== undefined) {
                localVarQueryParameter['addGroupMemberships@TypeHint'] = ((addGroupMemberships@TypeHint:any):string);
            }

            if (path) {
                localVarQueryParameter['path'] = path;
            }

            if (path@TypeHint !== undefined) {
                localVarQueryParameter['path@TypeHint'] = ((path@TypeHint:any):string);
            }

            if (synchronizeAttributes) {
                localVarQueryParameter['synchronizeAttributes'] = synchronizeAttributes;
            }

            if (synchronizeAttributes@TypeHint !== undefined) {
                localVarQueryParameter['synchronizeAttributes@TypeHint'] = ((synchronizeAttributes@TypeHint:any):string);
            }

            if (clockTolerance !== undefined) {
                localVarQueryParameter['clockTolerance'] = ((clockTolerance:any):string);
            }

            if (clockTolerance@TypeHint !== undefined) {
                localVarQueryParameter['clockTolerance@TypeHint'] = ((clockTolerance@TypeHint:any):string);
            }

            if (groupMembershipAttribute !== undefined) {
                localVarQueryParameter['groupMembershipAttribute'] = ((groupMembershipAttribute:any):string);
            }

            if (groupMembershipAttribute@TypeHint !== undefined) {
                localVarQueryParameter['groupMembershipAttribute@TypeHint'] = ((groupMembershipAttribute@TypeHint:any):string);
            }

            if (idpUrl !== undefined) {
                localVarQueryParameter['idpUrl'] = ((idpUrl:any):string);
            }

            if (idpUrl@TypeHint !== undefined) {
                localVarQueryParameter['idpUrl@TypeHint'] = ((idpUrl@TypeHint:any):string);
            }

            if (logoutUrl !== undefined) {
                localVarQueryParameter['logoutUrl'] = ((logoutUrl:any):string);
            }

            if (logoutUrl@TypeHint !== undefined) {
                localVarQueryParameter['logoutUrl@TypeHint'] = ((logoutUrl@TypeHint:any):string);
            }

            if (serviceProviderEntityId !== undefined) {
                localVarQueryParameter['serviceProviderEntityId'] = ((serviceProviderEntityId:any):string);
            }

            if (serviceProviderEntityId@TypeHint !== undefined) {
                localVarQueryParameter['serviceProviderEntityId@TypeHint'] = ((serviceProviderEntityId@TypeHint:any):string);
            }

            if (assertionConsumerServiceURL !== undefined) {
                localVarQueryParameter['assertionConsumerServiceURL'] = ((assertionConsumerServiceURL:any):string);
            }

            if (assertionConsumerServiceURL@TypeHint !== undefined) {
                localVarQueryParameter['assertionConsumerServiceURL@TypeHint'] = ((assertionConsumerServiceURL@TypeHint:any):string);
            }

            if (handleLogout !== undefined) {
                localVarQueryParameter['handleLogout'] = ((handleLogout:any):string);
            }

            if (handleLogout@TypeHint !== undefined) {
                localVarQueryParameter['handleLogout@TypeHint'] = ((handleLogout@TypeHint:any):string);
            }

            if (spPrivateKeyAlias !== undefined) {
                localVarQueryParameter['spPrivateKeyAlias'] = ((spPrivateKeyAlias:any):string);
            }

            if (spPrivateKeyAlias@TypeHint !== undefined) {
                localVarQueryParameter['spPrivateKeyAlias@TypeHint'] = ((spPrivateKeyAlias@TypeHint:any):string);
            }

            if (useEncryption !== undefined) {
                localVarQueryParameter['useEncryption'] = ((useEncryption:any):string);
            }

            if (useEncryption@TypeHint !== undefined) {
                localVarQueryParameter['useEncryption@TypeHint'] = ((useEncryption@TypeHint:any):string);
            }

            if (nameIdFormat !== undefined) {
                localVarQueryParameter['nameIdFormat'] = ((nameIdFormat:any):string);
            }

            if (nameIdFormat@TypeHint !== undefined) {
                localVarQueryParameter['nameIdFormat@TypeHint'] = ((nameIdFormat@TypeHint:any):string);
            }

            if (digestMethod !== undefined) {
                localVarQueryParameter['digestMethod'] = ((digestMethod:any):string);
            }

            if (digestMethod@TypeHint !== undefined) {
                localVarQueryParameter['digestMethod@TypeHint'] = ((digestMethod@TypeHint:any):string);
            }

            if (signatureMethod !== undefined) {
                localVarQueryParameter['signatureMethod'] = ((signatureMethod:any):string);
            }

            if (signatureMethod@TypeHint !== undefined) {
                localVarQueryParameter['signatureMethod@TypeHint'] = ((signatureMethod@TypeHint:any):string);
            }

            if (userIntermediatePath !== undefined) {
                localVarQueryParameter['userIntermediatePath'] = ((userIntermediatePath:any):string);
            }

            if (userIntermediatePath@TypeHint !== undefined) {
                localVarQueryParameter['userIntermediatePath@TypeHint'] = ((userIntermediatePath@TypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.felix.http`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (orgApacheFelixHttpsNio !== undefined) {
                localVarQueryParameter['org.apache.felix.https.nio'] = ((orgApacheFelixHttpsNio:any):string);
            }

            if (orgApacheFelixHttpsNio@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.nio@TypeHint'] = ((orgApacheFelixHttpsNio@TypeHint:any):string);
            }

            if (orgApacheFelixHttpsKeystore !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore'] = ((orgApacheFelixHttpsKeystore:any):string);
            }

            if (orgApacheFelixHttpsKeystore@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore@TypeHint'] = ((orgApacheFelixHttpsKeystore@TypeHint:any):string);
            }

            if (orgApacheFelixHttpsKeystorePassword !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.password'] = ((orgApacheFelixHttpsKeystorePassword:any):string);
            }

            if (orgApacheFelixHttpsKeystorePassword@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.password@TypeHint'] = ((orgApacheFelixHttpsKeystorePassword@TypeHint:any):string);
            }

            if (orgApacheFelixHttpsKeystoreKey !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.key'] = ((orgApacheFelixHttpsKeystoreKey:any):string);
            }

            if (orgApacheFelixHttpsKeystoreKey@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.key@TypeHint'] = ((orgApacheFelixHttpsKeystoreKey@TypeHint:any):string);
            }

            if (orgApacheFelixHttpsKeystoreKeyPassword !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.key.password'] = ((orgApacheFelixHttpsKeystoreKeyPassword:any):string);
            }

            if (orgApacheFelixHttpsKeystoreKeyPassword@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.key.password@TypeHint'] = ((orgApacheFelixHttpsKeystoreKeyPassword@TypeHint:any):string);
            }

            if (orgApacheFelixHttpsTruststore !== undefined) {
                localVarQueryParameter['org.apache.felix.https.truststore'] = ((orgApacheFelixHttpsTruststore:any):string);
            }

            if (orgApacheFelixHttpsTruststore@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.truststore@TypeHint'] = ((orgApacheFelixHttpsTruststore@TypeHint:any):string);
            }

            if (orgApacheFelixHttpsTruststorePassword !== undefined) {
                localVarQueryParameter['org.apache.felix.https.truststore.password'] = ((orgApacheFelixHttpsTruststorePassword:any):string);
            }

            if (orgApacheFelixHttpsTruststorePassword@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.truststore.password@TypeHint'] = ((orgApacheFelixHttpsTruststorePassword@TypeHint:any):string);
            }

            if (orgApacheFelixHttpsClientcertificate !== undefined) {
                localVarQueryParameter['org.apache.felix.https.clientcertificate'] = ((orgApacheFelixHttpsClientcertificate:any):string);
            }

            if (orgApacheFelixHttpsClientcertificate@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.clientcertificate@TypeHint'] = ((orgApacheFelixHttpsClientcertificate@TypeHint:any):string);
            }

            if (orgApacheFelixHttpsEnable !== undefined) {
                localVarQueryParameter['org.apache.felix.https.enable'] = ((orgApacheFelixHttpsEnable:any):string);
            }

            if (orgApacheFelixHttpsEnable@TypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.enable@TypeHint'] = ((orgApacheFelixHttpsEnable@TypeHint:any):string);
            }

            if (orgOsgiServiceHttpPortSecure !== undefined) {
                localVarQueryParameter['org.osgi.service.http.port.secure'] = ((orgOsgiServiceHttpPortSecure:any):string);
            }

            if (orgOsgiServiceHttpPortSecure@TypeHint !== undefined) {
                localVarQueryParameter['org.osgi.service.http.port.secure@TypeHint'] = ((orgOsgiServiceHttpPortSecure@TypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.http.proxyconfigurator.config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (proxyHost !== undefined) {
                localVarQueryParameter['proxy.host'] = ((proxyHost:any):string);
            }

            if (proxyHost@TypeHint !== undefined) {
                localVarQueryParameter['proxy.host@TypeHint'] = ((proxyHost@TypeHint:any):string);
            }

            if (proxyPort !== undefined) {
                localVarQueryParameter['proxy.port'] = ((proxyPort:any):string);
            }

            if (proxyPort@TypeHint !== undefined) {
                localVarQueryParameter['proxy.port@TypeHint'] = ((proxyPort@TypeHint:any):string);
            }

            if (proxyExceptions) {
                localVarQueryParameter['proxy.exceptions'] = proxyExceptions;
            }

            if (proxyExceptions@TypeHint !== undefined) {
                localVarQueryParameter['proxy.exceptions@TypeHint'] = ((proxyExceptions@TypeHint:any):string);
            }

            if (proxyEnabled !== undefined) {
                localVarQueryParameter['proxy.enabled'] = ((proxyEnabled:any):string);
            }

            if (proxyEnabled@TypeHint !== undefined) {
                localVarQueryParameter['proxy.enabled@TypeHint'] = ((proxyEnabled@TypeHint:any):string);
            }

            if (proxyUser !== undefined) {
                localVarQueryParameter['proxy.user'] = ((proxyUser:any):string);
            }

            if (proxyUser@TypeHint !== undefined) {
                localVarQueryParameter['proxy.user@TypeHint'] = ((proxyUser@TypeHint:any):string);
            }

            if (proxyPassword !== undefined) {
                localVarQueryParameter['proxy.password'] = ((proxyPassword:any):string);
            }

            if (proxyPassword@TypeHint !== undefined) {
                localVarQueryParameter['proxy.password@TypeHint'] = ((proxyPassword@TypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (alias !== undefined) {
                localVarQueryParameter['alias'] = ((alias:any):string);
            }

            if (alias@TypeHint !== undefined) {
                localVarQueryParameter['alias@TypeHint'] = ((alias@TypeHint:any):string);
            }

            if (davCreateAbsoluteUri !== undefined) {
                localVarQueryParameter['dav.create-absolute-uri'] = ((davCreateAbsoluteUri:any):string);
            }

            if (davCreateAbsoluteUri@TypeHint !== undefined) {
                localVarQueryParameter['dav.create-absolute-uri@TypeHint'] = ((davCreateAbsoluteUri@TypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jsonMaximumresults !== undefined) {
                localVarQueryParameter['json.maximumresults'] = ((jsonMaximumresults:any):string);
            }

            if (jsonMaximumresults@TypeHint !== undefined) {
                localVarQueryParameter['json.maximumresults@TypeHint'] = ((jsonMaximumresults@TypeHint:any):string);
            }

            if (enableHtml !== undefined) {
                localVarQueryParameter['enable.html'] = ((enableHtml:any):string);
            }

            if (enableHtml@TypeHint !== undefined) {
                localVarQueryParameter['enable.html@TypeHint'] = ((enableHtml@TypeHint:any):string);
            }

            if (enableTxt !== undefined) {
                localVarQueryParameter['enable.txt'] = ((enableTxt:any):string);
            }

            if (enableTxt@TypeHint !== undefined) {
                localVarQueryParameter['enable.txt@TypeHint'] = ((enableTxt@TypeHint:any):string);
            }

            if (enableXml !== undefined) {
                localVarQueryParameter['enable.xml'] = ((enableXml:any):string);
            }

            if (enableXml@TypeHint !== undefined) {
                localVarQueryParameter['enable.xml@TypeHint'] = ((enableXml@TypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.sling.security.impl.ReferrerFilter`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (allowEmpty !== undefined) {
                localVarQueryParameter['allow.empty'] = ((allowEmpty:any):string);
            }

            if (allowEmpty@TypeHint !== undefined) {
                localVarQueryParameter['allow.empty@TypeHint'] = ((allowEmpty@TypeHint:any):string);
            }

            if (allowHosts !== undefined) {
                localVarQueryParameter['allow.hosts'] = ((allowHosts:any):string);
            }

            if (allowHosts@TypeHint !== undefined) {
                localVarQueryParameter['allow.hosts@TypeHint'] = ((allowHosts@TypeHint:any):string);
            }

            if (allowHostsRegexp !== undefined) {
                localVarQueryParameter['allow.hosts.regexp'] = ((allowHostsRegexp:any):string);
            }

            if (allowHostsRegexp@TypeHint !== undefined) {
                localVarQueryParameter['allow.hosts.regexp@TypeHint'] = ((allowHostsRegexp@TypeHint:any):string);
            }

            if (filterMethods !== undefined) {
                localVarQueryParameter['filter.methods'] = ((filterMethods:any):string);
            }

            if (filterMethods@TypeHint !== undefined) {
                localVarQueryParameter['filter.methods@TypeHint'] = ((filterMethods@TypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: any, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postNode.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postNode.');
            }
            const localVarPath = `/{path}/{name}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (:operation !== undefined) {
                localVarQueryParameter[':operation'] = ((:operation:any):string);
            }

            if (deleteAuthorizable !== undefined) {
                localVarQueryParameter['deleteAuthorizable'] = ((deleteAuthorizable:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postNodeRw(path: string, name: string, addMembers?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postNodeRw.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postNodeRw.');
            }
            const localVarPath = `/{path}/{name}.rw.html`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (addMembers !== undefined) {
                localVarQueryParameter['addMembers'] = ((addMembers:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPath(path: string, jcr:primaryType: string, :name: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postPath.');
            }
            // verify required parameter 'jcr:primaryType' is not null or undefined
            if (jcr:primaryType === null || jcr:primaryType === undefined) {
                throw new RequiredError('jcr:primaryType','Required parameter jcr:primaryType was null or undefined when calling postPath.');
            }
            // verify required parameter ':name' is not null or undefined
            if (:name === null || :name === undefined) {
                throw new RequiredError(':name','Required parameter :name was null or undefined when calling postPath.');
            }
            const localVarPath = `/{path}/`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jcr:primaryType !== undefined) {
                localVarQueryParameter['jcr:primaryType'] = ((jcr:primaryType:any):string);
            }

            if (:name !== undefined) {
                localVarQueryParameter[':name'] = ((:name:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postQuery.');
            }
            // verify required parameter 'pLimit' is not null or undefined
            if (pLimit === null || pLimit === undefined) {
                throw new RequiredError('pLimit','Required parameter pLimit was null or undefined when calling postQuery.');
            }
            // verify required parameter '_1property' is not null or undefined
            if (_1property === null || _1property === undefined) {
                throw new RequiredError('_1property','Required parameter _1property was null or undefined when calling postQuery.');
            }
            // verify required parameter '_1propertyValue' is not null or undefined
            if (_1propertyValue === null || _1propertyValue === undefined) {
                throw new RequiredError('_1propertyValue','Required parameter _1propertyValue was null or undefined when calling postQuery.');
            }
            const localVarPath = `/bin/querybuilder.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = ((path:any):string);
            }

            if (pLimit !== undefined) {
                localVarQueryParameter['p.limit'] = ((pLimit:any):string);
            }

            if (_1property !== undefined) {
                localVarQueryParameter['1_property'] = ((_1property:any):string);
            }

            if (_1propertyValue !== undefined) {
                localVarQueryParameter['1_property.value'] = ((_1propertyValue:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'ignoredeactivated' is not null or undefined
            if (ignoredeactivated === null || ignoredeactivated === undefined) {
                throw new RequiredError('ignoredeactivated','Required parameter ignoredeactivated was null or undefined when calling postTreeActivation.');
            }
            // verify required parameter 'onlymodified' is not null or undefined
            if (onlymodified === null || onlymodified === undefined) {
                throw new RequiredError('onlymodified','Required parameter onlymodified was null or undefined when calling postTreeActivation.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postTreeActivation.');
            }
            const localVarPath = `/etc/replication/treeactivation.html`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (ignoredeactivated !== undefined) {
                localVarQueryParameter['ignoredeactivated'] = ((ignoredeactivated:any):string);
            }

            if (onlymodified !== undefined) {
                localVarQueryParameter['onlymodified'] = ((onlymodified:any):string);
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = ((path:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: any, options: RequestOptions): FetchArgs {
            const localVarPath = `/libs/granite/security/post/truststore`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (:operation !== undefined) {
                localVarQueryParameter[':operation'] = ((:operation:any):string);
            }

            if (newPassword !== undefined) {
                localVarQueryParameter['newPassword'] = ((newPassword:any):string);
            }

            if (rePassword !== undefined) {
                localVarQueryParameter['rePassword'] = ((rePassword:any):string);
            }

            if (keyStoreType !== undefined) {
                localVarQueryParameter['keyStoreType'] = ((keyStoreType:any):string);
            }

            if (removeAlias !== undefined) {
                localVarQueryParameter['removeAlias'] = ((removeAlias:any):string);
            }

            if (certificate !== undefined) {
                localVarFormParams.set('certificate', ((certificate:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postTruststorePKCS12(truststoreP12?: any, options: RequestOptions): FetchArgs {
            const localVarPath = `/etc/truststore`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (truststoreP12 !== undefined) {
                localVarFormParams.set('truststore.p12', ((truststoreP12:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type SlingApiType = { 
    deleteAgent(runmode: string, name: string, options?: RequestOptions): Promise<Response>,

    deleteNode(path: string, name: string, options?: RequestOptions): Promise<Response>,

    getAgent(runmode: string, name: string, options?: RequestOptions): Promise<Response>,

    getAgents(runmode: string, options?: RequestOptions): Promise<string>,

    getAuthorizableKeystore(intermediatePath: string, authorizableId: string, options?: RequestOptions): Promise<KeystoreInfo>,

    getKeystore(intermediatePath: string, authorizableId: string, options?: RequestOptions): Promise<any>,

    getNode(path: string, name: string, options?: RequestOptions): Promise<Response>,

    getPackage(group: string, name: string, version: string, options?: RequestOptions): Promise<any>,

    getPackageFilter(group: string, name: string, version: string, options?: RequestOptions): Promise<string>,

    getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options?: RequestOptions): Promise<string>,

    getTruststore(options?: RequestOptions): Promise<any>,

    getTruststoreInfo(options?: RequestOptions): Promise<TruststoreInfo>,

    postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, options?: RequestOptions): Promise<Response>,

    postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: any, pk?: any, keyStore?: any, options?: RequestOptions): Promise<KeystoreInfo>,

    postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, options?: RequestOptions): Promise<string>,

    postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, options?: RequestOptions): Promise<Response>,

    postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, options?: RequestOptions): Promise<Response>,

    postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, options?: RequestOptions): Promise<Response>,

    postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, options?: RequestOptions): Promise<Response>,

    postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, options?: RequestOptions): Promise<Response>,

    postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, options?: RequestOptions): Promise<Response>,

    postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: any, options?: RequestOptions): Promise<Response>,

    postNodeRw(path: string, name: string, addMembers?: string, options?: RequestOptions): Promise<Response>,

    postPath(path: string, jcr:primaryType: string, :name: string, options?: RequestOptions): Promise<Response>,

    postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options?: RequestOptions): Promise<string>,

    postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, options?: RequestOptions): Promise<Response>,

    postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: any, options?: RequestOptions): Promise<string>,

    postTruststorePKCS12(truststoreP12?: any, options?: RequestOptions): Promise<string>,
}

/**
 * SlingApi - factory function to inject configuration 
 * @export
 */
export const SlingApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): SlingApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        deleteAgent(runmode: string, name: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).deleteAgent(runmode, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        deleteNode(path: string, name: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).deleteNode(path, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getAgent(runmode: string, name: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getAgent(runmode, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getAgents(runmode: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getAgents(runmode, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getAuthorizableKeystore(intermediatePath: string, authorizableId: string, options?: RequestOptions = {}): Promise<KeystoreInfo> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getAuthorizableKeystore(intermediatePath, authorizableId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getKeystore(intermediatePath: string, authorizableId: string, options?: RequestOptions = {}): Promise<any> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getKeystore(intermediatePath, authorizableId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getNode(path: string, name: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getNode(path, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getPackage(group: string, name: string, version: string, options?: RequestOptions = {}): Promise<any> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getPackage(group, name, version, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getPackageFilter(group: string, name: string, version: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getPackageFilter(group, name, version, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getQuery(path, pLimit, _1property, _1propertyValue, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getTruststore(options?: RequestOptions = {}): Promise<any> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getTruststore(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getTruststoreInfo(options?: RequestOptions = {}): Promise<TruststoreInfo> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getTruststoreInfo(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postAgent(runmode, name, jcr:contentCq:distribute, jcr:contentCq:distribute@TypeHint, jcr:contentCq:name, jcr:contentCq:template, jcr:contentEnabled, jcr:contentJcr:description, jcr:contentJcr:lastModified, jcr:contentJcr:lastModifiedBy, jcr:contentJcr:mixinTypes, jcr:contentJcr:title, jcr:contentLogLevel, jcr:contentNoStatusUpdate, jcr:contentNoVersioning, jcr:contentProtocolConnectTimeout, jcr:contentProtocolHTTPConnectionClosed, jcr:contentProtocolHTTPExpired, jcr:contentProtocolHTTPHeaders, jcr:contentProtocolHTTPHeaders@TypeHint, jcr:contentProtocolHTTPMethod, jcr:contentProtocolHTTPSRelaxed, jcr:contentProtocolInterface, jcr:contentProtocolSocketTimeout, jcr:contentProtocolVersion, jcr:contentProxyNTLMDomain, jcr:contentProxyNTLMHost, jcr:contentProxyHost, jcr:contentProxyPassword, jcr:contentProxyPort, jcr:contentProxyUser, jcr:contentQueueBatchMaxSize, jcr:contentQueueBatchMode, jcr:contentQueueBatchWaitTime, jcr:contentRetryDelay, jcr:contentReverseReplication, jcr:contentSerializationType, jcr:contentSling:resourceType, jcr:contentSsl, jcr:contentTransportNTLMDomain, jcr:contentTransportNTLMHost, jcr:contentTransportPassword, jcr:contentTransportUri, jcr:contentTransportUser, jcr:contentTriggerDistribute, jcr:contentTriggerModified, jcr:contentTriggerOnOffTime, jcr:contentTriggerReceive, jcr:contentTriggerSpecific, jcr:contentUserId, jcr:primaryType, :operation, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: any, pk?: any, keyStore?: any, options?: RequestOptions = {}): Promise<KeystoreInfo> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postAuthorizableKeystore(intermediatePath, authorizableId, :operation, currentPassword, newPassword, rePassword, keyPassword, keyStorePass, alias, newAlias, removeAlias, certChain, pk, keyStore, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postAuthorizables(authorizableId, intermediatePath, createUser, createGroup, rep:password, profileGivenName, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword, keyStorePassword@TypeHint, serviceRanking, serviceRanking@TypeHint, idpHttpRedirect, idpHttpRedirect@TypeHint, createUser, createUser@TypeHint, defaultRedirectUrl, defaultRedirectUrl@TypeHint, userIDAttribute, userIDAttribute@TypeHint, defaultGroups, defaultGroups@TypeHint, idpCertAlias, idpCertAlias@TypeHint, addGroupMemberships, addGroupMemberships@TypeHint, path, path@TypeHint, synchronizeAttributes, synchronizeAttributes@TypeHint, clockTolerance, clockTolerance@TypeHint, groupMembershipAttribute, groupMembershipAttribute@TypeHint, idpUrl, idpUrl@TypeHint, logoutUrl, logoutUrl@TypeHint, serviceProviderEntityId, serviceProviderEntityId@TypeHint, assertionConsumerServiceURL, assertionConsumerServiceURL@TypeHint, handleLogout, handleLogout@TypeHint, spPrivateKeyAlias, spPrivateKeyAlias@TypeHint, useEncryption, useEncryption@TypeHint, nameIdFormat, nameIdFormat@TypeHint, digestMethod, digestMethod@TypeHint, signatureMethod, signatureMethod@TypeHint, userIntermediatePath, userIntermediatePath@TypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio, orgApacheFelixHttpsNio@TypeHint, orgApacheFelixHttpsKeystore, orgApacheFelixHttpsKeystore@TypeHint, orgApacheFelixHttpsKeystorePassword, orgApacheFelixHttpsKeystorePassword@TypeHint, orgApacheFelixHttpsKeystoreKey, orgApacheFelixHttpsKeystoreKey@TypeHint, orgApacheFelixHttpsKeystoreKeyPassword, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint, orgApacheFelixHttpsTruststore, orgApacheFelixHttpsTruststore@TypeHint, orgApacheFelixHttpsTruststorePassword, orgApacheFelixHttpsTruststorePassword@TypeHint, orgApacheFelixHttpsClientcertificate, orgApacheFelixHttpsClientcertificate@TypeHint, orgApacheFelixHttpsEnable, orgApacheFelixHttpsEnable@TypeHint, orgOsgiServiceHttpPortSecure, orgOsgiServiceHttpPortSecure@TypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheHttpComponentsProxyConfiguration(proxyHost, proxyHost@TypeHint, proxyPort, proxyPort@TypeHint, proxyExceptions, proxyExceptions@TypeHint, proxyEnabled, proxyEnabled@TypeHint, proxyUser, proxyUser@TypeHint, proxyPassword, proxyPassword@TypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheSlingDavExServlet(alias, alias@TypeHint, davCreateAbsoluteUri, davCreateAbsoluteUri@TypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheSlingGetServlet(jsonMaximumresults, jsonMaximumresults@TypeHint, enableHtml, enableHtml@TypeHint, enableTxt, enableTxt@TypeHint, enableXml, enableXml@TypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheSlingReferrerFilter(allowEmpty, allowEmpty@TypeHint, allowHosts, allowHosts@TypeHint, allowHostsRegexp, allowHostsRegexp@TypeHint, filterMethods, filterMethods@TypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: any, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postNode(path, name, :operation, deleteAuthorizable, file, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postNodeRw(path: string, name: string, addMembers?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postNodeRw(path, name, addMembers, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPath(path: string, jcr:primaryType: string, :name: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postPath(path, jcr:primaryType, :name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postQuery(path, pLimit, _1property, _1propertyValue, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postTreeActivation(ignoredeactivated, onlymodified, path, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: any, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postTruststore(:operation, newPassword, rePassword, keyStoreType, removeAlias, certificate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postTruststorePKCS12(truststoreP12?: any, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postTruststorePKCS12(truststoreP12, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

export type ApiTypes = { 
    ConsoleApi: ConsoleApiType,

    CqApi: CqApiType,

    CrxApi: CrxApiType,

    CustomApi: CustomApiType,

    SlingApi: SlingApiType,
 }
