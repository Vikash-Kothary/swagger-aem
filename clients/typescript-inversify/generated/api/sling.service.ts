/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * OpenAPI spec version: 3.2.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Observable } from "rxjs/Observable";
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import IHttpClient from "../IHttpClient";
import { inject, injectable } from "inversify";
import { IAPIConfiguration } from "../IAPIConfiguration";
import { Headers } from "../Headers";
import HttpResponse from "../HttpResponse";

import { KeystoreInfo } from '../model/keystoreInfo';
import { TruststoreInfo } from '../model/truststoreInfo';

import { COLLECTION_FORMATS }  from '../variables';



@injectable()
export class SlingService {
    private basePath: string = 'http://localhost';

    constructor(@inject("IApiHttpClient") private httpClient: IHttpClient,
        @inject("IAPIConfiguration") private APIConfiguration: IAPIConfiguration ) {
        if(this.APIConfiguration.basePath)
            this.basePath = this.APIConfiguration.basePath;
    }

    /**
     * 
     * 
     * @param runmode 
     * @param name 
     
     */
    public deleteAgent(runmode: string, name: string, observe?: 'body', headers?: Headers): Observable<any>;
    public deleteAgent(runmode: string, name: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public deleteAgent(runmode: string, name: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!runmode){
            throw new Error('Required parameter runmode was null or undefined when calling deleteAgent.');
        }

        if (!name){
            throw new Error('Required parameter name was null or undefined when calling deleteAgent.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.delete(`${this.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}/${encodeURIComponent(String(name))}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param path 
     * @param name 
     
     */
    public deleteNode(path: string, name: string, observe?: 'body', headers?: Headers): Observable<any>;
    public deleteNode(path: string, name: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public deleteNode(path: string, name: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!path){
            throw new Error('Required parameter path was null or undefined when calling deleteNode.');
        }

        if (!name){
            throw new Error('Required parameter name was null or undefined when calling deleteNode.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.delete(`${this.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param runmode 
     * @param name 
     
     */
    public getAgent(runmode: string, name: string, observe?: 'body', headers?: Headers): Observable<any>;
    public getAgent(runmode: string, name: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public getAgent(runmode: string, name: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!runmode){
            throw new Error('Required parameter runmode was null or undefined when calling getAgent.');
        }

        if (!name){
            throw new Error('Required parameter name was null or undefined when calling getAgent.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.get(`${this.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}/${encodeURIComponent(String(name))}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param runmode 
     
     */
    public getAgents(runmode: string, observe?: 'body', headers?: Headers): Observable<string>;
    public getAgents(runmode: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<string>>;
    public getAgents(runmode: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!runmode){
            throw new Error('Required parameter runmode was null or undefined when calling getAgents.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<string>> = this.httpClient.get(`${this.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}.-1.json`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <string>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param intermediatePath 
     * @param authorizableId 
     
     */
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, observe?: 'body', headers?: Headers): Observable<KeystoreInfo>;
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<KeystoreInfo>>;
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!intermediatePath){
            throw new Error('Required parameter intermediatePath was null or undefined when calling getAuthorizableKeystore.');
        }

        if (!authorizableId){
            throw new Error('Required parameter authorizableId was null or undefined when calling getAuthorizableKeystore.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'text/plain';

        const response: Observable<HttpResponse<KeystoreInfo>> = this.httpClient.get(`${this.basePath}/${encodeURIComponent(String(intermediatePath))}/${encodeURIComponent(String(authorizableId))}.ks.json`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <KeystoreInfo>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param intermediatePath 
     * @param authorizableId 
     
     */
    public getKeystore(intermediatePath: string, authorizableId: string, observe?: 'body', headers?: Headers): Observable<Blob>;
    public getKeystore(intermediatePath: string, authorizableId: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Blob>>;
    public getKeystore(intermediatePath: string, authorizableId: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!intermediatePath){
            throw new Error('Required parameter intermediatePath was null or undefined when calling getKeystore.');
        }

        if (!authorizableId){
            throw new Error('Required parameter authorizableId was null or undefined when calling getKeystore.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/octet-stream';

        const response: Observable<HttpResponse<Blob>> = this.httpClient.get(`${this.basePath}/${encodeURIComponent(String(intermediatePath))}/${encodeURIComponent(String(authorizableId))}/keystore/store.p12`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Blob>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param path 
     * @param name 
     
     */
    public getNode(path: string, name: string, observe?: 'body', headers?: Headers): Observable<any>;
    public getNode(path: string, name: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public getNode(path: string, name: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!path){
            throw new Error('Required parameter path was null or undefined when calling getNode.');
        }

        if (!name){
            throw new Error('Required parameter name was null or undefined when calling getNode.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.get(`${this.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param group 
     * @param name 
     * @param version 
     
     */
    public getPackage(group: string, name: string, version: string, observe?: 'body', headers?: Headers): Observable<Blob>;
    public getPackage(group: string, name: string, version: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Blob>>;
    public getPackage(group: string, name: string, version: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!group){
            throw new Error('Required parameter group was null or undefined when calling getPackage.');
        }

        if (!name){
            throw new Error('Required parameter name was null or undefined when calling getPackage.');
        }

        if (!version){
            throw new Error('Required parameter version was null or undefined when calling getPackage.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/octet-stream';

        const response: Observable<HttpResponse<Blob>> = this.httpClient.get(`${this.basePath}/etc/packages/${encodeURIComponent(String(group))}/${encodeURIComponent(String(name))}-${encodeURIComponent(String(version))}.zip`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Blob>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param group 
     * @param name 
     * @param version 
     
     */
    public getPackageFilter(group: string, name: string, version: string, observe?: 'body', headers?: Headers): Observable<string>;
    public getPackageFilter(group: string, name: string, version: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<string>>;
    public getPackageFilter(group: string, name: string, version: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!group){
            throw new Error('Required parameter group was null or undefined when calling getPackageFilter.');
        }

        if (!name){
            throw new Error('Required parameter name was null or undefined when calling getPackageFilter.');
        }

        if (!version){
            throw new Error('Required parameter version was null or undefined when calling getPackageFilter.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<string>> = this.httpClient.get(`${this.basePath}/etc/packages/${encodeURIComponent(String(group))}/${encodeURIComponent(String(name))}-${encodeURIComponent(String(version))}.zip/jcr:content/vlt:definition/filter.tidy.2.json`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <string>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     
     */
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'body', headers?: Headers): Observable<string>;
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<string>>;
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!path){
            throw new Error('Required parameter path was null or undefined when calling getQuery.');
        }

        if (!pLimit){
            throw new Error('Required parameter pLimit was null or undefined when calling getQuery.');
        }

        if (!_1property){
            throw new Error('Required parameter _1property was null or undefined when calling getQuery.');
        }

        if (!_1propertyValue){
            throw new Error('Required parameter _1propertyValue was null or undefined when calling getQuery.');
        }

        let queryParameters: string[] = [];
        if (path !== undefined) {
            queryParameters.push("path="+encodeURIComponent(String(path)));
        }
        if (pLimit !== undefined) {
            queryParameters.push("pLimit="+encodeURIComponent(String(pLimit)));
        }
        if (_1property !== undefined) {
            queryParameters.push("_1property="+encodeURIComponent(String(_1property)));
        }
        if (_1propertyValue !== undefined) {
            queryParameters.push("_1propertyValue="+encodeURIComponent(String(_1propertyValue)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<string>> = this.httpClient.get(`${this.basePath}/bin/querybuilder.json?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <string>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     
     */
    public getTruststore(observe?: 'body', headers?: Headers): Observable<Blob>;
    public getTruststore(observe?: 'response', headers?: Headers): Observable<HttpResponse<Blob>>;
    public getTruststore(observe: any = 'body', headers: Headers = {}): Observable<any> {
        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/octet-stream';

        const response: Observable<HttpResponse<Blob>> = this.httpClient.get(`${this.basePath}/etc/truststore/truststore.p12`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Blob>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     
     */
    public getTruststoreInfo(observe?: 'body', headers?: Headers): Observable<TruststoreInfo>;
    public getTruststoreInfo(observe?: 'response', headers?: Headers): Observable<HttpResponse<TruststoreInfo>>;
    public getTruststoreInfo(observe: any = 'body', headers: Headers = {}): Observable<any> {
        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<TruststoreInfo>> = this.httpClient.get(`${this.basePath}/libs/granite/security/truststore.json`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <TruststoreInfo>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param runmode 
     * @param name 
     * @param jcr:contentCq:distribute 
     * @param jcr:contentCq:distribute@TypeHint 
     * @param jcr:contentCq:name 
     * @param jcr:contentCq:template 
     * @param jcr:contentEnabled 
     * @param jcr:contentJcr:description 
     * @param jcr:contentJcr:lastModified 
     * @param jcr:contentJcr:lastModifiedBy 
     * @param jcr:contentJcr:mixinTypes 
     * @param jcr:contentJcr:title 
     * @param jcr:contentLogLevel 
     * @param jcr:contentNoStatusUpdate 
     * @param jcr:contentNoVersioning 
     * @param jcr:contentProtocolConnectTimeout 
     * @param jcr:contentProtocolHTTPConnectionClosed 
     * @param jcr:contentProtocolHTTPExpired 
     * @param jcr:contentProtocolHTTPHeaders 
     * @param jcr:contentProtocolHTTPHeaders@TypeHint 
     * @param jcr:contentProtocolHTTPMethod 
     * @param jcr:contentProtocolHTTPSRelaxed 
     * @param jcr:contentProtocolInterface 
     * @param jcr:contentProtocolSocketTimeout 
     * @param jcr:contentProtocolVersion 
     * @param jcr:contentProxyNTLMDomain 
     * @param jcr:contentProxyNTLMHost 
     * @param jcr:contentProxyHost 
     * @param jcr:contentProxyPassword 
     * @param jcr:contentProxyPort 
     * @param jcr:contentProxyUser 
     * @param jcr:contentQueueBatchMaxSize 
     * @param jcr:contentQueueBatchMode 
     * @param jcr:contentQueueBatchWaitTime 
     * @param jcr:contentRetryDelay 
     * @param jcr:contentReverseReplication 
     * @param jcr:contentSerializationType 
     * @param jcr:contentSling:resourceType 
     * @param jcr:contentSsl 
     * @param jcr:contentTransportNTLMDomain 
     * @param jcr:contentTransportNTLMHost 
     * @param jcr:contentTransportPassword 
     * @param jcr:contentTransportUri 
     * @param jcr:contentTransportUser 
     * @param jcr:contentTriggerDistribute 
     * @param jcr:contentTriggerModified 
     * @param jcr:contentTriggerOnOffTime 
     * @param jcr:contentTriggerReceive 
     * @param jcr:contentTriggerSpecific 
     * @param jcr:contentUserId 
     * @param jcr:primaryType 
     * @param :operation 
     
     */
    public postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postAgent(runmode: string, name: string, jcr:contentCq:distribute?: boolean, jcr:contentCq:distribute@TypeHint?: string, jcr:contentCq:name?: string, jcr:contentCq:template?: string, jcr:contentEnabled?: boolean, jcr:contentJcr:description?: string, jcr:contentJcr:lastModified?: string, jcr:contentJcr:lastModifiedBy?: string, jcr:contentJcr:mixinTypes?: string, jcr:contentJcr:title?: string, jcr:contentLogLevel?: string, jcr:contentNoStatusUpdate?: boolean, jcr:contentNoVersioning?: boolean, jcr:contentProtocolConnectTimeout?: number, jcr:contentProtocolHTTPConnectionClosed?: boolean, jcr:contentProtocolHTTPExpired?: string, jcr:contentProtocolHTTPHeaders?: Array<string>, jcr:contentProtocolHTTPHeaders@TypeHint?: string, jcr:contentProtocolHTTPMethod?: string, jcr:contentProtocolHTTPSRelaxed?: boolean, jcr:contentProtocolInterface?: string, jcr:contentProtocolSocketTimeout?: number, jcr:contentProtocolVersion?: string, jcr:contentProxyNTLMDomain?: string, jcr:contentProxyNTLMHost?: string, jcr:contentProxyHost?: string, jcr:contentProxyPassword?: string, jcr:contentProxyPort?: number, jcr:contentProxyUser?: string, jcr:contentQueueBatchMaxSize?: number, jcr:contentQueueBatchMode?: string, jcr:contentQueueBatchWaitTime?: number, jcr:contentRetryDelay?: string, jcr:contentReverseReplication?: boolean, jcr:contentSerializationType?: string, jcr:contentSling:resourceType?: string, jcr:contentSsl?: string, jcr:contentTransportNTLMDomain?: string, jcr:contentTransportNTLMHost?: string, jcr:contentTransportPassword?: string, jcr:contentTransportUri?: string, jcr:contentTransportUser?: string, jcr:contentTriggerDistribute?: boolean, jcr:contentTriggerModified?: boolean, jcr:contentTriggerOnOffTime?: boolean, jcr:contentTriggerReceive?: boolean, jcr:contentTriggerSpecific?: boolean, jcr:contentUserId?: string, jcr:primaryType?: string, :operation?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!runmode){
            throw new Error('Required parameter runmode was null or undefined when calling postAgent.');
        }

        if (!name){
            throw new Error('Required parameter name was null or undefined when calling postAgent.');
        }

        let queryParameters: string[] = [];
        if (jcr:contentCq:distribute !== undefined) {
            queryParameters.push("jcr:contentCq:distribute="+encodeURIComponent(String(jcr:contentCq:distribute)));
        }
        if (jcr:contentCq:distribute@TypeHint !== undefined) {
            queryParameters.push("jcr:contentCq:distribute@TypeHint="+encodeURIComponent(String(jcr:contentCq:distribute@TypeHint)));
        }
        if (jcr:contentCq:name !== undefined) {
            queryParameters.push("jcr:contentCq:name="+encodeURIComponent(String(jcr:contentCq:name)));
        }
        if (jcr:contentCq:template !== undefined) {
            queryParameters.push("jcr:contentCq:template="+encodeURIComponent(String(jcr:contentCq:template)));
        }
        if (jcr:contentEnabled !== undefined) {
            queryParameters.push("jcr:contentEnabled="+encodeURIComponent(String(jcr:contentEnabled)));
        }
        if (jcr:contentJcr:description !== undefined) {
            queryParameters.push("jcr:contentJcr:description="+encodeURIComponent(String(jcr:contentJcr:description)));
        }
        if (jcr:contentJcr:lastModified !== undefined) {
            queryParameters.push("jcr:contentJcr:lastModified="+encodeURIComponent(String(jcr:contentJcr:lastModified)));
        }
        if (jcr:contentJcr:lastModifiedBy !== undefined) {
            queryParameters.push("jcr:contentJcr:lastModifiedBy="+encodeURIComponent(String(jcr:contentJcr:lastModifiedBy)));
        }
        if (jcr:contentJcr:mixinTypes !== undefined) {
            queryParameters.push("jcr:contentJcr:mixinTypes="+encodeURIComponent(String(jcr:contentJcr:mixinTypes)));
        }
        if (jcr:contentJcr:title !== undefined) {
            queryParameters.push("jcr:contentJcr:title="+encodeURIComponent(String(jcr:contentJcr:title)));
        }
        if (jcr:contentLogLevel !== undefined) {
            queryParameters.push("jcr:contentLogLevel="+encodeURIComponent(String(jcr:contentLogLevel)));
        }
        if (jcr:contentNoStatusUpdate !== undefined) {
            queryParameters.push("jcr:contentNoStatusUpdate="+encodeURIComponent(String(jcr:contentNoStatusUpdate)));
        }
        if (jcr:contentNoVersioning !== undefined) {
            queryParameters.push("jcr:contentNoVersioning="+encodeURIComponent(String(jcr:contentNoVersioning)));
        }
        if (jcr:contentProtocolConnectTimeout !== undefined) {
            queryParameters.push("jcr:contentProtocolConnectTimeout="+encodeURIComponent(String(jcr:contentProtocolConnectTimeout)));
        }
        if (jcr:contentProtocolHTTPConnectionClosed !== undefined) {
            queryParameters.push("jcr:contentProtocolHTTPConnectionClosed="+encodeURIComponent(String(jcr:contentProtocolHTTPConnectionClosed)));
        }
        if (jcr:contentProtocolHTTPExpired !== undefined) {
            queryParameters.push("jcr:contentProtocolHTTPExpired="+encodeURIComponent(String(jcr:contentProtocolHTTPExpired)));
        }
        if (jcr:contentProtocolHTTPHeaders) {
            jcr:contentProtocolHTTPHeaders.forEach((element) => {
                queryParameters.push("jcr:contentProtocolHTTPHeaders="+encodeURIComponent(String(jcr:contentProtocolHTTPHeaders)));
            })
        }
        if (jcr:contentProtocolHTTPHeaders@TypeHint !== undefined) {
            queryParameters.push("jcr:contentProtocolHTTPHeaders@TypeHint="+encodeURIComponent(String(jcr:contentProtocolHTTPHeaders@TypeHint)));
        }
        if (jcr:contentProtocolHTTPMethod !== undefined) {
            queryParameters.push("jcr:contentProtocolHTTPMethod="+encodeURIComponent(String(jcr:contentProtocolHTTPMethod)));
        }
        if (jcr:contentProtocolHTTPSRelaxed !== undefined) {
            queryParameters.push("jcr:contentProtocolHTTPSRelaxed="+encodeURIComponent(String(jcr:contentProtocolHTTPSRelaxed)));
        }
        if (jcr:contentProtocolInterface !== undefined) {
            queryParameters.push("jcr:contentProtocolInterface="+encodeURIComponent(String(jcr:contentProtocolInterface)));
        }
        if (jcr:contentProtocolSocketTimeout !== undefined) {
            queryParameters.push("jcr:contentProtocolSocketTimeout="+encodeURIComponent(String(jcr:contentProtocolSocketTimeout)));
        }
        if (jcr:contentProtocolVersion !== undefined) {
            queryParameters.push("jcr:contentProtocolVersion="+encodeURIComponent(String(jcr:contentProtocolVersion)));
        }
        if (jcr:contentProxyNTLMDomain !== undefined) {
            queryParameters.push("jcr:contentProxyNTLMDomain="+encodeURIComponent(String(jcr:contentProxyNTLMDomain)));
        }
        if (jcr:contentProxyNTLMHost !== undefined) {
            queryParameters.push("jcr:contentProxyNTLMHost="+encodeURIComponent(String(jcr:contentProxyNTLMHost)));
        }
        if (jcr:contentProxyHost !== undefined) {
            queryParameters.push("jcr:contentProxyHost="+encodeURIComponent(String(jcr:contentProxyHost)));
        }
        if (jcr:contentProxyPassword !== undefined) {
            queryParameters.push("jcr:contentProxyPassword="+encodeURIComponent(String(jcr:contentProxyPassword)));
        }
        if (jcr:contentProxyPort !== undefined) {
            queryParameters.push("jcr:contentProxyPort="+encodeURIComponent(String(jcr:contentProxyPort)));
        }
        if (jcr:contentProxyUser !== undefined) {
            queryParameters.push("jcr:contentProxyUser="+encodeURIComponent(String(jcr:contentProxyUser)));
        }
        if (jcr:contentQueueBatchMaxSize !== undefined) {
            queryParameters.push("jcr:contentQueueBatchMaxSize="+encodeURIComponent(String(jcr:contentQueueBatchMaxSize)));
        }
        if (jcr:contentQueueBatchMode !== undefined) {
            queryParameters.push("jcr:contentQueueBatchMode="+encodeURIComponent(String(jcr:contentQueueBatchMode)));
        }
        if (jcr:contentQueueBatchWaitTime !== undefined) {
            queryParameters.push("jcr:contentQueueBatchWaitTime="+encodeURIComponent(String(jcr:contentQueueBatchWaitTime)));
        }
        if (jcr:contentRetryDelay !== undefined) {
            queryParameters.push("jcr:contentRetryDelay="+encodeURIComponent(String(jcr:contentRetryDelay)));
        }
        if (jcr:contentReverseReplication !== undefined) {
            queryParameters.push("jcr:contentReverseReplication="+encodeURIComponent(String(jcr:contentReverseReplication)));
        }
        if (jcr:contentSerializationType !== undefined) {
            queryParameters.push("jcr:contentSerializationType="+encodeURIComponent(String(jcr:contentSerializationType)));
        }
        if (jcr:contentSling:resourceType !== undefined) {
            queryParameters.push("jcr:contentSling:resourceType="+encodeURIComponent(String(jcr:contentSling:resourceType)));
        }
        if (jcr:contentSsl !== undefined) {
            queryParameters.push("jcr:contentSsl="+encodeURIComponent(String(jcr:contentSsl)));
        }
        if (jcr:contentTransportNTLMDomain !== undefined) {
            queryParameters.push("jcr:contentTransportNTLMDomain="+encodeURIComponent(String(jcr:contentTransportNTLMDomain)));
        }
        if (jcr:contentTransportNTLMHost !== undefined) {
            queryParameters.push("jcr:contentTransportNTLMHost="+encodeURIComponent(String(jcr:contentTransportNTLMHost)));
        }
        if (jcr:contentTransportPassword !== undefined) {
            queryParameters.push("jcr:contentTransportPassword="+encodeURIComponent(String(jcr:contentTransportPassword)));
        }
        if (jcr:contentTransportUri !== undefined) {
            queryParameters.push("jcr:contentTransportUri="+encodeURIComponent(String(jcr:contentTransportUri)));
        }
        if (jcr:contentTransportUser !== undefined) {
            queryParameters.push("jcr:contentTransportUser="+encodeURIComponent(String(jcr:contentTransportUser)));
        }
        if (jcr:contentTriggerDistribute !== undefined) {
            queryParameters.push("jcr:contentTriggerDistribute="+encodeURIComponent(String(jcr:contentTriggerDistribute)));
        }
        if (jcr:contentTriggerModified !== undefined) {
            queryParameters.push("jcr:contentTriggerModified="+encodeURIComponent(String(jcr:contentTriggerModified)));
        }
        if (jcr:contentTriggerOnOffTime !== undefined) {
            queryParameters.push("jcr:contentTriggerOnOffTime="+encodeURIComponent(String(jcr:contentTriggerOnOffTime)));
        }
        if (jcr:contentTriggerReceive !== undefined) {
            queryParameters.push("jcr:contentTriggerReceive="+encodeURIComponent(String(jcr:contentTriggerReceive)));
        }
        if (jcr:contentTriggerSpecific !== undefined) {
            queryParameters.push("jcr:contentTriggerSpecific="+encodeURIComponent(String(jcr:contentTriggerSpecific)));
        }
        if (jcr:contentUserId !== undefined) {
            queryParameters.push("jcr:contentUserId="+encodeURIComponent(String(jcr:contentUserId)));
        }
        if (jcr:primaryType !== undefined) {
            queryParameters.push("jcr:primaryType="+encodeURIComponent(String(jcr:primaryType)));
        }
        if (:operation !== undefined) {
            queryParameters.push(":operation="+encodeURIComponent(String(:operation)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}/${encodeURIComponent(String(name))}?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param intermediatePath 
     * @param authorizableId 
     * @param :operation 
     * @param currentPassword 
     * @param newPassword 
     * @param rePassword 
     * @param keyPassword 
     * @param keyStorePass 
     * @param alias 
     * @param newAlias 
     * @param removeAlias 
     * @param certChain 
     * @param pk 
     * @param keyStore 
     
     */
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Blob, pk?: Blob, keyStore?: Blob, observe?: 'body', headers?: Headers): Observable<KeystoreInfo>;
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Blob, pk?: Blob, keyStore?: Blob, observe?: 'response', headers?: Headers): Observable<HttpResponse<KeystoreInfo>>;
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, :operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Blob, pk?: Blob, keyStore?: Blob, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!intermediatePath){
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizableKeystore.');
        }

        if (!authorizableId){
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizableKeystore.');
        }

        let queryParameters: string[] = [];
        if (:operation !== undefined) {
            queryParameters.push(":operation="+encodeURIComponent(String(:operation)));
        }
        if (currentPassword !== undefined) {
            queryParameters.push("currentPassword="+encodeURIComponent(String(currentPassword)));
        }
        if (newPassword !== undefined) {
            queryParameters.push("newPassword="+encodeURIComponent(String(newPassword)));
        }
        if (rePassword !== undefined) {
            queryParameters.push("rePassword="+encodeURIComponent(String(rePassword)));
        }
        if (keyPassword !== undefined) {
            queryParameters.push("keyPassword="+encodeURIComponent(String(keyPassword)));
        }
        if (keyStorePass !== undefined) {
            queryParameters.push("keyStorePass="+encodeURIComponent(String(keyStorePass)));
        }
        if (alias !== undefined) {
            queryParameters.push("alias="+encodeURIComponent(String(alias)));
        }
        if (newAlias !== undefined) {
            queryParameters.push("newAlias="+encodeURIComponent(String(newAlias)));
        }
        if (removeAlias !== undefined) {
            queryParameters.push("removeAlias="+encodeURIComponent(String(removeAlias)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'text/plain';

        let formData: FormData = new FormData();
        headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';
        if (certChain !== undefined) {
            formData.append('cert-chain', <any>certChain);
        }
        if (pk !== undefined) {
            formData.append('pk', <any>pk);
        }
        if (keyStore !== undefined) {
            formData.append('keyStore', <any>keyStore);
        }

        const response: Observable<HttpResponse<KeystoreInfo>> = this.httpClient.post(`${this.basePath}/${encodeURIComponent(String(intermediatePath))}/${encodeURIComponent(String(authorizableId))}.ks.html?${queryParameters.join('&')}`, body, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <KeystoreInfo>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param authorizableId 
     * @param intermediatePath 
     * @param createUser 
     * @param createGroup 
     * @param rep:password 
     * @param profileGivenName 
     
     */
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, observe?: 'body', headers?: Headers): Observable<string>;
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<string>>;
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, rep:password?: string, profileGivenName?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!authorizableId){
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizables.');
        }

        if (!intermediatePath){
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizables.');
        }

        let queryParameters: string[] = [];
        if (authorizableId !== undefined) {
            queryParameters.push("authorizableId="+encodeURIComponent(String(authorizableId)));
        }
        if (intermediatePath !== undefined) {
            queryParameters.push("intermediatePath="+encodeURIComponent(String(intermediatePath)));
        }
        if (createUser !== undefined) {
            queryParameters.push("createUser="+encodeURIComponent(String(createUser)));
        }
        if (createGroup !== undefined) {
            queryParameters.push("createGroup="+encodeURIComponent(String(createGroup)));
        }
        if (rep:password !== undefined) {
            queryParameters.push("rep:password="+encodeURIComponent(String(rep:password)));
        }
        if (profileGivenName !== undefined) {
            queryParameters.push("profileGivenName="+encodeURIComponent(String(profileGivenName)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'text/html';

        const response: Observable<HttpResponse<string>> = this.httpClient.post(`${this.basePath}/libs/granite/security/post/authorizables?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <string>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param keyStorePassword 
     * @param keyStorePassword@TypeHint 
     * @param serviceRanking 
     * @param serviceRanking@TypeHint 
     * @param idpHttpRedirect 
     * @param idpHttpRedirect@TypeHint 
     * @param createUser 
     * @param createUser@TypeHint 
     * @param defaultRedirectUrl 
     * @param defaultRedirectUrl@TypeHint 
     * @param userIDAttribute 
     * @param userIDAttribute@TypeHint 
     * @param defaultGroups 
     * @param defaultGroups@TypeHint 
     * @param idpCertAlias 
     * @param idpCertAlias@TypeHint 
     * @param addGroupMemberships 
     * @param addGroupMemberships@TypeHint 
     * @param path 
     * @param path@TypeHint 
     * @param synchronizeAttributes 
     * @param synchronizeAttributes@TypeHint 
     * @param clockTolerance 
     * @param clockTolerance@TypeHint 
     * @param groupMembershipAttribute 
     * @param groupMembershipAttribute@TypeHint 
     * @param idpUrl 
     * @param idpUrl@TypeHint 
     * @param logoutUrl 
     * @param logoutUrl@TypeHint 
     * @param serviceProviderEntityId 
     * @param serviceProviderEntityId@TypeHint 
     * @param assertionConsumerServiceURL 
     * @param assertionConsumerServiceURL@TypeHint 
     * @param handleLogout 
     * @param handleLogout@TypeHint 
     * @param spPrivateKeyAlias 
     * @param spPrivateKeyAlias@TypeHint 
     * @param useEncryption 
     * @param useEncryption@TypeHint 
     * @param nameIdFormat 
     * @param nameIdFormat@TypeHint 
     * @param digestMethod 
     * @param digestMethod@TypeHint 
     * @param signatureMethod 
     * @param signatureMethod@TypeHint 
     * @param userIntermediatePath 
     * @param userIntermediatePath@TypeHint 
     
     */
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePassword@TypeHint?: string, serviceRanking?: number, serviceRanking@TypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirect@TypeHint?: string, createUser?: boolean, createUser@TypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrl@TypeHint?: string, userIDAttribute?: string, userIDAttribute@TypeHint?: string, defaultGroups?: Array<string>, defaultGroups@TypeHint?: string, idpCertAlias?: string, idpCertAlias@TypeHint?: string, addGroupMemberships?: boolean, addGroupMemberships@TypeHint?: string, path?: Array<string>, path@TypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributes@TypeHint?: string, clockTolerance?: number, clockTolerance@TypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttribute@TypeHint?: string, idpUrl?: string, idpUrl@TypeHint?: string, logoutUrl?: string, logoutUrl@TypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityId@TypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURL@TypeHint?: string, handleLogout?: boolean, handleLogout@TypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAlias@TypeHint?: string, useEncryption?: boolean, useEncryption@TypeHint?: string, nameIdFormat?: string, nameIdFormat@TypeHint?: string, digestMethod?: string, digestMethod@TypeHint?: string, signatureMethod?: string, signatureMethod@TypeHint?: string, userIntermediatePath?: string, userIntermediatePath@TypeHint?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (keyStorePassword !== undefined) {
            queryParameters.push("keyStorePassword="+encodeURIComponent(String(keyStorePassword)));
        }
        if (keyStorePassword@TypeHint !== undefined) {
            queryParameters.push("keyStorePassword@TypeHint="+encodeURIComponent(String(keyStorePassword@TypeHint)));
        }
        if (serviceRanking !== undefined) {
            queryParameters.push("serviceRanking="+encodeURIComponent(String(serviceRanking)));
        }
        if (serviceRanking@TypeHint !== undefined) {
            queryParameters.push("serviceRanking@TypeHint="+encodeURIComponent(String(serviceRanking@TypeHint)));
        }
        if (idpHttpRedirect !== undefined) {
            queryParameters.push("idpHttpRedirect="+encodeURIComponent(String(idpHttpRedirect)));
        }
        if (idpHttpRedirect@TypeHint !== undefined) {
            queryParameters.push("idpHttpRedirect@TypeHint="+encodeURIComponent(String(idpHttpRedirect@TypeHint)));
        }
        if (createUser !== undefined) {
            queryParameters.push("createUser="+encodeURIComponent(String(createUser)));
        }
        if (createUser@TypeHint !== undefined) {
            queryParameters.push("createUser@TypeHint="+encodeURIComponent(String(createUser@TypeHint)));
        }
        if (defaultRedirectUrl !== undefined) {
            queryParameters.push("defaultRedirectUrl="+encodeURIComponent(String(defaultRedirectUrl)));
        }
        if (defaultRedirectUrl@TypeHint !== undefined) {
            queryParameters.push("defaultRedirectUrl@TypeHint="+encodeURIComponent(String(defaultRedirectUrl@TypeHint)));
        }
        if (userIDAttribute !== undefined) {
            queryParameters.push("userIDAttribute="+encodeURIComponent(String(userIDAttribute)));
        }
        if (userIDAttribute@TypeHint !== undefined) {
            queryParameters.push("userIDAttribute@TypeHint="+encodeURIComponent(String(userIDAttribute@TypeHint)));
        }
        if (defaultGroups) {
            defaultGroups.forEach((element) => {
                queryParameters.push("defaultGroups="+encodeURIComponent(String(defaultGroups)));
            })
        }
        if (defaultGroups@TypeHint !== undefined) {
            queryParameters.push("defaultGroups@TypeHint="+encodeURIComponent(String(defaultGroups@TypeHint)));
        }
        if (idpCertAlias !== undefined) {
            queryParameters.push("idpCertAlias="+encodeURIComponent(String(idpCertAlias)));
        }
        if (idpCertAlias@TypeHint !== undefined) {
            queryParameters.push("idpCertAlias@TypeHint="+encodeURIComponent(String(idpCertAlias@TypeHint)));
        }
        if (addGroupMemberships !== undefined) {
            queryParameters.push("addGroupMemberships="+encodeURIComponent(String(addGroupMemberships)));
        }
        if (addGroupMemberships@TypeHint !== undefined) {
            queryParameters.push("addGroupMemberships@TypeHint="+encodeURIComponent(String(addGroupMemberships@TypeHint)));
        }
        if (path) {
            path.forEach((element) => {
                queryParameters.push("path="+encodeURIComponent(String(path)));
            })
        }
        if (path@TypeHint !== undefined) {
            queryParameters.push("path@TypeHint="+encodeURIComponent(String(path@TypeHint)));
        }
        if (synchronizeAttributes) {
            synchronizeAttributes.forEach((element) => {
                queryParameters.push("synchronizeAttributes="+encodeURIComponent(String(synchronizeAttributes)));
            })
        }
        if (synchronizeAttributes@TypeHint !== undefined) {
            queryParameters.push("synchronizeAttributes@TypeHint="+encodeURIComponent(String(synchronizeAttributes@TypeHint)));
        }
        if (clockTolerance !== undefined) {
            queryParameters.push("clockTolerance="+encodeURIComponent(String(clockTolerance)));
        }
        if (clockTolerance@TypeHint !== undefined) {
            queryParameters.push("clockTolerance@TypeHint="+encodeURIComponent(String(clockTolerance@TypeHint)));
        }
        if (groupMembershipAttribute !== undefined) {
            queryParameters.push("groupMembershipAttribute="+encodeURIComponent(String(groupMembershipAttribute)));
        }
        if (groupMembershipAttribute@TypeHint !== undefined) {
            queryParameters.push("groupMembershipAttribute@TypeHint="+encodeURIComponent(String(groupMembershipAttribute@TypeHint)));
        }
        if (idpUrl !== undefined) {
            queryParameters.push("idpUrl="+encodeURIComponent(String(idpUrl)));
        }
        if (idpUrl@TypeHint !== undefined) {
            queryParameters.push("idpUrl@TypeHint="+encodeURIComponent(String(idpUrl@TypeHint)));
        }
        if (logoutUrl !== undefined) {
            queryParameters.push("logoutUrl="+encodeURIComponent(String(logoutUrl)));
        }
        if (logoutUrl@TypeHint !== undefined) {
            queryParameters.push("logoutUrl@TypeHint="+encodeURIComponent(String(logoutUrl@TypeHint)));
        }
        if (serviceProviderEntityId !== undefined) {
            queryParameters.push("serviceProviderEntityId="+encodeURIComponent(String(serviceProviderEntityId)));
        }
        if (serviceProviderEntityId@TypeHint !== undefined) {
            queryParameters.push("serviceProviderEntityId@TypeHint="+encodeURIComponent(String(serviceProviderEntityId@TypeHint)));
        }
        if (assertionConsumerServiceURL !== undefined) {
            queryParameters.push("assertionConsumerServiceURL="+encodeURIComponent(String(assertionConsumerServiceURL)));
        }
        if (assertionConsumerServiceURL@TypeHint !== undefined) {
            queryParameters.push("assertionConsumerServiceURL@TypeHint="+encodeURIComponent(String(assertionConsumerServiceURL@TypeHint)));
        }
        if (handleLogout !== undefined) {
            queryParameters.push("handleLogout="+encodeURIComponent(String(handleLogout)));
        }
        if (handleLogout@TypeHint !== undefined) {
            queryParameters.push("handleLogout@TypeHint="+encodeURIComponent(String(handleLogout@TypeHint)));
        }
        if (spPrivateKeyAlias !== undefined) {
            queryParameters.push("spPrivateKeyAlias="+encodeURIComponent(String(spPrivateKeyAlias)));
        }
        if (spPrivateKeyAlias@TypeHint !== undefined) {
            queryParameters.push("spPrivateKeyAlias@TypeHint="+encodeURIComponent(String(spPrivateKeyAlias@TypeHint)));
        }
        if (useEncryption !== undefined) {
            queryParameters.push("useEncryption="+encodeURIComponent(String(useEncryption)));
        }
        if (useEncryption@TypeHint !== undefined) {
            queryParameters.push("useEncryption@TypeHint="+encodeURIComponent(String(useEncryption@TypeHint)));
        }
        if (nameIdFormat !== undefined) {
            queryParameters.push("nameIdFormat="+encodeURIComponent(String(nameIdFormat)));
        }
        if (nameIdFormat@TypeHint !== undefined) {
            queryParameters.push("nameIdFormat@TypeHint="+encodeURIComponent(String(nameIdFormat@TypeHint)));
        }
        if (digestMethod !== undefined) {
            queryParameters.push("digestMethod="+encodeURIComponent(String(digestMethod)));
        }
        if (digestMethod@TypeHint !== undefined) {
            queryParameters.push("digestMethod@TypeHint="+encodeURIComponent(String(digestMethod@TypeHint)));
        }
        if (signatureMethod !== undefined) {
            queryParameters.push("signatureMethod="+encodeURIComponent(String(signatureMethod)));
        }
        if (signatureMethod@TypeHint !== undefined) {
            queryParameters.push("signatureMethod@TypeHint="+encodeURIComponent(String(signatureMethod@TypeHint)));
        }
        if (userIntermediatePath !== undefined) {
            queryParameters.push("userIntermediatePath="+encodeURIComponent(String(userIntermediatePath)));
        }
        if (userIntermediatePath@TypeHint !== undefined) {
            queryParameters.push("userIntermediatePath@TypeHint="+encodeURIComponent(String(userIntermediatePath@TypeHint)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param orgApacheFelixHttpsNio 
     * @param orgApacheFelixHttpsNio@TypeHint 
     * @param orgApacheFelixHttpsKeystore 
     * @param orgApacheFelixHttpsKeystore@TypeHint 
     * @param orgApacheFelixHttpsKeystorePassword 
     * @param orgApacheFelixHttpsKeystorePassword@TypeHint 
     * @param orgApacheFelixHttpsKeystoreKey 
     * @param orgApacheFelixHttpsKeystoreKey@TypeHint 
     * @param orgApacheFelixHttpsKeystoreKeyPassword 
     * @param orgApacheFelixHttpsKeystoreKeyPassword@TypeHint 
     * @param orgApacheFelixHttpsTruststore 
     * @param orgApacheFelixHttpsTruststore@TypeHint 
     * @param orgApacheFelixHttpsTruststorePassword 
     * @param orgApacheFelixHttpsTruststorePassword@TypeHint 
     * @param orgApacheFelixHttpsClientcertificate 
     * @param orgApacheFelixHttpsClientcertificate@TypeHint 
     * @param orgApacheFelixHttpsEnable 
     * @param orgApacheFelixHttpsEnable@TypeHint 
     * @param orgOsgiServiceHttpPortSecure 
     * @param orgOsgiServiceHttpPortSecure@TypeHint 
     
     */
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNio@TypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystore@TypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePassword@TypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKey@TypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPassword@TypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststore@TypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePassword@TypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificate@TypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnable@TypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecure@TypeHint?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (orgApacheFelixHttpsNio !== undefined) {
            queryParameters.push("orgApacheFelixHttpsNio="+encodeURIComponent(String(orgApacheFelixHttpsNio)));
        }
        if (orgApacheFelixHttpsNio@TypeHint !== undefined) {
            queryParameters.push("orgApacheFelixHttpsNio@TypeHint="+encodeURIComponent(String(orgApacheFelixHttpsNio@TypeHint)));
        }
        if (orgApacheFelixHttpsKeystore !== undefined) {
            queryParameters.push("orgApacheFelixHttpsKeystore="+encodeURIComponent(String(orgApacheFelixHttpsKeystore)));
        }
        if (orgApacheFelixHttpsKeystore@TypeHint !== undefined) {
            queryParameters.push("orgApacheFelixHttpsKeystore@TypeHint="+encodeURIComponent(String(orgApacheFelixHttpsKeystore@TypeHint)));
        }
        if (orgApacheFelixHttpsKeystorePassword !== undefined) {
            queryParameters.push("orgApacheFelixHttpsKeystorePassword="+encodeURIComponent(String(orgApacheFelixHttpsKeystorePassword)));
        }
        if (orgApacheFelixHttpsKeystorePassword@TypeHint !== undefined) {
            queryParameters.push("orgApacheFelixHttpsKeystorePassword@TypeHint="+encodeURIComponent(String(orgApacheFelixHttpsKeystorePassword@TypeHint)));
        }
        if (orgApacheFelixHttpsKeystoreKey !== undefined) {
            queryParameters.push("orgApacheFelixHttpsKeystoreKey="+encodeURIComponent(String(orgApacheFelixHttpsKeystoreKey)));
        }
        if (orgApacheFelixHttpsKeystoreKey@TypeHint !== undefined) {
            queryParameters.push("orgApacheFelixHttpsKeystoreKey@TypeHint="+encodeURIComponent(String(orgApacheFelixHttpsKeystoreKey@TypeHint)));
        }
        if (orgApacheFelixHttpsKeystoreKeyPassword !== undefined) {
            queryParameters.push("orgApacheFelixHttpsKeystoreKeyPassword="+encodeURIComponent(String(orgApacheFelixHttpsKeystoreKeyPassword)));
        }
        if (orgApacheFelixHttpsKeystoreKeyPassword@TypeHint !== undefined) {
            queryParameters.push("orgApacheFelixHttpsKeystoreKeyPassword@TypeHint="+encodeURIComponent(String(orgApacheFelixHttpsKeystoreKeyPassword@TypeHint)));
        }
        if (orgApacheFelixHttpsTruststore !== undefined) {
            queryParameters.push("orgApacheFelixHttpsTruststore="+encodeURIComponent(String(orgApacheFelixHttpsTruststore)));
        }
        if (orgApacheFelixHttpsTruststore@TypeHint !== undefined) {
            queryParameters.push("orgApacheFelixHttpsTruststore@TypeHint="+encodeURIComponent(String(orgApacheFelixHttpsTruststore@TypeHint)));
        }
        if (orgApacheFelixHttpsTruststorePassword !== undefined) {
            queryParameters.push("orgApacheFelixHttpsTruststorePassword="+encodeURIComponent(String(orgApacheFelixHttpsTruststorePassword)));
        }
        if (orgApacheFelixHttpsTruststorePassword@TypeHint !== undefined) {
            queryParameters.push("orgApacheFelixHttpsTruststorePassword@TypeHint="+encodeURIComponent(String(orgApacheFelixHttpsTruststorePassword@TypeHint)));
        }
        if (orgApacheFelixHttpsClientcertificate !== undefined) {
            queryParameters.push("orgApacheFelixHttpsClientcertificate="+encodeURIComponent(String(orgApacheFelixHttpsClientcertificate)));
        }
        if (orgApacheFelixHttpsClientcertificate@TypeHint !== undefined) {
            queryParameters.push("orgApacheFelixHttpsClientcertificate@TypeHint="+encodeURIComponent(String(orgApacheFelixHttpsClientcertificate@TypeHint)));
        }
        if (orgApacheFelixHttpsEnable !== undefined) {
            queryParameters.push("orgApacheFelixHttpsEnable="+encodeURIComponent(String(orgApacheFelixHttpsEnable)));
        }
        if (orgApacheFelixHttpsEnable@TypeHint !== undefined) {
            queryParameters.push("orgApacheFelixHttpsEnable@TypeHint="+encodeURIComponent(String(orgApacheFelixHttpsEnable@TypeHint)));
        }
        if (orgOsgiServiceHttpPortSecure !== undefined) {
            queryParameters.push("orgOsgiServiceHttpPortSecure="+encodeURIComponent(String(orgOsgiServiceHttpPortSecure)));
        }
        if (orgOsgiServiceHttpPortSecure@TypeHint !== undefined) {
            queryParameters.push("orgOsgiServiceHttpPortSecure@TypeHint="+encodeURIComponent(String(orgOsgiServiceHttpPortSecure@TypeHint)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/apps/system/config/org.apache.felix.http?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param proxyHost 
     * @param proxyHost@TypeHint 
     * @param proxyPort 
     * @param proxyPort@TypeHint 
     * @param proxyExceptions 
     * @param proxyExceptions@TypeHint 
     * @param proxyEnabled 
     * @param proxyEnabled@TypeHint 
     * @param proxyUser 
     * @param proxyUser@TypeHint 
     * @param proxyPassword 
     * @param proxyPassword@TypeHint 
     
     */
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHost@TypeHint?: string, proxyPort?: number, proxyPort@TypeHint?: string, proxyExceptions?: Array<string>, proxyExceptions@TypeHint?: string, proxyEnabled?: boolean, proxyEnabled@TypeHint?: string, proxyUser?: string, proxyUser@TypeHint?: string, proxyPassword?: string, proxyPassword@TypeHint?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (proxyHost !== undefined) {
            queryParameters.push("proxyHost="+encodeURIComponent(String(proxyHost)));
        }
        if (proxyHost@TypeHint !== undefined) {
            queryParameters.push("proxyHost@TypeHint="+encodeURIComponent(String(proxyHost@TypeHint)));
        }
        if (proxyPort !== undefined) {
            queryParameters.push("proxyPort="+encodeURIComponent(String(proxyPort)));
        }
        if (proxyPort@TypeHint !== undefined) {
            queryParameters.push("proxyPort@TypeHint="+encodeURIComponent(String(proxyPort@TypeHint)));
        }
        if (proxyExceptions) {
            proxyExceptions.forEach((element) => {
                queryParameters.push("proxyExceptions="+encodeURIComponent(String(proxyExceptions)));
            })
        }
        if (proxyExceptions@TypeHint !== undefined) {
            queryParameters.push("proxyExceptions@TypeHint="+encodeURIComponent(String(proxyExceptions@TypeHint)));
        }
        if (proxyEnabled !== undefined) {
            queryParameters.push("proxyEnabled="+encodeURIComponent(String(proxyEnabled)));
        }
        if (proxyEnabled@TypeHint !== undefined) {
            queryParameters.push("proxyEnabled@TypeHint="+encodeURIComponent(String(proxyEnabled@TypeHint)));
        }
        if (proxyUser !== undefined) {
            queryParameters.push("proxyUser="+encodeURIComponent(String(proxyUser)));
        }
        if (proxyUser@TypeHint !== undefined) {
            queryParameters.push("proxyUser@TypeHint="+encodeURIComponent(String(proxyUser@TypeHint)));
        }
        if (proxyPassword !== undefined) {
            queryParameters.push("proxyPassword="+encodeURIComponent(String(proxyPassword)));
        }
        if (proxyPassword@TypeHint !== undefined) {
            queryParameters.push("proxyPassword@TypeHint="+encodeURIComponent(String(proxyPassword@TypeHint)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/apps/system/config/org.apache.http.proxyconfigurator.config?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param alias 
     * @param alias@TypeHint 
     * @param davCreateAbsoluteUri 
     * @param davCreateAbsoluteUri@TypeHint 
     
     */
    public postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postConfigApacheSlingDavExServlet(alias?: string, alias@TypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUri@TypeHint?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (alias !== undefined) {
            queryParameters.push("alias="+encodeURIComponent(String(alias)));
        }
        if (alias@TypeHint !== undefined) {
            queryParameters.push("alias@TypeHint="+encodeURIComponent(String(alias@TypeHint)));
        }
        if (davCreateAbsoluteUri !== undefined) {
            queryParameters.push("davCreateAbsoluteUri="+encodeURIComponent(String(davCreateAbsoluteUri)));
        }
        if (davCreateAbsoluteUri@TypeHint !== undefined) {
            queryParameters.push("davCreateAbsoluteUri@TypeHint="+encodeURIComponent(String(davCreateAbsoluteUri@TypeHint)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param jsonMaximumresults 
     * @param jsonMaximumresults@TypeHint 
     * @param enableHtml 
     * @param enableHtml@TypeHint 
     * @param enableTxt 
     * @param enableTxt@TypeHint 
     * @param enableXml 
     * @param enableXml@TypeHint 
     
     */
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresults@TypeHint?: string, enableHtml?: boolean, enableHtml@TypeHint?: string, enableTxt?: boolean, enableTxt@TypeHint?: string, enableXml?: boolean, enableXml@TypeHint?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (jsonMaximumresults !== undefined) {
            queryParameters.push("jsonMaximumresults="+encodeURIComponent(String(jsonMaximumresults)));
        }
        if (jsonMaximumresults@TypeHint !== undefined) {
            queryParameters.push("jsonMaximumresults@TypeHint="+encodeURIComponent(String(jsonMaximumresults@TypeHint)));
        }
        if (enableHtml !== undefined) {
            queryParameters.push("enableHtml="+encodeURIComponent(String(enableHtml)));
        }
        if (enableHtml@TypeHint !== undefined) {
            queryParameters.push("enableHtml@TypeHint="+encodeURIComponent(String(enableHtml@TypeHint)));
        }
        if (enableTxt !== undefined) {
            queryParameters.push("enableTxt="+encodeURIComponent(String(enableTxt)));
        }
        if (enableTxt@TypeHint !== undefined) {
            queryParameters.push("enableTxt@TypeHint="+encodeURIComponent(String(enableTxt@TypeHint)));
        }
        if (enableXml !== undefined) {
            queryParameters.push("enableXml="+encodeURIComponent(String(enableXml)));
        }
        if (enableXml@TypeHint !== undefined) {
            queryParameters.push("enableXml@TypeHint="+encodeURIComponent(String(enableXml@TypeHint)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param allowEmpty 
     * @param allowEmpty@TypeHint 
     * @param allowHosts 
     * @param allowHosts@TypeHint 
     * @param allowHostsRegexp 
     * @param allowHostsRegexp@TypeHint 
     * @param filterMethods 
     * @param filterMethods@TypeHint 
     
     */
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmpty@TypeHint?: string, allowHosts?: string, allowHosts@TypeHint?: string, allowHostsRegexp?: string, allowHostsRegexp@TypeHint?: string, filterMethods?: string, filterMethods@TypeHint?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (allowEmpty !== undefined) {
            queryParameters.push("allowEmpty="+encodeURIComponent(String(allowEmpty)));
        }
        if (allowEmpty@TypeHint !== undefined) {
            queryParameters.push("allowEmpty@TypeHint="+encodeURIComponent(String(allowEmpty@TypeHint)));
        }
        if (allowHosts !== undefined) {
            queryParameters.push("allowHosts="+encodeURIComponent(String(allowHosts)));
        }
        if (allowHosts@TypeHint !== undefined) {
            queryParameters.push("allowHosts@TypeHint="+encodeURIComponent(String(allowHosts@TypeHint)));
        }
        if (allowHostsRegexp !== undefined) {
            queryParameters.push("allowHostsRegexp="+encodeURIComponent(String(allowHostsRegexp)));
        }
        if (allowHostsRegexp@TypeHint !== undefined) {
            queryParameters.push("allowHostsRegexp@TypeHint="+encodeURIComponent(String(allowHostsRegexp@TypeHint)));
        }
        if (filterMethods !== undefined) {
            queryParameters.push("filterMethods="+encodeURIComponent(String(filterMethods)));
        }
        if (filterMethods@TypeHint !== undefined) {
            queryParameters.push("filterMethods@TypeHint="+encodeURIComponent(String(filterMethods@TypeHint)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/apps/system/config/org.apache.sling.security.impl.ReferrerFilter?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param path 
     * @param name 
     * @param :operation 
     * @param deleteAuthorizable 
     * @param file 
     
     */
    public postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: Blob, observe?: 'body', headers?: Headers): Observable<any>;
    public postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: Blob, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postNode(path: string, name: string, :operation?: string, deleteAuthorizable?: string, file?: Blob, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!path){
            throw new Error('Required parameter path was null or undefined when calling postNode.');
        }

        if (!name){
            throw new Error('Required parameter name was null or undefined when calling postNode.');
        }

        let queryParameters: string[] = [];
        if (:operation !== undefined) {
            queryParameters.push(":operation="+encodeURIComponent(String(:operation)));
        }
        if (deleteAuthorizable !== undefined) {
            queryParameters.push("deleteAuthorizable="+encodeURIComponent(String(deleteAuthorizable)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        let formData: FormData = new FormData();
        headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';
        if (file !== undefined) {
            formData.append('file', <any>file);
        }

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}?${queryParameters.join('&')}`, body, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param path 
     * @param name 
     * @param addMembers 
     
     */
    public postNodeRw(path: string, name: string, addMembers?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postNodeRw(path: string, name: string, addMembers?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postNodeRw(path: string, name: string, addMembers?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!path){
            throw new Error('Required parameter path was null or undefined when calling postNodeRw.');
        }

        if (!name){
            throw new Error('Required parameter name was null or undefined when calling postNodeRw.');
        }

        let queryParameters: string[] = [];
        if (addMembers !== undefined) {
            queryParameters.push("addMembers="+encodeURIComponent(String(addMembers)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}.rw.html?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param path 
     * @param jcr:primaryType 
     * @param :name 
     
     */
    public postPath(path: string, jcr:primaryType: string, :name: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postPath(path: string, jcr:primaryType: string, :name: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postPath(path: string, jcr:primaryType: string, :name: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!path){
            throw new Error('Required parameter path was null or undefined when calling postPath.');
        }

        if (!jcr:primaryType){
            throw new Error('Required parameter jcr:primaryType was null or undefined when calling postPath.');
        }

        if (!:name){
            throw new Error('Required parameter :name was null or undefined when calling postPath.');
        }

        let queryParameters: string[] = [];
        if (jcr:primaryType !== undefined) {
            queryParameters.push("jcr:primaryType="+encodeURIComponent(String(jcr:primaryType)));
        }
        if (:name !== undefined) {
            queryParameters.push(":name="+encodeURIComponent(String(:name)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/${encodeURIComponent(String(path))}/?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     
     */
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'body', headers?: Headers): Observable<string>;
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<string>>;
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!path){
            throw new Error('Required parameter path was null or undefined when calling postQuery.');
        }

        if (!pLimit){
            throw new Error('Required parameter pLimit was null or undefined when calling postQuery.');
        }

        if (!_1property){
            throw new Error('Required parameter _1property was null or undefined when calling postQuery.');
        }

        if (!_1propertyValue){
            throw new Error('Required parameter _1propertyValue was null or undefined when calling postQuery.');
        }

        let queryParameters: string[] = [];
        if (path !== undefined) {
            queryParameters.push("path="+encodeURIComponent(String(path)));
        }
        if (pLimit !== undefined) {
            queryParameters.push("pLimit="+encodeURIComponent(String(pLimit)));
        }
        if (_1property !== undefined) {
            queryParameters.push("_1property="+encodeURIComponent(String(_1property)));
        }
        if (_1propertyValue !== undefined) {
            queryParameters.push("_1propertyValue="+encodeURIComponent(String(_1propertyValue)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<string>> = this.httpClient.post(`${this.basePath}/bin/querybuilder.json?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <string>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param ignoredeactivated 
     * @param onlymodified 
     * @param path 
     
     */
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!ignoredeactivated){
            throw new Error('Required parameter ignoredeactivated was null or undefined when calling postTreeActivation.');
        }

        if (!onlymodified){
            throw new Error('Required parameter onlymodified was null or undefined when calling postTreeActivation.');
        }

        if (!path){
            throw new Error('Required parameter path was null or undefined when calling postTreeActivation.');
        }

        let queryParameters: string[] = [];
        if (ignoredeactivated !== undefined) {
            queryParameters.push("ignoredeactivated="+encodeURIComponent(String(ignoredeactivated)));
        }
        if (onlymodified !== undefined) {
            queryParameters.push("onlymodified="+encodeURIComponent(String(onlymodified)));
        }
        if (path !== undefined) {
            queryParameters.push("path="+encodeURIComponent(String(path)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/etc/replication/treeactivation.html?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param :operation 
     * @param newPassword 
     * @param rePassword 
     * @param keyStoreType 
     * @param removeAlias 
     * @param certificate 
     
     */
    public postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Blob, observe?: 'body', headers?: Headers): Observable<string>;
    public postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Blob, observe?: 'response', headers?: Headers): Observable<HttpResponse<string>>;
    public postTruststore(:operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Blob, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (:operation !== undefined) {
            queryParameters.push(":operation="+encodeURIComponent(String(:operation)));
        }
        if (newPassword !== undefined) {
            queryParameters.push("newPassword="+encodeURIComponent(String(newPassword)));
        }
        if (rePassword !== undefined) {
            queryParameters.push("rePassword="+encodeURIComponent(String(rePassword)));
        }
        if (keyStoreType !== undefined) {
            queryParameters.push("keyStoreType="+encodeURIComponent(String(keyStoreType)));
        }
        if (removeAlias !== undefined) {
            queryParameters.push("removeAlias="+encodeURIComponent(String(removeAlias)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'text/plain';

        let formData: FormData = new FormData();
        headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';
        if (certificate !== undefined) {
            formData.append('certificate', <any>certificate);
        }

        const response: Observable<HttpResponse<string>> = this.httpClient.post(`${this.basePath}/libs/granite/security/post/truststore?${queryParameters.join('&')}`, body, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <string>(httpResponse.response));
        }
        return response;
    }


    /**
     * 
     * 
     * @param truststoreP12 
     
     */
    public postTruststorePKCS12(truststoreP12?: Blob, observe?: 'body', headers?: Headers): Observable<string>;
    public postTruststorePKCS12(truststoreP12?: Blob, observe?: 'response', headers?: Headers): Observable<HttpResponse<string>>;
    public postTruststorePKCS12(truststoreP12?: Blob, observe: any = 'body', headers: Headers = {}): Observable<any> {
        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'text/plain';

        let formData: FormData = new FormData();
        headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';
        if (truststoreP12 !== undefined) {
            formData.append('truststore.p12', <any>truststoreP12);
        }

        const response: Observable<HttpResponse<string>> = this.httpClient.post(`${this.basePath}/etc/truststore`, body, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <string>(httpResponse.response));
        }
        return response;
    }

}
